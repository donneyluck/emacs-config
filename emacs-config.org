:properties:
:path:     ~/.emacs.d/
:header-args: :tangle (concat (org-entry-get nil "path" t) (org-get-heading)) :mkdirp yes :comment no
:end:
#+title: Emacs 配置文件
#+author: donney.luck
#+date: 2023/04/15 14:23:50
#+startup: overview nohideblocks
* early-init.el
=early-init.el= 在Emacs刚启动，还未加载主要配置文件时的配置文件。

#+begin_src emacs-lisp
;;; early-init.el --- MinEmacs early initialization tweaks -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:

(setq
 ;; Do not make installed packages available when Emacs starts
 package-enable-at-startup nil
 ;; HACK: Increase the garbage collection (GC) threshold for faster startup.
 ;; This will be overwritten when `gcmh-mode' (a.k.a. the Garbage Collector
 ;; Magic Hack) gets loaded in the `me-gc' module (see "init.el").
 gc-cons-threshold most-positive-fixnum
 ;; Prefer loading newer files
 load-prefer-newer t
 ;; Remove some unneeded UI elements
 default-frame-alist '((tool-bar-lines . 0)
                       (menu-bar-lines . 0)
                       (vertical-scroll-bars)
                       (mouse-color . "blue")
                       (left-fringe . 8)
                       (right-fringe . 13)
                       (fullscreen . maximized))
 ;; Explicitly set modes disabled in `default-frame-alist' to nil
 tool-bar-mode nil
 menu-bar-mode nil
 scroll-bar-mode nil)

;; NOTE: In Emacs29+, frames can have a transparent background via the
;; `alpha-background' parameter. For a better experience, this value should be
;; set early before any frame gets created (i.e. in "early-init.el"). MinEmacs
;; uses the "$MINEMACS_ALPHA" environment variable that can be set to an integer
;; value in the [1-100] range (the alpha percentage). When this variable is not
;; set, Emacs will load the default GUI (without background alpha), and when it
;; is set but the value is not valid, MinEmacs will fallback to the default
;; alpha of 93%.
(when (>= emacs-major-version 29)
  (when-let* ((alpha (getenv "MINEMACS_ALPHA"))
              (alpha (string-to-number alpha)))
    (push (cons 'alpha-background (if (or (zerop alpha) (> alpha 100)) 93 alpha))
          default-frame-alist)))

;; HACK: In `lsp-mode' (see the `me-lsp' module), the user can define the
;; "$LSP_USE_PLISTS=true" to improve `lsp-mode' performances. We set this
;; environment variable here so we don't need to add it to the system's
;; environment variables.
(setenv "LSP_USE_PLISTS" "true")

;; Load MinEmacs variables from the `me-vars' core module.
(load (expand-file-name "core/me-vars.el" (file-name-directory (file-truename load-file-name))) nil t)

;; Load the user early configuration file from "$MINEMACSDIR/early-config.el"
;; if it exists.
(let ((early-config-path (concat minemacs-config-dir "early-config.el")))
  (when (file-exists-p early-config-path)
    (load early-config-path nil (not minemacs-verbose))))

;;; early-init.el ends here
#+end_src

* init.el
=init.el= 是Emacs的主要配置文件。

文件头

#+begin_src emacs-lisp
;; init.el --- MinEmacs core initialization file -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

版本检测

#+begin_src emacs-lisp
;; Check if Emacs version is supported. You can define the
;; $MINEMACS_IGNORE_VERSION_CHECK environment variable to ignore this check.
;; This can be useful if you are stuck with an old Emacs version and you've
;; incrementally implemented the new Emacs routines MinEmacs needs in your
;; "init-tweaks.el".
(let ((min-ver "28.0"))
  (when (and (version< emacs-version min-ver) (not (getenv "MINEMACS_IGNORE_VERSION_CHECK")))
    (error "Emacs v%s is not supported, MinEmacs requires v%s or higher" emacs-version min-ver)))
#+end_src

提高启动速度

#+begin_src emacs-lisp
;; PERF: Setting `file-name-handler-alist' to nil should boost startup time.
;; reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start
;; Store the current value so we can reset it after Emacs startup.
(put 'file-name-handler-alist 'original-value (default-toplevel-value 'file-name-handler-alist))
;; Make sure the new value survives any current let-binding.
(set-default-toplevel-value 'file-name-handler-alist nil)
;; After Emacs startup, we restore `file-name-handler-alist' while conserving
;; the potential edits made during startup.
(add-hook
 'emacs-startup-hook
 (defun +mineamcs--restore-file-name-handler-alist-h ()
   (setq file-name-handler-alist
         (delete-dups
          (append file-name-handler-alist
                  (get 'file-name-handler-alist 'original-value)))))
 101)
#+end_src

载入定义的vars

#+begin_src emacs-lisp
;; HACK: At this point, MinEmacs variables defined in `me-vars' should be
;; already loaded (in "early-init.el"). However, we double-check here and load
;; them if necessary in case Emacs has been loaded directly from "init.el"
;; without passing by "early-init.el". This can happen when we are running in a
;; `me-org-export-async-init' context, or if we use some bootstrapping mechanism
;; like Chemacs2.
(unless (featurep 'me-vars)
  (load (expand-file-name "core/me-vars.el" (file-name-directory (file-truename load-file-name))) nil t))

(defun +load (&rest filename-parts)
  "Load a file, the FILENAME-PARTS are concatenated to form the file name."
  (let ((filename (mapconcat #'identity filename-parts nil)))
    (if (file-exists-p filename)
        (load filename nil (not minemacs-verbose))
      (user-error "[MinEmacs:Error] Cannot load \"%s\", the file doesn't exists." filename))))

;; HACK: Most core and third-party packages depends on the
;; `user-emacs-directory' variable to store some cache information and generated
;; configuration files. However, this will mess with MinEmacs' directory (which
;; defaults to `user-emacs-directory'). To keep the "~/.emacs.d/" directory
;; clean, we overwrite the `user-emacs-directory' with `minemacs-local-dir' so
;; all generated files gets stored in "~/.emacs.d/local/".
;; BUG: It is important to set this here and not in `me-vars' nor in
;; "early-init.el", otherwise, it won't work with Chemacs2-based installations.
(setq user-emacs-directory minemacs-local-dir)
#+end_src

当emacs版本小于29 则需要加载兼容函数

#+begin_src emacs-lisp
;; HACK: Load Emacs 29 back ports for earlier Emacs versions. Note that I do
;; only back port a very small number of the functions/variables that I use at
;; early stage from Emacs29+ to be compatible with Emacs 28.2. For any Emacs
;; version less than 29, MinEmacs will enable the `me-compat' module and load it
;; just after `me-bootstrap'. This module loads the `compat' package which
;; provide several forward compatibility functions, it is loaded at an early
;; stage to provide its functionality to the rest of the modules so we can use
;; some new features when configuring them.
(when (< emacs-major-version 29)
  (+load minemacs-core-dir "me-backports-29.el"))
#+end_src

设置警告等级 是否开启debug-on-error

#+begin_src emacs-lisp
(setq
 ;; Enable debugging on error when Emacs is launched with the "--debug-init"
 ;; option or when the environment variable "$MINEMACS_DEBUG" is defined (see
 ;; `me-vars').
 debug-on-error minemacs-debug
 ;; Decrese the warning type to `:error', unless we are running in verbose mode
 warning-minimum-level (if minemacs-verbose :warning :error)
 warning-minimum-log-level warning-minimum-level
 ;; Make byte compilation less noisy
 byte-compile-warnings minemacs-verbose
 byte-compile-verbose minemacs-verbose)
#+end_src

=native-compile= 是 Emacs 28 版本引入的一个特性，它允许将 Emacs Lisp 代码编译为本机机器代码，从而提高 Emacs 的性能和启动速度。
通过 =native-compile= Emacs Lisp 代码可以直接编译为本机机器码，而不是以解释器方式执行, 这样可以显著提高代码的执行速度。
编译后的代码可以保存在文件中，以便下次启动时直接加载，避免重新编译。

#+begin_src emacs-lisp
;; Native compilation settings
(when (featurep 'native-compile)
  (setq
   ;; Silence compiler warnings as they can be pretty disruptive, unless we are
   ;; running in `minemacs-verbose' mode.
   native-comp-async-report-warnings-errors (when minemacs-verbose 'silent)
   native-comp-verbose (if minemacs-verbose 1 0) ; do not be too verbose
   native-comp-debug (if minemacs-debug 1 0)
   ;; Make native compilation happens asynchronously.
   native-comp-jit-compilation t)

  ;; Set the right directory to store the native compilation cache to avoid
  ;; messing with "~/.emacs.d/".
  (startup-redirect-eln-cache (concat minemacs-cache-dir "eln/")))

#+end_src

增加一些目录为load-path

#+begin_src emacs-lisp
;; Add some of MinEmacs' directories to `load-path'.
(setq load-path (append (list minemacs-core-dir minemacs-elisp-dir minemacs-extras-dir) load-path))
#+end_src

增加一个函数 自动收集目录下的autoload函数到 =minemacs-loaddefs-file= 文件(不存在就执行)

#+begin_src emacs-lisp
(defun minemacs-generate-loaddefs ()
  "Generate MinEmacs' loaddefs file."
  (interactive)
  (when (file-exists-p minemacs-loaddefs-file)
    (delete-file minemacs-loaddefs-file))

  (loaddefs-generate
   (list minemacs-core-dir minemacs-elisp-dir minemacs-extras-dir)
   minemacs-loaddefs-file))

;; Some of MinEmacs commands and libraries are defined to be auto-loaded. In
;; particular, these in the `minemacs-core-dir', `minemacs-elisp-dir', and
;; `minemacs-extras-dir' directories. The generated loaddefs file will be stored
;; in `minemacs-loaddefs-file'. We first regenerate the loaddefs file if it
;; doesn't exist.
(unless (file-exists-p minemacs-loaddefs-file)
  (minemacs-generate-loaddefs))

;; Then we load the loaddefs file
(+load minemacs-loaddefs-file)
#+end_src

init-tweaks.el  init.el后执行 用户可以微调

#+begin_src emacs-lisp
;; Load user init tweaks from "$MINEMACSDIR/init-tweaks.el" when available
(let ((user-init-tweaks (concat minemacs-config-dir "init-tweaks.el")))
  (when (file-exists-p user-init-tweaks)
    (+load user-init-tweaks)))
#+end_src

环境变量的解决方案 通过 =+env_save= 保存 启动的时候通过 =+env_load= 载入

#+begin_src emacs-lisp
;; HACK: When Emacs is launched from the terminal (in GNU/Linux), it inherits
;; the terminal's environment variables, which can be useful specially for
;; running commands under a custom "$PATH" directory. But when Emacs is launched
;; from the desktop manager (KDE, Gnome, etc.), it can omit the terminal's
;; environment variables. The way I solve this is by launching Emacs from
;; terminal, which gives Emacs the full environment variables of the invoking
;; terminal. Then I call the `+env-save' command, which reads the environment
;; variables defined in `+env-save-vars' and stores them in
;; "~/.emacs.d/local/system-env.el". This file is then loaded in the future
;; Emacs sessions (launched either from terminal or from GUI) by calling the
;; `+env-load' command.
(+env-load) ; Load environment variables when available.
#+end_src

加载 Emacs 后，emacs-startup-hook 被执行，我们使用这个钩子来分析启动时间，加载字体和主题，
并设置 *scratch* 缓冲区内容, 最后 require =minemacs-loaded= 这个虚拟模块来控制延迟加载

#+begin_src emacs-lisp
;; NOTE: This is MinEmacs' synchronization point. To get a fast Emacs startup,
;; MinEmacs tries to defer loading most of its packages until this hook is
;; executed. This is managed by the `minemacs-loaded' and `minemacs-lazy'
;; pseudo-modules. After loading Emacs, the `emacs-startup-hook' gets executed,
;; we use this hook to profile the startup time, load the fonts and the theme,
;; and setup the *scratch* buffer content. Lastly we require the
;; `minemacs-loaded' synchronization module, which runs internally the
;; `minemacs-after-startup-hook' hooks and provide `minemacs-loaded' so the
;; packages loaded with `:after minemacs-loaded' can be loaded. The
;; `minemacs-loaded' will require `minemacs-lazy' when Emacs goes idle, this
;; pseudo-module provides `minemacs-lazy' so the packages loaded with `:after
;; minemacs-lazy' can be loaded then it incrementally run the hooks in
;; `minemacs-lazy-hook' when Emacs goes idle.
(defun +minemacs--loaded-h ()
  (+log! "=============== Loaded Emacs ===============")
  (+info! "Loaded Emacs in %s." (emacs-init-time))

  ;; When running in an async Org export context, there is no need to set
  ;; the fonts, load the theme or play with the scratch buffer.
  (unless (featurep 'me-org-export-async-init)
    (+log! "Applying `minemacs-fonts'.")
    ;; Load fonts, values are read from `minemacs-fonts' if set in config.el,
    ;; otherwise, they are read from the default `minemacs-default-fonts'.
    (+set-fonts)

    ;; Initially MinEmacs loads the `doom-one-light' theme, and when
    ;; `minemacs-theme' is set in user configuration, it is loaded here.
    (+load-theme)

    (+log! "Filling scratch buffer content.")
    (+fill-scratch-buffer)

    ;; In `me-defaults', the `initial-major-mode' is set to `fundamental-mode'
    ;; to enhance startup time. However, I like to use the scratch buffer to
    ;; evaluate Elisp code, so we switch to Elisp mode in the scratch buffer
    ;; when Emacs is idle for 10 seconds.
    (+eval-when-idle-for! 10.0
      (setq initial-major-mode 'lisp-interaction-mode)
      (with-current-buffer (get-scratch-buffer-create)
        (emacs-lisp-mode))))

  ;; Require the virtual package to triggre loading packages depending on it
  (require 'minemacs-loaded))

;; Add it to the very begining of `emacs-startup-hook'
(add-hook 'emacs-startup-hook #'+minemacs--loaded-h -101)
#+end_src

载入 =packages= 和 =user customization=

#+begin_src emacs-lisp
;; ========= Load MinEmacs packages and user customization =========
;; When running in an async Org export context, the used modules are set in
;; modules/extras/me-org-export-async-init.el, so we must not overrite them with
;; the user's enabled modules.
(if (featurep 'me-org-export-async-init)
    (progn (message "Loading \"init.el\" in an org-export-async context.")
           (setq minemacs-not-lazy t)
           (require 'minemacs-loaded))
  ;; Load the default list of enabled modules (`minemacs-modules' and `minemacs-core-modules')
  (+load minemacs-core-dir "me-modules.el")

  ;; The modules.el file can override minemacs-modules and minemacs-core-modules
  (let ((user-conf-modules (concat minemacs-config-dir "modules.el")))
    (when (file-exists-p user-conf-modules)
      (+load user-conf-modules))))

;; Load fonts early (they are read from the default `minemacs-default-fonts').
(+set-fonts)

;; NOTE: Ensure the `me-gc' module is in the core modules list. This module
;; enables the `gcmh-mode' package (a.k.a. the Garbage Collector Magic Hack).
;; This GCMH minimizes GC interference with the activity by using a high GC
;; threshold during normal use, then when Emacs is idling, GC is triggered and a
;; low threshold is set. In MinEmacs, we set the threshold (`gc-cons-threshold'
;; variable) to an unlimited size in "early-init.el", this helps improving the
;; startup time, but needs to be set down to a more reasonable value after Emacs
;; gets loaded. The use of `gcmh-mode' ensures reverting this value so we don't
;; need to do it manually.
;; NOTE: Ensure the `me-defaults', `me-splash', `me-bootstrap' and `me-compat'
;; modules are in the right order. The `me-compat' should be loaded just after
;; `me-bootstrap' once `straight' and `use-package' are set up. This enables us
;; to use some of the new Emacs 29 functions even on earlier Emacs versions,
;; this can be useful when configuring the module's packages and adding new
;; functionality.
(setq minemacs-core-modules
      (delete-dups
       (append
        '(me-defaults)
        (when (memq 'me-splash minemacs-core-modules) '(me-splash))
        '(me-bootstrap)
        (when (< emacs-major-version 29) '(me-compat))
        '(me-builtin me-gc)
        minemacs-core-modules)))

;; Load MinEmacs modules
(dolist (module-file (append
                      (mapcar (apply-partially #'format "%s%s.el" minemacs-core-dir) minemacs-core-modules)
                      (mapcar (apply-partially #'format "%s%s.el" minemacs-modules-dir) minemacs-modules)))
  (+load module-file))

;; Write user custom variables to separate file instead of "init.el"
(setq custom-file (concat minemacs-config-dir "custom-vars.el"))

;; Load the custom variables file if it exists
(when (file-exists-p custom-file)
  (+load custom-file))

;; Load user configuration from "$MINEMACSDIR/config.el" when available
(let ((user-config (concat minemacs-config-dir "config.el")))
  (when (file-exists-p user-config)
    (+load user-config)))

(+lazy-when! (featurep 'native-compile)
  (+info! "Trying to clean outdated native compile cache")
  ;; Delete outdated natively compiled files when Emacs become idle
  (+shutup! (native-compile-prune-cache)))

(+log! "Loaded init.el")
#+end_src

文件尾

#+begin_src emacs-lisp
;;; init.el ends here
#+end_src

* core/
:properties:
:path:     ~/.emacs.d/core/
:end:
=core= 目录下是框架的核心配置
** me-backports-29.el
=me-backports-29.el= 一些emacs29的函数

文件头

#+begin_src emacs-lisp
;;; me-backports-29.el --- Some Emacs 29 functionalities ported back to Emacs 28 -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; MinEmacs is distributed under the MIT license. However, this file is mostly a
;; copy-and-paste from Emacs 29 with some adaptations, hence, it is licensed
;; with original Emacs GNU GPL-3.0 license.

;;; Code:
#+end_src

一些emacs29才有的函数

#+begin_src emacs-lisp
(unless (= emacs-major-version 28)
  (user-error "This file should only be called from an Emacs 28.x"))

(require 'wid-edit) ;; Needed by `setopt--set'

;; This macro is provided by `compat'. However, it is used in some core
;; functions which might get called before `me-bootstrap' and `me-compat'.
(defmacro with-memoization (place &rest code)
  "Return the value of CODE and stash it in PLACE.
If PLACE's value is non-nil, then don't bother evaluating CODE
and return the value found in PLACE instead."
  (declare (indent 1) (debug (gv-place body)))
  (gv-letplace (getter setter) place
    `(or
      ,getter
      ,(macroexp-let2 nil val (macroexp-progn code)
        `(progn
           ,(funcall setter val)
           ,val)))))

;; Functions not provided by `compat'
(defun startup-redirect-eln-cache (cache-directory)
  "Redirect the user's eln-cache directory to CACHE-DIRECTORY.
CACHE-DIRECTORY must be a single directory, a string.
This function destructively changes `native-comp-eln-load-path'
so that its first element is CACHE-DIRECTORY.  If CACHE-DIRECTORY
is not an absolute file name, it is interpreted relative
to `user-emacs-directory'.
For best results, call this function in your early-init file,
so that the rest of initialization and package loading uses
the updated value."
  ;; Remove the original eln-cache.
  (setq native-comp-eln-load-path (cdr native-comp-eln-load-path))
  ;; Add the new eln-cache.
  (push (expand-file-name (file-name-as-directory cache-directory)
                          user-emacs-directory)
        native-comp-eln-load-path))

(defun scratch-buffer ()
  "Switch to the *scratch* buffer.
If the buffer doesn't exist, create it first."
  (interactive)
  (pop-to-buffer-same-window (get-scratch-buffer-create)))

(defun native-compile-prune-cache ()
  "Remove .eln files that aren't applicable to the current Emacs invocation."
  (interactive)
  (unless (featurep 'native-compile)
    (user-error "This Emacs isn't built with native-compile support"))
  ;; The last item in native-comp-eln-load-path is assumed to be a system
  ;; directory, so don't try to delete anything there (bug#59658).
  (dolist (dir (butlast native-comp-eln-load-path))
    ;; If a directory is non absolute it is assumed to be relative to
    ;; `invocation-directory'.
    (setq dir (expand-file-name dir invocation-directory))
    (when (file-exists-p dir)
      (dolist (subdir (seq-filter
                       (lambda (f) (not (string-match (rx "/." (? ".") eos) f)))
                       (directory-files dir t)))
        (when (and (file-directory-p subdir)
                   (file-writable-p subdir)
                   (not (equal (file-name-nondirectory
                                (directory-file-name subdir))
                               comp-native-version-dir)))
          (message "Deleting `%s'..." subdir)
          ;; We're being overly cautious here -- there shouldn't be
          ;; anything but .eln files in these directories.
          (dolist (eln (directory-files subdir t "\\.eln\\(\\.tmp\\)?\\'"))
            (when (file-writable-p eln)
              (delete-file eln)))
          (when (directory-empty-p subdir)
            (delete-directory subdir))))))
  (message "Cache cleared"))

(defmacro setopt (&rest pairs)
  "Set VARIABLE/VALUE pairs, and return the final VALUE.
This is like `setq', but is meant for user options instead of
plain variables.  This means that `setopt' will execute any
`custom-set' form associated with VARIABLE.
\(fn [VARIABLE VALUE]...)"
  (declare (debug setq))
  (unless (zerop (mod (length pairs) 2))
    (error "PAIRS must have an even number of variable/value members"))
  (let ((expr nil))
    (while pairs
      (unless (symbolp (car pairs))
        (error "Attempting to set a non-symbol: %s" (car pairs)))
      (push `(setopt--set ',(car pairs) ,(cadr pairs))
            expr)
      (setq pairs (cddr pairs)))
    (macroexp-progn (nreverse expr))))

(defun setopt--set (variable value)
  (custom-load-symbol variable)
  ;; Check that the type is correct.
  (when-let ((type (get variable 'custom-type)))
    (unless (widget-apply (widget-convert type) :match value)
      (warn "Value `%S' does not match type %s" value type)))
  (put variable 'custom-check-value (list value))
  (funcall (or (get variable 'custom-set) #'set-default) variable value))

;; Variable aliases
(when (featurep 'native-compile)
  (defvaralias 'native-comp-jit-compilation 'native-comp-deferred-compilation)
  (defvaralias 'native-comp-jit-compilation-deny-list 'native-comp-deferred-compilation-deny-list))

(defvar messages-buffer-name "*Messages*")

;; Function aliases
(defalias 'string-split #'split-string)
(defalias 'loaddefs-generate #'make-directory-autoloads)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-backports-29)
;;; me-backports-29.el ends here
#+end_src

** me-bootstrap.el
=me-bootstrap.el= 设置包下载器和包安装器

文件头

#+begin_src emacs-lisp
;; me-bootstrap.el --- Bootstrap packages (straight & use-package) -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

安装 =straight= 包下载器

#+begin_src emacs-lisp
(setq
 ;; Base directory
 straight-base-dir minemacs-local-dir
 ;; Add Emacs version and the Git hash to the build directory to avoid problems
 straight-build-dir (format "build-%s%s" emacs-version
                            (if emacs-repository-version
                                (format "-%s" (substring emacs-repository-version 0 8))
                              ""))
 ;; Use the "develop" branch on straight.el's repo.
 straight-repository-branch "develop"
 ;; Do not slow startup by checking for package modifs, check only on demand
 straight-check-for-modifications '(check-on-save find-when-checking))

;; Bootstraping straight.el
;; See: github.com/radian-software/straight.el#bootstrapping-straightel
(defvar bootstrap-version)
(let ((bootstrap-file (concat straight-base-dir "straight/repos/straight.el/bootstrap.el"))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

安装 =use-package= 包管理器

#+begin_src emacs-lisp
;; Configure `use-package'
(unless (require 'use-package nil t)
  (straight-use-package 'use-package))

(setq
 ;; Set `use-package' to verbose when MinEmacs is started in verbose mode
 use-package-verbose minemacs-verbose
 ;; Defer loading packages by default, use `:demand' to force loading a package
 use-package-always-defer t)
#+end_src

安装 =use-package= 扩展 =:pin-ref=

#+begin_src emacs-lisp
;; Add the `:pin-ref' extension to `use-package'
(require 'me-use-package-pin-ref)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-bootstrap)
;;; me-bootstrap.el ends here
#+end_src

** me-builtin.el
=me-builtin.el= 管理一些内置包

文件头

#+begin_src emacs-lisp
;;; me-builtin.el --- Customization of some of Emacs' builtin libraries -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

一些内置的包

#+begin_src emacs-lisp
(use-package transient
  :straight (:type built-in)
  :config
  ;; Map ESC and q to quit transient
  (define-key transient-map [escape]  #'transient-quit-one)
  (define-key transient-map (kbd "q") #'transient-quit-one))

(use-package map
  :straight (:type built-in))

(use-package let-alist
  :straight (:type built-in))

(use-package password-cache
  :straight (:type built-in)
  :custom
  (password-cache t) ; Enable password caching
  (password-cache-expiry 60)) ; One minute, default is 16

(use-package auth-source
  :straight (:type built-in)
  :custom
  (auth-sources '("~/.authinfo.gpg")) ; Default auth-sources to GPG
  (auth-source-do-cache t) ; Enable caching, do not keep asking about GPG key
  (auth-source-cache-expiry 86400)) ; All day, default is 2h (7200)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-builtin)
;;; me-builtin.el ends here
#+end_src

** me-compat.el
=me-compat.el= 提供兼容的能力

文件头

#+begin_src emacs-lisp
;;; me-compat.el --- Emacs forward compatibility layer -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

[[https://github.com/emacs-compat/compat][compat]]  包是一个用于提供 Emacs 版本兼容性的库。它旨在简化在不同版本的 Emacs 上编写可移植代码的过程。
具体而言，compat 包提供了一些宏和函数，这些宏和函数在不同版本的 Emacs上具有不同的行为，并且它们会根据当前运行的 Emacs 版本选择合适的实现。

#+begin_src emacs-lisp
(use-package compat
  :straight t
  :demand t)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-compat)
;;; me-compat.el ends here
#+end_src

** me-completion.el
=me-completion.el= 补全相关配置

文件头

#+begin_src emacs-lisp
;;; completion.el --- Completion packages -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

package [[https://github.com/minad/cape/][cape]]  完成后端

#+begin_src emacs-lisp
(use-package cape
  :straight t
  :after minemacs-loaded
  :demand t
  :config
  (dolist (fn '(cape-file cape-ispell cape-symbol cape-keyword))
    (add-to-list 'completion-at-point-functions fn)))
#+end_src

package [[https://github.com/minad/corfu][corfu]] 完成前端

#+begin_src emacs-lisp
(use-package corfu
  :straight t
  :hook (minemacs-after-startup . global-corfu-mode)
  :init
  (add-to-list
   'load-path
   (format "%sstraight/%s/corfu/extensions" straight-base-dir straight-build-dir))
  :custom
  (corfu-auto t) ; Enable auto completion
  (corfu-cycle t) ; Allows cycling through candidates
  (corfu-min-width 25)
  (corfu-auto-delay 0.2)
  :config
  (with-eval-after-load 'evil
    (define-key corfu-map (kbd "C-j") #'corfu-next)
    (define-key corfu-map (kbd "C-k") #'corfu-previous))

  (defun +corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (setq-local corfu-auto nil) ; Enable/disable auto completion
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'+corfu-enable-in-minibuffer))
#+end_src

package [[https://elpa.gnu.org/packages/corfu.html][corfu extensions]]

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom
  (corfu-popupinfo-delay 0.1)
  (corfu-popupinfo-max-height 15)
  :config
  (define-key corfu-map (kbd "M-p") #'corfu-popupinfo-scroll-down)
  (define-key corfu-map (kbd "M-n") #'corfu-popupinfo-scroll-up)
  (define-key corfu-map (kbd "M-d") #'corfu-popupinfo-toggle))

(use-package corfu-history
  :hook (corfu-mode . corfu-history-mode)
  :config
  (unless (bound-and-true-p savehist-mode)
    (savehist-mode 1))
  (add-to-list 'savehist-additional-variables 'corfu-history))

(use-package corfu-terminal
  :straight t
  :hook (corfu-mode . corfu-terminal-mode))
#+end_src

package [[https://github.com/jdtsmith/kind-icon][kind-icon]] 图标和完成前缀

#+begin_src emacs-lisp
(use-package kind-icon
  :straight t
  :after corfu
  :demand t
  :custom
  (kind-icon-default-style '(:padding 0
                             :stroke 0
                             :margin 0
                             :radius 0
                             :height 0.8
                             :scale 1.05)) ; Fix the scaling/height
  (kind-icon-use-icons (+emacs-features-p 'rsvg)) ; Use icons only in Emacs built with SVG support
  (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face          background
  (kind-icon-blend-background nil) ; Use midpoint color between foreground and background colors       ("blended")?
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

package [[https://github.com/minad/consult][consult]] 搜索和导航

#+begin_src emacs-lisp
(use-package consult
  :straight t
  :demand t
  :hook (embark-collect-mode . consult-preview-at-point-mode)
  :custom
  ;; Use `consult-xref' for `xref-find-references'
  (xref-show-xrefs-function #'consult-xref)
  ;; Better formatting for `view-register'
  (register-preview-function #'consult-register-format)
  :init
  (define-key minibuffer-local-map (kbd "C-r") #'consult-history)
  (define-key minibuffer-local-map (kbd "S-C-v") #'consult-yank-pop)
  (global-set-key (kbd "C-s") #'consult-line)
  (+map!
    ;; buffer
    "bl"  #'consult-line
    "bb"  #'consult-buffer
    "bB"  #'consult-buffer-other-window
    "bF"  #'consult-buffer-other-frame
    "bmM" #'consult-bookmark
    "si"  #'consult-imenu
    "bO"  #'consult-outline
    ;; file
    "fr"  #'consult-recent-file
    ;; git/vc
    "gG"  #'consult-git-grep
    ;; search
    "ss"  #'consult-ripgrep
    "sg"  #'consult-grep
    "sf"  #'consult-find
    "sM"  #'consult-man
    "st"  #'consult-locate
    "sh"  #'consult-history
    "sa"  #'consult-org-agenda
    ;; project
    "pl"  #'consult-line-multi
    "pi"  #'consult-imenu-multi
    ;; code
    "cm"  #'consult-flymake
    "cE"  #'consult-compile-error
    ;; unclassified
    "xc"  #'consult-complex-command
    ;; insert
    "iy"  #'consult-yank-from-kill-ring
    "ir"  '(nil :wk "register")
    "irr" #'consult-register
    "irl" #'consult-register-load
    "irs" #'consult-register-store
    ;; help
    "hu"  #'consult-theme
    "hI"  #'consult-info)
  (+map-local! :keymaps 'org-mode-map
    "h"   #'consult-org-heading)
  :config
  (setq-default completion-in-region-function #'consult-completion-in-region)

  ;; TWEAK: Fill the `initial' query of `consult' commands from
  ;; `thing-at-point'.
  ;; NOTE: Some `consult' commands have slightly different signature, the
  ;; `initial' argument can come first in some cases (like `consult-line') or
  ;; second in some other cases (like `condult-grep'). These two advices are
  ;; added to such family of commands so it is filled in the right place.
  (dolist (cmd '(consult-line ; `initial' comes first in these commands
                 consult-man))
    (advice-add
     cmd :around
     (defun +consult--dwim-first-arg-a (orig-fn &optional initial opt)
       (apply orig-fn
              (append
               (if (and (called-interactively-p) (not (minibufferp)))
                   (list (or initial (+region-or-thing-at-point)))
                 (list initial))
               (when opt (list opt)))))))

  (dolist (cmd '(consult-ripgrep ; `initial' comes second in these commands
                 consult-line-multi
                 consult-grep
                 consult-find))
    (advice-add
     cmd :around
     (defun +consult--dwim-second-arg-a (orig-fn &optional dir initial)
       (apply orig-fn
              (append
               (list dir)
               (if (and (called-interactively-p) (not (minibufferp)))
                   (list (or initial (+region-or-thing-at-point)))
                 (list initial))))))))
#+end_src

package [[https://github.com/oantolin/embark][embark]] TODO:
j
#+begin_src emacs-lisp
(use-package embark
  :straight t
  :init
  (global-set-key [remap describe-bindings] #'embark-bindings)
  (setq prefix-help-command #'embark-prefix-help-command)
  (+map! "." #'embark-act))

(use-package embark-consult
  :straight t
  :after embark consult
  :demand t)
#+end_src

package [[https://github.com/minad/marginalia][marginalia]] 旁注

#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :hook (minemacs-after-startup . marginalia-mode))

(use-package nerd-icons-completion
  :straight t
  :hook (marginalia-mode . nerd-icons-completion-mode))
#+end_src

package [[https://github.com/oantolin/orderless][orderless]] 正则匹配

#+begin_src emacs-lisp
(use-package orderless
  :straight t
  :after minemacs-loaded
  :demand t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

package [[https://github.com/minad/vertico][vertico]] 完成UI

#+begin_src emacs-lisp
(use-package vertico
  :straight t
  :hook (minemacs-after-startup . vertico-mode)
  :custom
  (vertico-cycle t)
  (vertico-resize nil)
  (vertico-count 12)
  :init
  (add-to-list
   'load-path (concat
               straight-base-dir
               (format "straight/%s/vertico/extensions" straight-build-dir)))
  ;; In the minibuffer, "C-k" is be mapped to act like "<up>". However, in
  ;; Emacs, "C-k" have a special meaning of `kill-line'. So lets map "C-S-k"
  ;; to serve the original "C-k".
  (define-key minibuffer-local-map (kbd "C-S-k") #'kill-line)
  :config
  (with-eval-after-load 'evil
    (define-key vertico-map (kbd "C-j") #'vertico-next)
    (define-key vertico-map (kbd "C-k") #'vertico-previous)))

(use-package vertico-directory
  :after vertico
  :demand t
  :config
  (define-key vertico-map "\r" #'vertico-directory-enter)
  (define-key vertico-map "\d" #'vertico-directory-delete-char)
  (define-key vertico-map "\M-\d" #'vertico-directory-delete-word)
  (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)

  (with-eval-after-load 'evil
    (define-key vertico-map (kbd "M-h") #'vertico-directory-up)))

(use-package vertico-repeat
  :hook (minibuffer-setup . vertico-repeat-save)
  :init
  (keymap-global-set "M-R" #'vertico-repeat))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-completion)
;;; me-completion.el ends here
#+end_src

** me-core-ui.el
=me-core-ui.el= 界面相关配置

文件头

#+begin_src emacs-lisp
;;; me-core-ui.el --- MinEmacs -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

调整行号大小 75% 更美观一些

#+begin_src emacs-lisp
(defun +theme--tweaks-h (&optional _)
  "Use smaller font (75% of the default) for line numbers in graphic mode."
  (when (display-graphic-p)
    (set-face-attribute
     'line-number nil
     :background (face-attribute 'default :background)
     :height (truncate (* 0.75 (face-attribute 'default :height)))
     :weight 'semi-light)
    (set-face-attribute
     'line-number-current-line nil
     :height (truncate (* 0.75 (face-attribute 'default :height)))
     :weight 'bold)))

;; Apply tweaks
(add-hook 'after-init-hook #'+theme--tweaks-h)
(add-hook 'enable-theme-functions #'+theme--tweaks-h)

;; Save enabled theme
(add-hook
 'enable-theme-functions
 (defun +theme--save-enabled-theme-h (theme)
   "Save the enabled theme to `minemacs-theme'.
Useful for keeping track of the enabled theme."
   (setq minemacs-theme theme)))
#+end_src

主题相关

#+begin_src emacs-lisp
;; Disable previously enabled custom themes before enabling a new one.
(advice-add
 'load-theme :before
 (defun +theme--disable-previous-themes-a (&rest _)
   "Disable previously enabled themes before enabling the new one."
   (mapc #'disable-theme custom-enabled-themes)))

(use-package modus-themes
  :straight (:host github :repo "protesilaos/modus-themes")
  :config
  ;; In all of the following, WEIGHT is a symbol such as `semibold',
  ;; `light', `bold', or anything mentioned in `modus-themes-weights'.
  (setq modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-mixed-fonts nil
        modus-themes-variable-pitch-ui nil
        modus-themes-custom-auto-reload t

        ;; Options for `modus-themes-prompts' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `italic', `WEIGHT'
        modus-themes-prompts '(semi-bold)

        ;; The `modus-themes-completions' is an alist that reads two
        ;; keys: `matches', `selection'.  Each accepts a nil value (or
        ;; empty list) or a list of properties that can include any of
        ;; the following (for WEIGHT read further below):
        ;; `matches'   :: `underline', `italic', `WEIGHT'
        ;; `selection' :: `underline', `italic', `WEIGHT'
        modus-themes-completions
        '((matches   . (extrabold))
          (selection . (semibold text-also)))

        modus-themes-org-blocks 'gray-background ; {nil,'gray-background,'tinted-background}

        ;; The `modus-themes-headings' is an alist: read the manual's
        ;; node about it or its doc string.  Basically, it supports
        ;; per-level configurations for the optional use of
        ;; `variable-pitch' typography, a height value as a multiple of
        ;; the base font size (e.g. 1.5), and a `WEIGHT'.
        modus-themes-headings
        '((1                . (1.4))
          (2                . (1.3))
          (3                . (1.2))
          (agenda-date      . (1.2))
          (agenda-structure . (light 1.5))
          (t                . (1.1)))

        modus-themes-common-palette-overrides
        `(;; Customize the mode-line colors
          (bg-mode-line-active bg-blue-intense)
          (fg-mode-line-active fg-main)

          ;; From the section "Make the mode line borderless"
          (border-mode-line-active unspecified)
          (border-mode-line-inactive unspecified)

          ;; From the section "Make matching parenthesis more or less intense"
          (bg-paren-match bg-blue-intense)
          (underline-paren-match unspecified)

          ;; Links
          (underline-link border)
          (underline-link-visited border)
          (underline-link-symbolic border)

          ;; Comments are yellow, strings are green
          (comment yellow-cooler)
          (string green-warmer)

          ;; And expand the preset here. Note that the ,@ works because we use
          ;; the backtick for this list, instead of a straight quote.
          ,@modus-themes-preset-overrides-faint))

  ;; Load the theme of your choice.
  (load-theme 'modus-operandi-tinted t))

(use-package doom-themes
  :straight t)

(use-package apropospriate-theme
  :straight t)
#+end_src

图标icon相关

#+begin_src emacs-lisp
(use-package nerd-icons
  :straight t
  :config
  ;; Show .m files as matlab/octave files (integral icon)
  (setcdr (assoc "m" nerd-icons-extension-icon-alist)
          '(nerd-icons-mdicon "nf-md-math_integral_box" :face nerd-icons-orange)))
#+end_src

pacakge [[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] 仪表盘

#+begin_src emacs-lisp
;;HACK: want hack
(use-package dashboard
  :straight t
  :after evil evil-collection
  :demand t
  :when (not (bound-and-true-p +dashboard-disable))
  :init
  (+map! "oD" #'dashboard-open)
  :custom
  (dashboard-set-heading-icons t)
  (dashboard-set-file-icons t)
  (dashboard-center-content t)
  (dashboard-banner-ascii "MinEmacs")
  (dashboard-banner-logo-title "Welcome to MinEmacs!")
  (dashboard-items '((recents . 5) (projects . 5) (bookmarks . 5)))
  (dashboard-image-banner-max-width 600)
  (dashboard-projects-backend 'project-el)
  (dashboard-startup-banner (concat minemacs-assets-dir "images/anonymous.png"))
  :config
  ;; Ensure setting the keybindings before openning the dashboard
  (evil-collection-dashboard-setup)

  ;; Avoid openning the dashboard when Emacs starts with an open file.
  (when (zerop (length (seq-filter #'identity (mapcar #'buffer-file-name (buffer-list)))))
    (dashboard-open)))
#+end_src

package doom-modeline

#+begin_src emacs-lisp
(use-package doom-modeline
  :straight t
  :hook (minemacs-after-startup . doom-modeline-mode)
  :custom
  (doom-modeline-height 35)
  (doom-modeline-bar-width 8)
  (doom-modeline-time-icon nil)
  (doom-modeline-buffer-encoding 'nondefault)
  (doom-modeline-unicode-fallback t)
  :config
  ;; HACK: Add some padding to the right
  (doom-modeline-def-modeline 'main
    '(bar workspace-name window-number modals matches follow buffer-info
      remote-host buffer-position word-count parrot selection-info)
    '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus
      github debug repl lsp minor-modes input-method indent-info buffer-encoding
      major-mode process vcs checker time "  ")))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-core-ui)
;;; me-core-ui.el ends here
#+end_src

** me-defaults.el
=me-defaults.el= 一些默认设置

文件头

#+begin_src emacs-lisp
;;; me-defaults.el --- MinEmacs defaults for Emacs -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

GNU 广告关闭

#+begin_src emacs-lisp
;; Inhibit startup message in echo area the brutal way!
;; The `inhibit-startup-echo-area-message' variable is very restrictive, there
;; is only one unique way of setting it right!
;; See: reddit.com/r/emacs/comments/6e9o4o/comment/di8q1t5
(fset 'display-startup-echo-area-message #'ignore)
#+end_src

EMACS 中的 UTF-8：无处不在，永远不变

#+begin_src emacs-lisp
;;; Why use anything but UTF-8?
(prefer-coding-system 'utf-8)
(set-charset-priority 'unicode)
(set-default-coding-systems 'utf-8)
(set-locale-environment "en_US.UTF-8")
;; Use UTF-16-LE in Windows, see: rufflewind.com/2014-07-20/pasting-unicode-in-emacs-on-windows
(set-selection-coding-system (if os/win 'utf-16-le 'utf-8))
;; 配置所有的编码为UTF-8，参考：
;; https://thraxys.wordpress.com/2016/01/13/utf-8-in-emacs-everywhere-forever/
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment 'utf-8)
(set-clipboard-coding-system 'utf-8)
(set-file-name-coding-system 'utf-8)
(set-buffer-file-coding-system 'utf-8)
(modify-coding-system-alist 'process "*" 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

设置一些默认路径和参数

#+begin_src emacs-lisp
(setq
 ;; ====== Default directories for builtin packages ======
 abbrev-file-name (concat minemacs-local-dir "abbrev.el")
 auto-insert-directory (+directory-ensure minemacs-local-dir "auto-insert/")
 auto-save-list-file-prefix (+directory-ensure minemacs-local-dir "auto-save/")
 backup-directory-alist (list (cons "." (+directory-ensure minemacs-local-dir "backup/")))
 bookmark-default-file (concat minemacs-local-dir "bookmark.el")
 calc-settings-file (concat minemacs-local-dir "calc-settings.el")
 custom-theme-directory (concat minemacs-config-dir "themes/")
 desktop-dirname (+directory-ensure minemacs-local-dir "desktop/")
 desktop-path (list desktop-dirname)
 diary-file (concat minemacs-local-dir "diary")
 ecomplete-database-file (concat minemacs-local-dir "ecomplete-database.el")
 ede-project-placeholder-cache-file (concat minemacs-local-dir "ede-projects.el")
 erc-dcc-get-default-directory (+directory-ensure minemacs-local-dir "erc/dcc/")
 erc-log-channels-directory (+directory-ensure minemacs-local-dir "erc/log-channels/")
 eshell-aliases-file (concat minemacs-local-dir "eshell/aliases")
 eshell-directory-name (+directory-ensure minemacs-local-dir "eshell/")
 eshell-history-file-name (concat minemacs-local-dir "eshell/history.el")
 eshell-last-dir-ring-file-name (concat minemacs-local-dir "eshell/last-dir-ring.el")
 eshell-login-script (concat minemacs-local-dir "eshell/login")
 eshell-rc-script (concat minemacs-local-dir "eshell/rc")
 eudc-options-file (concat minemacs-local-dir "eudc-options.el")
 eww-bookmarks-directory (+directory-ensure minemacs-local-dir "eww/bookmarks/")
 gnus-dribble-directory (+directory-ensure minemacs-local-dir "gnus/dribble/")
 gnus-init-file (concat minemacs-config-dir "gnus/init.el")
 gnus-startup-file (concat minemacs-config-dir "gnus/newsrc")
 ido-save-directory-list-file (concat minemacs-local-dir "ido-save-directory-list.el")
 image-dired-dir (+directory-ensure minemacs-local-dir "image-dired/")
 image-dired-tags-db-file (concat minemacs-local-dir "image-dired/tags-db.el")
 image-dired-temp-rotate-image-file (concat minemacs-cache-dir "image-dired/temp-rotate-image")
 kkc-init-file-name (concat minemacs-local-dir "kkc-init.el")
 multisession-dir (concat minemacs-local-dir "multisession/")
 newsticker-cache-filename (concat minemacs-local-dir "newsticker/cache.el")
 newsticker-dir (+directory-ensure minemacs-local-dir "newsticker/data/")
 nsm-settings-file (concat minemacs-local-dir "nsm-settings.el")
 org-clock-persist-file (concat minemacs-cache-dir "org/clock-persist.el")
 ;; org-id-locations-file (concat minemacs-cache-dir "org/id-locations.el")
 org-id-locations-file (concat minemacs-local-dir "id-locations.el")
 org-persist-directory (+directory-ensure minemacs-cache-dir "org/persist/")
 org-preview-latex-image-directory (+directory-ensure minemacs-cache-dir "org/preview/latex-image/")
 org-publish-timestamp-directory (+directory-ensure minemacs-cache-dir "org/publish/timestamps/")
 project-list-file (concat minemacs-local-dir "project-list.el")
 quickurl-url-file (concat minemacs-local-dir "quickurl-url.el")
 rcirc-log-directory (+directory-ensure minemacs-local-dir "rcirc/log/")
 recentf-save-file (concat minemacs-local-dir "recentf-save.el")
 remember-data-directory (+directory-ensure minemacs-local-dir "remember/data/")
 remember-data-file (concat minemacs-local-dir "remember/data.el")
 save-place-file (concat minemacs-local-dir "save-place.el")
 savehist-file (concat minemacs-local-dir "savehist.el")
 semanticdb-default-system-save-directory (concat minemacs-local-dir "semantic/")
 shadow-info-file (concat minemacs-local-dir "shadow/info.el")
 shadow-todo-file (concat minemacs-local-dir "shadow/todo.el")
 shared-game-score-directory (+directory-ensure minemacs-local-dir "shared-game-score/")
 srecode-map-save-file (concat minemacs-local-dir "srecode-map.el")
 timeclock-file (concat minemacs-local-dir "timeclock")
 tramp-auto-save-directory (concat minemacs-local-dir "tramp/auto-save/")
 tramp-backup-directory-alist backup-directory-alist
 tramp-persistency-file-name (concat minemacs-local-dir "tramp/persistency.el")
 type-break-file-name (concat minemacs-local-dir "type-break.el")
 url-cache-directory (+directory-ensure minemacs-cache-dir "url/")
 url-configuration-directory (+directory-ensure minemacs-local-dir "url/")
 url-cookie-file (concat minemacs-local-dir "url/cookie.el")
 url-history-file (concat minemacs-local-dir "url/history.el")

 ;; ====== Additional directories for non-builtin but common packages ======
 pcache-directory (concat minemacs-cache-dir "pcache/")

 ;; ====== Default behavior ======
 ;; Inhibit startup message
 inhibit-startup-message t
 ;; Do not ring
 ring-bell-function #'ignore
 ;; Set to non-nil to flash!
 visible-bell nil
 ;; Increase the large file threshold to 50 MiB
 large-file-warning-threshold (* 50 1024 1024)
 ;; Initial scratch message (will be overridden if "fortune" is installed)
 initial-scratch-message ";; MinEmacs -- start here!"
 ;; Set initial buffer to fundamental-mode for faster load
 initial-major-mode 'fundamental-mode
 ;; Always prompt in minibuffer (no GUI)
 use-dialog-box nil
 ;; Use y or n instead of yes or no
 use-short-answers t
 ;; Confirm before quitting
 confirm-kill-emacs #'y-or-n-p
 ;; Filter duplicate entries in kill ring
 kill-do-not-save-duplicates t
 ;; Save existing clipboard text into the kill ring before replacing it.
 save-interprogram-paste-before-kill t
 ;; Save files only in sub-directories of current project
 save-some-buffers-default-predicate #'save-some-buffers-root
 ;; Use single space between sentences
 sentence-end-double-space nil
 ;; Move stuff to trash
 delete-by-moving-to-trash t
 ;; Select help window for faster quit!
 help-window-select t
 ;; More info on completions
 completions-detailed t
 ;; Do not ask obvious questions, follow symlinks
 vc-follow-symlinks t
 ;; Display the true file name for symlinks
 find-file-visit-truename t
 ;; Use completion in the minibuffer instead of definitions buffer
 xref-show-definitions-function #'xref-show-definitions-completing-read
 ;; Enable recursive calls to minibuffer
 enable-recursive-minibuffers t
 ;; Kill the shell buffer after exit
 shell-kill-buffer-on-exit t

 ;; ====== Performances ======
 ;; Don’t compact font caches during GC
 inhibit-compacting-font-caches t
 ;; Increase single chunk bytes to read from subprocess (default 4096)
 read-process-output-max (if os/linux
                             (condition-case nil
                                 ;; Android may raise permission-denied error
                                 (with-temp-buffer
                                   (insert-file-contents "/proc/sys/fs/pipe-max-size")
                                   (string-to-number (buffer-string)))
                               ;; If an error occured, fallback to the default value
                               (error read-process-output-max))
                           (* 1024 1024))

 ;; ====== Aesthetics and UI ======
 ;; Do force frame size to be a multiple of char size
 frame-resize-pixelwise t
 ;; Stretch cursor to the glyph width
 x-stretch-cursor t
 ;; Resize window combinations proportionally
 window-combination-resize t
 ;; Enable time in the mode-line
 display-time-string-forms '((propertize (concat 24-hours ":" minutes)))
 ;; Relative line numbering
 display-line-numbers-type 'relative
 ;; No ugly button for widgets
 widget-image-enable nil
 ;; Show unprettified symbol under cursor (when in `prettify-symbols-mode')
 prettify-symbols-unprettify-at-point t
 ;; Make tooltips last a bit longer (default 10s)
 tooltip-hide-delay 20
 ;; Use small frames to display tooltips instead of the default OS tooltips
 use-system-tooltips nil
 ;; Animated images loop forever instead of playing the animation only once
 image-animate-loop t
 ;; Set line width for the divider in `window-divider-mode' to 2px
 window-divider-default-bottom-width 2
 window-divider-default-right-width 2

 ;; ====== Undo ======
 ;; 10MB (default is 160kB)
 undo-limit 10000000
 ;; 50MB (default is 240kB)
 undo-strong-limit 50000000
 ;; 150MB (default is 24MB)
 undo-outer-limit 150000000

 ;; ====== Editing ======
 ;; Hitting TAB behavior
 tab-always-indent nil
 ;; Default behavior for `whitespace-cleanup'
 whitespace-action '(cleanup auto-cleanup)
 ;; End files with newline
 require-final-newline t
 ;; Enable Drag-and-Drop of regions
 mouse-drag-and-drop-region t
 ;; Enable Drag-and-Drop of regions from Emacs to external programs
 mouse-drag-and-drop-region-cross-program t

 ;; ====== Backups ======
 ;; Disable lockfiles
 create-lockfiles nil
 ;; Enable making backup files
 make-backup-files t
 ;; Number each backup file
 version-control t
 ;; Copy instead of renaming current file
 backup-by-copying t
 ;; Clean up after itself
 delete-old-versions t
 ;; Keep up to 5 old versions of each file
 kept-old-versions 5
 ;; Keep up to 5 new versions of each file
 kept-new-versions 5
 ;; Keep up to 5 versions when cleaning a directory
 dired-kept-versions 5

 ;; ====== Scrolling ======
 ;; Do not adjust window-vscroll to view tall lines. Fixes some lag issues see:
 ;; emacs.stackexchange.com/a/28746
 auto-window-vscroll nil
 ;; Fast scrolling
 fast-but-imprecise-scrolling t
 ;; Keep the point in the same position while scrolling
 scroll-preserve-screen-position t
 ;; Do not move cursor to the center when scrolling
 scroll-conservatively 101
 ;; Scroll at a margin of one line
 scroll-margin 1
 ;; Better scrolling on Emacs29+, specially on a touchpad
 pixel-scroll-precision-use-momentum t

 ;; ====== Recent files ======
 ;; Increase the maximum number of saved items
 recentf-max-saved-items 100
 ;; Ignore case when searching recentf files
 recentf-case-fold-search t
 ;; Exclude some files from being remembered by recentf
 recentf-exclude
 `(,(rx (* any)
     (or
      "elfeed-db"
      "eln-cache"
      "/cache/"
      ".maildir/"
      ".cache/")
     (* any)
     (? (or "html" "pdf" "tex" "epub")))
   ,(rx "/"
     (or "rsync" "ssh" "tmp" "yadm" "sudoedit" "sudo")
     (* any)))

 ;; ====== Timestamps ======
 ;; Do enable time-stamps
 time-stamp-active t
 ;; Check the first 12 buffer lines for Time-stamp: <>
 time-stamp-line-limit 12
 ;; Timestamp format
 time-stamp-format "%04Y-%02m-%02d %02H:%02M:%02S"

 ;; ====== Auto-Saving, sessions ======
 ;; Enable auto-save (use `recover-file' or `recover-session' to recover)
 auto-save-default t
 ;; Include big deletions
 auto-save-include-big-deletions t
 ;; Set file naming transform
 auto-save-file-name-transforms
 `(;; Prefix tramp autosaves with "tramp-"
   ("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,(concat auto-save-list-file-prefix "tramp-\\2") t)
   ;; Local autosaves
   (".*" ,auto-save-list-file-prefix t))
 ;; File name to use when saving desktop
 desktop-base-file-name "emacs-session.el"
 ;; File name to use as a lock
 desktop-base-lock-name (concat desktop-base-file-name ".lock")
 ;; Load only 5 buffers immediately, the remaining buffers will be loaded lazily
 desktop-restore-eager 5
 ;; Avoid writing contents unchanged between auto-saves
 desktop-file-checksum t

 ;; ====== Misc ======
 ;; Set `webjump' sites to manily search engins
 webjump-sites
 '(("Emacs Wiki"    . [simple-query "www.emacswiki.org" "www.emacswiki.org/cgi-bin/wiki/" ""])
   ("DuckDuckGo"    . [simple-query "duckduckgo.com" "duckduckgo.com/?q=" ""])
   ("Qwant"         . [simple-query "www.qwant.com" "www.qwant.com/?q=" ""])
   ("Ecosia"        . [simple-query "www.ecosia.org" "www.ecosia.org/search?q=" ""])
   ("Brave"         . [simple-query "search.brave.com" "search.brave.com/search?q=" ""])
   ("Bing"          . [simple-query "www.bing.com" "www.bing.com/search?q=" ""])
   ("Yahoo"         . [simple-query "www.yahoo.com" "search.yahoo.com/search?p=" ""])
   ("Google"        . [simple-query "www.google.com" "www.google.com/search?q=" ""])
   ("Google Maps"   . [simple-query "www.google.com" "www.google.com/maps?q=" ""])
   ("Google Images" . [simple-query "www.google.com" "www.google.com/images?q=" ""])
   ("Google Groups" . [simple-query "groups.google.com" "groups.google.com/groups?q=" ""])
   ("StackOverflow" . [simple-query "stackoverflow.com" "stackoverflow.com/search?q=" ""])
   ("GitHub Repo"   . [simple-query "github.com" "github.com/search?type=repositories&q=" ""])
   ("GitHub Code"   . [simple-query "github.com" "github.com/search?type=code&q=" ""])
   ("WolframAlpha"  . [simple-query "wolframalpha.com" "wolframalpha.com/input/?i=" ""])
   ("MDN"           . [simple-query "developer.mozilla.org" "developer.mozilla.org/search?q=" ""])
   ("Youtube"       . [simple-query "www.youtube.com" "www.youtube.com/results?search_query=" ""])
   ("Reddit"        . [simple-query "www.reddit.com" "www.reddit.com/search/?q=" ""])
   ("Wikipedia"     . [simple-query "wikipedia.org" "wikipedia.org/wiki/" ""])))

(setq-default
 ;; ====== Buffer-local variables ======
 ;; Display long lines
 truncate-lines nil
 ;; Default fill column width
 fill-column 80
 ;; Never mix, use only spaces
 indent-tabs-mode nil
 ;; Width for line numbers
 display-line-numbers-width 4
 ;; Display absolute line numbers in narrowed regions
 display-line-numbers-widen t
 ;; Small tab is enough!
 tab-width 2
 ;; Save buffer status
 desktop-save-buffer t)

;; ====== Misc hooks and advices ======
;; Advice `emacs-session-filename' to ensure creating "session.ID" files in
;; a sub-directory
(with-eval-after-load 'x-win
  (advice-add
   #'emacs-session-filename :filter-return
   (defun +emacs-session-filename--in-subdir-a (session-filename)
     "Put the SESSION-FILENAME in the \"x-win/\" sub-directory."
     (concat (+directory-ensure minemacs-local-dir "x-win/")
             (file-name-nondirectory session-filename)))))

;; Kill `term' buffer on exit (reproduce a similar behavior to `shell's
;; `shell-kill-buffer-on-exit').
(advice-add
 'term-sentinel :around
 (defun +term--kill-after-exit-a (orig-fn proc msg)
   (if (memq (process-status proc) '(signal exit))
       (let ((buffer (process-buffer proc)))
         (apply orig-fn (list proc msg))
         (kill-buffer buffer))
     (apply orig-fn (list proc msg)))))

;; Kill the minibuffer when switching by mouse to another window.
;; Adapted from: trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
(add-hook
 'mouse-leave-buffer-hook
 (defun +minibuffer--kill-on-mouse-h ()
   "Kill the minibuffer when switching to window with mouse."
   (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
     (abort-recursive-edit))))

;; ====== Tweaks on file save ======
;; Update time stamp (if available) before saving a file.
(add-hook 'before-save-hook 'time-stamp)

(defcustom +whitespace-auto-cleanup-modes
  '(prog-mode conf-mode org-mode markdown-mode
    latex-mode tex-mode bibtex-mode)
  "Enable auto white space cleanup before saving for these derived modes."
  :group 'minemacs-edit
  :type '(repeat symbol))

;; Auto-remove trailing white spaces before saving for modes defined in
;; `+whitespace-auto-cleanup-modes'.
(add-hook
 'before-save-hook
 (defun +save--whitespace-cleanup-h ()
   (when (cl-some #'derived-mode-p +whitespace-auto-cleanup-modes)
     (whitespace-cleanup))))

;; Guess the major mode after saving a file in `fundamental-mode' (adapted
;; from Doom Emacs).
(add-hook
 'after-save-hook
 (defun +save--guess-file-mode-h ()
   "Guess major mode when saving a file in `fundamental-mode'.
Likely, something has changed since the buffer was opened. e.g. A shebang line
or file path may exist now."
   (when (eq major-mode 'fundamental-mode)
     (let ((buffer (or (buffer-base-buffer) (current-buffer))))
       (and (buffer-file-name buffer)
            (eq buffer (window-buffer (selected-window))) ;; Only visible buffers
            (set-auto-mode))))))

;; ====== Modes enabled locally, mainly for `prog-mode', `conf-mode' and `text-mode' ======
;; Show line numbers
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'conf-mode-hook #'display-line-numbers-mode)
(add-hook 'text-mode-hook #'display-line-numbers-mode)

;; Highlight the current line
(add-hook 'prog-mode-hook #'hl-line-mode)
(add-hook 'conf-mode-hook #'hl-line-mode)
(add-hook 'text-mode-hook #'hl-line-mode)

;; Hide/show code blocks, a.k.a. code folding
(add-hook 'prog-mode-hook #'hs-minor-mode)
(add-hook 'conf-mode-hook #'hs-minor-mode)

;; Wrap long lines
(add-hook 'prog-mode-hook #'visual-line-mode)
(add-hook 'conf-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'visual-line-mode)

;; Show trailing whitespace in `prog-mode' and `conf-mode'
(defun +show-trailing-whitespace-h () (setq show-trailing-whitespace t))
(add-hook 'prog-mode-hook #'+show-trailing-whitespace-h)
(add-hook 'conf-mode-hook #'+show-trailing-whitespace-h)

;; When MinEmacs is running in an asynchronous Org export context, there is no
;; need to enable these modes. So we load them only if we haven't been launched
;; through the `me-org-export-async-init' file.
;; All modes and tweaks are enabled after MinEmacs is gets loaded
(+deferred-unless! (featurep 'me-org-export-async-init)
  ;; Navigate windows using Shift+Direction
  (windmove-default-keybindings 'shift)

  ;; ====== Modes enabled globally ======
  ;; Show the battery status (if available) in the mode-line
  (+shutup!
   (let ((battery-str (battery)))
     (unless (or (equal "Battery status not available" battery-str)
                 (string-match-p "unknown" battery-str)
                 (string-match-p "N/A" battery-str))
       (display-battery-mode 1))))

  ;; Fallback the new `fido-vertical-mode' Emacs28+ builtin completion mode if
  ;; the `me-completion' (which contains `vertico-mode' configuration) core
  ;; module is not enabled.
  (unless (memq 'me-completion minemacs-core-modules)
    (fido-vertical-mode 1))

  ;; Window layout undo/redo (`winner-undo' / `winner-redo')
  (winner-mode 1)

  ;; Display divider between windows
  (window-divider-mode 1)

  ;; Scroll pixel by pixel, in Emacs29+ there is a more pricise mode way to scroll
  (if (>= emacs-major-version 29)
      (pixel-scroll-precision-mode 1)
    (pixel-scroll-mode 1))

  ;; Display time in mode-line
  (display-time-mode 1)

  ;; Replace selection after start typing
  (delete-selection-mode 1)

  ;; Enable `recentf-mode' to remember recent files
  (+shutup! (recentf-mode 1))

  ;; Show recursion depth in minibuffer (see `enable-recursive-minibuffers')
  (minibuffer-depth-indicate-mode 1)

  ;; Save place in files
  (save-place-mode 1)

  ;; Enable saving minibuffer history
  (savehist-mode 1)

  ;; Auto load files changed on disk
  (global-auto-revert-mode 1)

  ;; Show line number in mode-line
  (line-number-mode 1)

  ;; Show column numbers (a.k.a. cursor position) in the mode-line
  (column-number-mode 1)

  ;; Better handling for files with so long lines
  (global-so-long-mode 1)

  ;; Save Emacs state from one session to another
  (desktop-save-mode 1)

  ;; Global SubWord mode
  (global-subword-mode 1))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-defaults)
;;; me-defaults.el ends here
#+end_src

** me-evil.el
=me-evil.el= Emacs as Vim

文件头

#+begin_src emacs-lisp
;;; me-evil.el --- Emacs as Vim! -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

pacakge =evil= 模拟vim

#+begin_src emacs-lisp
(use-package evil
  :straight t
  :hook (minemacs-after-startup . evil-mode)
  :preface
  (setq evil-want-keybinding nil)
  :custom
  (evil-want-C-i-jump nil)
  (evil-want-fine-undo t)
  (evil-want-Y-yank-to-eol t)
  (evil-split-window-below t)
  (evil-vsplit-window-right t)
  (evil-kill-on-visual-paste nil)
  (evil-respect-visual-line-mode t)
  (evil-ex-interactive-search-highlight 'selected-window)
  :config
  (+map!
    ;; buffer
    "bN" '(evil-buffer-new :wk "New buffer")
    ;; window
    "ww" '(evil-window-next :wk "Next")
    "wW" '(evil-window-prev :wk "Previous")
    "ws" '(evil-window-split :wk "Split")
    "wv" '(evil-window-vsplit :wk "Vertical split")
    "wr" '(evil-window-rotate-downwards :wk "Rotate downwards")
    "wR" '(evil-window-rotate-upwards :wk "Rotate upwards")
    "w+" '(evil-window-increase-width :wk "Increase width")
    "w-" '(evil-window-decrease-width :wk "Decrease width"))

  ;; Use `evil-search' instead of `isearch'
  (evil-select-search-module 'evil-search-module 'evil-search)

  ;; Ask for a buffer when splitting windows
  (with-eval-after-load 'consult
    (dolist (fn '(evil-window-split evil-window-vsplit))
      (advice-add
       fn :after
       (defun +evil--cunsult-buffer-after-window-split-a (&rest _)
         (consult-buffer))))))
#+end_src

=evil-collection= 其他包的evil按键集合

#+begin_src emacs-lisp
(use-package evil-collection
  :straight t
  :after evil minemacs-loaded
  :demand t
  :config
  (evil-collection-init
   (seq-filter
    (lambda (mode)
      (not (memq mode '(evil-mc ; Default bindings for `evil-mc' are messy
                        elisp-mode)))) ; I don't like "gz" for `ielm', I like "gr" though
    evil-collection-mode-list))

  ;; Use "gr" to find references for elisp mode
  (with-eval-after-load 'elisp-mode
    (when evil-collection-want-find-usages-bindings
      (evil-collection-define-key 'normal 'emacs-lisp-mode-map
        "gr" 'xref-find-references))))
#+end_src

=evil-snipe= 快速移动光标

#+begin_src emacs-lisp
(use-package evil-snipe
  :straight t
  :hook (minemacs-after-startup . evil-snipe-mode)
  :hook (minemacs-after-startup . evil-snipe-override-mode)
  :custom
  (evil-snipe-scope 'buffer)
  (evil-snipe-smart-case t)
  (evil-snipe-auto-scroll t))
#+end_src

=evil-numbers= 数字增加或者减少

#+begin_src emacs-lisp
(use-package evil-numbers
  :straight t
  :init
  (+nmap!
    "g+" #'evil-numbers/inc-at-pt
    "g=" #'evil-numbers/inc-at-pt
    "g-" #'evil-numbers/dec-at-pt)
  (+vmap!
    "g+" #'evil-numbers/inc-at-pt-incremental
    "g=" #'evil-numbers/inc-at-pt-incremental
    "g-" #'evil-numbers/dec-at-pt-incremental))
#+end_src

=evil-nerd-commenter= 快速注释 TODO:

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :straight t
  :commands evilnc-comment-operator
  :init
  (+nvmap! "gc" #'evilnc-comment-operator))
#+end_src

=evil-escape= 快速回到normal-state

#+begin_src emacs-lisp
(use-package evil-escape
  :straight t
  :hook (evil-mode . evil-escape-mode)
  :custom
  ;; The default "fd" interfere with the "f" (bound to `evil-snipe-f') binding.
  (evil-escape-key-sequence "kj")
  (evil-escape-unordered-key-sequence t)) ; "kj" or "jk"
#+end_src

=evil-surround=

#+begin_src emacs-lisp
(use-package evil-surround
  :straight t
  :demand t
  :config
  (global-evil-surround-mode 1))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-evil)
;;; me-evil.el ends here
#+end_src

** me-gc.el
=me-gc.el=  garbage collection 垃圾回收

文件头

#+begin_src emacs-lisp
;;; me-gc.el --- garbage collection -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

gcmh 垃圾回收

#+begin_src emacs-lisp
(use-package gcmh
  :straight t
  :hook (minemacs-lazy . gcmh-mode)
  :custom
  ;; Set the delay to 20s instead of the default 15. I tried using `auto', but
  ;; with the default 20 of `gcmh-auto-idle-delay-factor', it triggers GC each
  ;; 1s on my machine. Setting the factor to a higher value should solve the
  ;; issue on my machine, but I don't think it is right to assume it will work
  ;; the same way on other machines. So we switch back to a fixed delay of 20s.
  (gcmh-idle-delay 20)
  ;; The default `gcmh's 1GB is probably too high. We set it to 256MB on 64bit
  ;; systems, or 16MB on 32bit ones.
  (gcmh-high-cons-threshold
   (* 1024 1024 (if (string-suffix-p "64" (symbol-name sys/arch)) 256 16))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-gc)
;;; me-gc.el ends here
#+end_src

** me-keybindings.el
=me-keybindings.el= 按键相关设置

文件头

#+begin_src emacs-lisp
;;; me-keybindings.el --- Default keybindings -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

[[https://github.com/justbur/emacs-which-key][which-key]]

#+begin_src emacs-lisp
(use-package which-key
  :straight t
  :hook (minemacs-after-startup . which-key-mode)
  :custom
  (which-key-idle-delay 1.0)
  (which-key-idle-secondary-delay nil)
  (which-key-ellipsis "..")
  (which-key-prefix-prefix "+")
  (which-key-sort-order 'which-key-key-order-alpha)
  (which-key-min-display-lines 3)
  (which-key-max-display-columns nil)
  ;; Allow a key binding to be modified by multiple rules in
  ;; `which-key-replacement-alist'
  (which-key-allow-multiple-replacements t)
  :config
  (setq
   which-key-replacement-alist
   (append
    which-key-replacement-alist
    (list
     '(("\\`g z" . "\\`evil-\\(?:mc\\|multiedit\\)-\\(.*\\)")    . (nil . "⌶·\\1"))
     ;; '(("\\`g c" . "\\`evilnc-\\(.*\\)")                         . (nil . "#·\\1"))
     '(("\\`g" . "\\`[Ii]nfo[-:]?\\(?:a-\\)?\\(.*\\)")           . (nil . "ɩ·\\1"))
     '(("\\`SPC TAB" . "\\`tabspaces-\\(.*\\)")                  . (nil . "⭾·\\1"))
     '(("\\`SPC p" . "\\`\\+?\\(?:consult-\\)?project-\\(.*\\)") . (nil . "🅟·\\1"))
     '(("" . "\\`evil[-:]?\\(?:a-\\)?\\(.*\\)")                  . (nil . "ɛ·\\1")))))
  ;; Setup `which-key' integration with the minibuffer
  (which-key-setup-minibuffer))
#+end_src

general

#+begin_src emacs-lisp
(use-package general
  :straight t
  ;; PERF: Loading `general' early make Emacs very slow on startup.
  :after evil
  :demand t
  :config
  ;; Advise `define-key' to automatically unbind keys when necessary.
  (general-auto-unbind-keys)
  ;; Set up some basic equivalents (like `general-nmap') with short named
  ;; aliases (like `nmap') for VIM mapping functions.
  (general-evil-setup t)

  ;; Global leader
  (general-create-definer +minemacs--internal-map!
    ;; The order of states matters, the last is prioritized
    :states '(insert emacs visual normal)
    :keymaps 'override
    :prefix minemacs-leader-key
    :global-prefix minemacs-global-leader-prefix)

  ;; Local leader
  (general-create-definer +minemacs--internal-map-local!
    :states '(insert emacs visual normal)
    :keymaps 'override
    :prefix minemacs-localleader-key
    :global-prefix minemacs-global-mode-prefix)

  ;; Define the built-in global keybindings
  (+minemacs--internal-map!
    ;; ====== Top level functions ======
    "SPC" '(execute-extended-command :wk "M-x")
    ">"   '(switch-to-next-buffer :wk "Next buffer")
    "<"   '(switch-to-prev-buffer :wk "Previous buffer")
    ";"   '(pp-eval-expression :wk "Eval expression")
    "X"   #'org-capture
    "u"   '(universal-argument :wk "C-u")
    "C"   #'universal-coding-system-argument

    ;; ====== Quit/Session ======
    "q"   '(nil :wk "quit/session")
    "qq"  #'save-buffers-kill-terminal
    "qQ"  #'kill-emacs
    "qS"  #'server-start
    "qR"  #'recover-session
    "qd"  #'desktop-read
    "qD"  #'desktop-lazy-complete
    "qs"  #'desktop-save

    ;; ====== Files ======
    "f"   '(nil :wk "file")
    "fS"  '(write-file :wk "Save as ...")
    "fD"  #'+delete-this-file
    "fu"  #'+sudo-find-file
    "fU"  #'+sudo-this-file
    "fR"  #'+move-this-file
    "ff"  #'find-file
    "fs"  #'save-buffer
    "ft"  #'recover-this-file
    "fT"  #'recover-file
    "fy"  #'+yank-this-file-name
    "fE"  `(,(+cmdfy! (dired (or minemacs-config-dir minemacs-root-dir)))
            :wk "User config directory")

    ;; ====== Buffers ======
    "b"   '(nil :wk "buffer")
    "bI"  #'ibuffer
    "bu"  #'+sudo-save-buffer
    "bS"  #'save-some-buffers
    "bs"  #'scratch-buffer
    "bM"  #'view-echo-area-messages
    "bA"  #'+kill-some-buffers
    "bk"  `(,(+cmdfy! (kill-buffer (current-buffer)))
            :wk "Kill this buffer")
    "bK"  `(,(+cmdfy! (+kill-buffer-and-its-windows (current-buffer)))
            :wk "Kill this buffer and its windows")
    "br"  '(revert-buffer :wk "Revert")
    "bR"  '(rename-buffer :wk "Rename")
    ;; Bookmarks
    "bm"  '(nil :wk "bookmark")
    "bmm"  #'bookmark-set
    "bmd"  #'bookmark-delete
    ;; Files / Local variables
    "bv"  '(nil :wk "locals")
    "bvv" '(add-file-local-variable :wk "Add")
    "bvV" '(delete-file-local-variable :wk "Delete")
    "bvp" '(add-file-local-variable-prop-line :wk "Add in prop line")
    "bvP" '(delete-file-local-variable-prop-line :wk "Delete from prop line")
    "bvd" '(add-dir-local-variable :wk "Add to dir-locals")
    "bvD" '(delete-dir-local-variable :wk "Delete from dir-locals")
    "bvr"  '(nil :wk "reload dir-locals for...")
    "bvrr" '(+dir-locals-reload-for-this-buffer :wk "This buffer")
    "bvrd" '(+dir-locals-reload-for-all-buffers-in-this-directory :wk "All buffers in this directory")

    ;; ====== Insert ======
    "i"   '(nil :wk "insert")
    "iu"  '(insert-char :wk "Unicode char")
    "ie"  `(,(when (>= emacs-major-version 29) #'emoji-search) :wk "Emoji")

    ;; ====== Window ======
    "w"   '(nil :wk "window")
    "wd"  #'delete-window
    "wD"  #'delete-window-on
    "wm"  #'maximize-window
    "wu"  #'winner-undo
    "wU"  #'winner-redo

    ;; ====== Applications (Open) ======
    "o"   '(nil   :wk "app/open")
    "o-"  '(dired :wk "Dired") ;; Will be overwritten if dirvish is used
    "oa"  #'org-agenda
    "oe"  #'eshell

    ;; ====== Search ======
    "s"   '(nil :wk "search")
    "sw"  '+webjump

    ;; ======  Mode specific a.k.a. "local leader" ======
    "m"   '(nil :wk "mode-specific")

    ;; ====== VC ======
    "g"   '(nil :wk "git/vc")

    ;; ====== Workspaces ======
    "TAB" '(nil :wk "workspace")

    ;; ====== Toggle ======
    "t"   '(nil :wk "toggle")
    "td"  '(toggle-debug-on-error :wk "Debug on error")
    "tr"  #'read-only-mode
    "tl"  #'follow-mode
    "tV"  '(netextender-toggle :wk "NetExtender")
    "te"  '(ecryptfs-toggle-mount-private :wk "eCryptfs")
    "tv"  #'visible-mode

    ;; ====== Code ======
    "c"   '(nil :wk "code")
    "cf"  '(nil :wk "format buffer")

    ;; ====== Workspaces ======
    "r"   '(nil :wk "workspace") ;; TODO: use tab-bar-mode and tab-line-mode

    ;; ====== Notes ======
    "n"   '(nil :wk "notes")

    ;; ====== Help ======
    "h"   '(nil :wk "help")
    "hi"  #'info
    "hg"  #'general-describe-keybindings
    "hs"  #'+screenshot-svg
    "he"  '(nil :wk "elisp/emacs")
    "hes" #'elisp-index-search
    "hem" #'info-emacs-manual
    "hei" #'Info-search
    "hd"  '(nil :wk "describe")
    "hdk" #'describe-key
    "hdm" #'describe-keymap
    "hdb" #'describe-bindings
    "hds" #'describe-symbol
    "hdv" #'describe-variable
    "hdc" #'describe-command
    "hdf" #'describe-function
    "hdp" #'describe-package

    ;; ====== Project ======
    "p"   '(nil :wk "project"))

  ;; HACK: This is a synchronization feature, providing `me-general-ready' tells
  ;; the `+map!', `+map-local!', ... macros that `general' is ready and the
  ;; definers `+minemacs--internal-map!', `+minemacs--internal-map-local!', ...
  ;; are available (See the `+map!' macro definition in "elisp/+minemacs.el").
  (provide 'me-general-ready))
#+end_src

=hydra=

#+begin_src emacs-lisp
(use-package hydra
  :straight t)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-keybindings)
;;; me-keybindings.el ends here
#+end_src

** me-meow.el

文件头

#+begin_src emacs-lisp
;; me-meow.el --- Meow integration -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

meow 猫态编辑模式 一种不同于evil的按键模式

#+begin_src emacs-lisp
(when (memq 'me-evil minemacs-core-modules)
  (user-error "The `me-meow' module is incompatible with `me-evil'."))

(use-package meow
  :straight t
  :preface
  (defun meow-setup ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("q" . meow-quit)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . meow-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("'" . repeat)
     '("<escape>" . ignore))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-meow)
;;; me-meow.el ends here
#+end_src

** me-loaddefs.el
=me-loaddefs.el= 此文件是由 =minemacs-generate-loaddefs= 收集autoload 函数
** me-modules.el
=me-modules.el= 按照模块划分功能

文件头

#+begin_src emacs-lisp
;;; me-modules.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src


核心模块

#+begin_src emacs-lisp
(defcustom minemacs-core-modules
  '(me-splash        ; Simple splash screen
    me-keybindings   ; Keybinding (general, which-key, hydra, ...)
    me-evil          ; Emacs as Vim (evil, evil-collection, evil-escape, evil-snipe, evil-numbers, ...)
    me-core-ui       ; Core UI (doom-themes, modus-themes, doom-modeline, ...)
    me-completion)   ; Completion (vertico, marginalia, corfu, cape, consult, embark, ...)
  "MinEmacs enabled core modules."
  :group 'minemacs-core
  :type '(repeat symbol))
#+end_src

功能模块

#+begin_src emacs-lisp
(defcustom minemacs-modules
  '(me-ui            ; User interface (focus, writeroom-mode, mixed-pitch, ...)
    me-editor        ; Editing (yasnippet, smartparens, unicode-fonts, ligature, ...)
    me-daemon        ; Emacs daemon tweaks
    me-undo          ; Better undoing (undo-fu, undo-fu-session, vundo, ...)
    me-multi-cursors ; Multi-cursors editing (iedit, evil-mc, evil-iedit-state, ...)
    me-vc            ; Version control (magit, forge, core-review, diff-hl, ...)
    me-project       ; Project management (project, projectile, consult-projectile, treemacs-projectile, ...)
    me-prog          ; Programming stuff (tree-sitter, eglot, eldoc, eldoc-box, apheleia, editorconfig, ...)
    me-checkers      ; Static checkers (flymake, flymake-easy, ...)
    me-debug         ; Debugging tools (gdb-mi, realgud, disaster, ...)
    ;; me-lsp        ; LSP and DAP (lsp-mode, dap-mode, consult-lsp, lsp-pyright, ccls, ...)
    me-lisp          ; Lisps development (parinfer-rust, sly, macrostep, geiser, elisp, helpful, eros, ...)
    me-data          ; Data file formats (csv, yaml, toml, json, plantuml-mode, ...)
    ;; me-math       ; Mathematics (maxima, ess, ein, julia-mode, octave, ...)
    me-org           ; Org-mode for life (org, org-contrib, org-modern, org-appear, ...)
    me-extra         ; Extra features (better-jumper, crux, ...)
    me-notes         ; Notes & Zettelkasten (org-roam, consult-org-roam, ...)
    me-eaf           ; EAF apps (browser, jupyter, file-sender, ...)
    ;; me-email      ; Email (mu4e, mu4e-alert, org-msg, ...)
    ;; me-rss        ; News feed (elfeed, ...)
    ;; me-lifestyle  ; *Very* opinionated lifestyle packages (awqat, ...)
    me-docs          ; Documents (pdf-tools, nov, ...)
    me-latex         ; LaTeX (auctex, auctex-latexmk, reftex, bibtex, ...)
    ;; me-biblio     ; Bibliography & citations (org-cite, citar, zotxt, ...)
    me-natural-langs ; Natural language stuff (spell-fu, go-translate, eglot-ltex, ...)
    me-files         ; Files and directories (dirvish, treemacs, vlf, ...)
    me-tools         ; System tools (tramp, vterm, tldr, ssh-deploy, docker, ...)
    me-tty           ; Emacs from terminal (xt-mouse, xclip, ...)
    ;; me-fun        ; Games and funny packages (xkcd, speed-type, ...)
    ;; me-media      ; Multimedia (empv, emms, ...)
    ;; me-binary        ; Display binary files in hex or decompile them (hexl, ...) ...
    me-window)       ; Frame & window tweaks
  "MinEmacs enabled modules."
  :group 'minemacs-core
  :type '(repeat symbol))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; me-modules.el ends here
#+end_src

** me-splash.el
=me-splash.el= 下载包过程中简易界面 参考 [[github.com/rougier/emacs-splash][emacs-splash]]

文件头

#+begin_src emacs-lisp
;;; me-splash.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

界面定制

#+begin_src emacs-lisp
;; Adapted from: github.com/rougier/emacs-splash

(setq inhibit-startup-screen t)
(defvar minemacs-splash-buffer-name "*minemacs-splash*")

(defun minemacs-splash ()
  "MinEmacs splash screen"
  ;; If there are buffer associated with filenames, we don't show splash screen.
  (when (zerop (length (seq-filter #'identity (mapcar #'buffer-file-name (buffer-list)))))
    (let* ((buffer (get-buffer-create minemacs-splash-buffer-name))
           (height (- (window-body-height nil) 1))
           (padding-center (min 5 (- (/ height 3) 1)))
           (padding-bottom (min 2 (- height (/ height 3) 3))))
      (with-current-buffer buffer
        (erase-buffer)
        ;; Buffer local settings
        (setq-local cursor-type nil
                    vertical-scroll-bar nil
                    horizontal-scroll-bar nil)

        ;; Vertical padding to center
        (insert-char ?\n padding-center)

        ;; Central text
        (insert-char ?\s 10)
        (insert (propertize "MinEmacs" 'face 'bold))
        (insert-char ?\n)
        (insert-char ?\s 10)
        (insert (propertize
                 (format "Running GNU Emacs %s%s"
                         emacs-version
                         (if emacs-repository-version
                             (format " (%s)" (substring emacs-repository-version 0 10))
                           ""))
                 'face 'shadow))

        ;; Bootstraping
        (unless (file-exists-p (concat minemacs-local-dir "straight/repos/straight.el/bootstrap.el"))
          (insert-char ?\n)
          (insert-char ?\s 10)
          (insert (propertize "You are running MinEmacs for the first time."
                              'face 'warning))
          (insert-char ?\n)
          (insert-char ?\s 10)
          (insert (propertize "Please wait while MinEmacs installs the required packages."
                              'face 'warning)))

        ;; Vertical padding to bottom
        (insert-char ?\n padding-bottom)

        ;; Copyright text
        (insert-char ?\n)
        (insert-char ?\s 10)
        (insert (propertize "Minimal Emacs configuration for daily use" 'face 'shadow))
        (insert-char ?\n)
        (insert-char ?\s 10)
        (insert-text-button "github.com/donneyluck/emacs-config"
                            'action (lambda (_) (browse-url "https://github.com/donneyluck/emacs-config"))
                            'help-echo "Visit MinEmacs repo"
                            'follow-link t)
        (insert-char ?\n)

        (goto-char 0)
        (read-only-mode t)

        (local-set-key (kbd "<escape>") (lambda () (interactive) (minemacs-splash-kill)))
        (local-set-key (kbd "q") (lambda () (interactive) (minemacs-splash-kill)))
        (local-set-key (kbd "<mouse-1>") 'mouse-set-point)
        (local-set-key (kbd "<mouse-2>") 'operate-this-button)

        (display-buffer-same-window buffer nil)))))

(defun minemacs-splash-kill ()
  (when (get-buffer minemacs-splash-buffer-name)
    (kill-buffer minemacs-splash-buffer-name)))

;; Display splash screen
(minemacs-splash)

;; Close splash screen automatically after Emacs gets loaded
(add-hook
 'emacs-startup-hook
 (defun +minemacs-splash--kill-h ()
   (run-at-time 0.5 nil #'minemacs-splash-kill)))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-splash)
;;; me-splash.el ends here
#+end_src

** me-vars.el
=me-vars.el= 一些自定义变量

文件头

#+begin_src emacs-lisp
;;; me-vars.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

变量定义

#+begin_src emacs-lisp
;;; MinEmacs directories

(defgroup minemacs nil
  "MinEmacs specific functionalities.")

(defgroup minemacs-core nil
  "MinEmacs core tweaks."
  :group 'minemacs)

(defgroup minemacs-ui nil
  "MinEmacs UI tweaks."
  :group 'minemacs)

(defgroup minemacs-edit nil
  "MinEmacs editor tweaks."
  :group 'minemacs)

(defgroup minemacs-prog nil
  "MinEmacs programming stuff."
  :group 'minemacs)

(defgroup minemacs-keybinding nil
  "MinEmacs keybinding."
  :group 'minemacs)

(defgroup minemacs-utils nil
  "MinEmacs utility functions."
  :group 'minemacs)

(defconst minemacs-config-dir
  (file-name-as-directory
   (or (getenv "MINEMACS_DIR")
       (getenv "MINEMACSDIR")
       "~/.minemacs.d/"))
  "MinEmacs user customization directory.")

(defconst minemacs-debug
  (and (or (getenv "MINEMACS_DEBUG") init-file-debug) t)
  "MinEmacs is started in debug mode.")

(defconst minemacs-verbose
  (and (or (getenv "MINEMACS_VERBOSE") minemacs-debug) t)
  "MinEmacs is started in verbose mode.")

(defconst minemacs-not-lazy
  (or (daemonp) (and (getenv "MINEMACS_NOT_LAZY") t))
  "Load lazy packages (minemacs-lazy-hook) immediately.")

(defcustom minemacs-msg-level
  (let ((level (string-to-number (or (getenv "MINEMACS_MSG_LEVEL") ""))))
    (cond (minemacs-verbose 4)
          ((> level 0) level)
          (t 1)))
  "Level of printed messages.
1 - `+error!'
2 - `+info!'
3 - `+log!'
4 - `+debug!'"
  :group 'minemacs-core
  :type '(choice
          (const :tag "Error" 1)
          (const :tag "Info" 2)
          (const :tag "Log" 3)
          (const :tag "Debug" 4)))

;; Derive the root directory from this file path
(defconst minemacs-root-dir
  (abbreviate-file-name
   (file-name-directory
    (directory-file-name
     (file-name-directory (file-truename load-file-name))))))
(defconst minemacs-core-dir (concat minemacs-root-dir "core/"))
(defconst minemacs-assets-dir (concat minemacs-root-dir "assets/"))
(defconst minemacs-elisp-dir (concat minemacs-root-dir "elisp/"))
(defconst minemacs-modules-dir (concat minemacs-root-dir "modules/"))
(defconst minemacs-extras-dir (concat minemacs-modules-dir "extras/"))
(defconst minemacs-local-dir (concat minemacs-root-dir "local/"))
(defconst minemacs-cache-dir (concat minemacs-local-dir "cache/"))
(defconst minemacs-loaddefs-file (concat minemacs-core-dir "me-loaddefs.el"))

(defconst os/linux (and (memq system-type '(gnu gnu/linux)) t))
(defconst os/bsd (and (memq system-type '(darwin berkeley-unix gnu/kfreebsd)) t))
(defconst os/win (and (memq system-type '(cygwin windows-nt ms-dos)) t))
(defconst os/mac (eq system-type 'darwin))

;; Should return x86_64, aarch64, armhf, ...
(defconst sys/arch (intern (car (split-string system-configuration "-"))))

(defconst emacs/features
  (mapcar #'intern
          (mapcar (apply-partially #'string-replace "_" "-")
                  (mapcar #'downcase (split-string system-configuration-features))))
  "List of symbols representing Emacs' enabled features.
Compiled from the `system-configuration-features'.")

(defcustom minemacs-fonts nil
  "Fonts to use within MinEmacs."
  :group 'minemacs-ui
  :type '(plist
          (:font-family string)
          (:font-size natnum)
          (:unicode-font-family string)
          (:variable-pitch-font-family string)
          (:variable-pitch-font-size natnum)))

(defcustom minemacs-leader-key "SPC"
  "MinEmacs leader key."
  :group 'minemacs-keybinding
  :type 'string)

(defcustom minemacs-localleader-key "SPC m"
  "MinEmacs local leader (a.k.a. mode specific) key sequence."
  :group 'minemacs-keybinding
  :type 'string)

(defcustom minemacs-global-leader-prefix "C-SPC"
  "MinEmacs general leader key."
  :group 'minemacs-keybinding
  :type 'string)

(defcustom minemacs-global-mode-prefix "C-SPC m"
  "MinEmacs general local leader (a.k.a. mode specific) key sequence."
  :group 'minemacs-keybinding
  :type 'string)

(defcustom minemacs-theme 'doom-one-light
  "The theme of MinEmacs."
  :group 'minemacs-ui
  :type 'symbol)

(defcustom minemacs-after-set-fonts-hook nil
  "Runs after setting MinEmacs fonts, runs at the end of `+set-fonts'."
  :group 'minemacs-ui
  :type 'hook)

(defcustom minemacs-after-load-theme-hook nil
  "Runs after loading MinEmacs theme, runs at the end of `+load-theme'."
  :group 'minemacs-ui
  :type 'hook)

(defcustom minemacs-after-startup-hook nil
  "This hook will be run after loading Emacs.

MinEmacs hooks will be run in this order:
1. `minemacs-after-startup-hook'
2. `minemacs-lazy-hook'"
  :group 'minemacs-core
  :type 'hook)

(defcustom minemacs-lazy-hook nil
  "This hook will be run after loading Emacs, with laziness.

MinEmacs hooks will be run in this order:
1. `minemacs-after-startup-hook'
2. `minemacs-lazy-hook'"
  :group 'minemacs-core
  :type 'hook)

;; Setup default fonts (depending on the OS)
(let ((mono-font (cond (os/linux "monospace")
                       (os/win "Lucida Console")
                       (os/mac "monospace")))
      (varp-font (cond (os/linux "monospace")
                       (os/win "Tahoma")
                       (os/mac "monospace"))))
  (defconst minemacs-default-fonts
    `(:font-family ,mono-font
      :font-size 13
      :unicode-font-family nil
      :variable-pitch-font-family ,varp-font
      :variable-pitch-font-size 13)
    "Default fonts of MinEmacs."))
#+end_src

需要存储的环境变量KEY

#+begin_src emacs-lisp
(defcustom +env-save-vars
  '("PATH" "MANPATH" "CMAKE_PREFIX_PATH" "PKG_CONFIG_PATH" "LSP_USE_PLISTS" "HTTP_PROXY" "HTTPS_PROXY")
  "List of the environment variables to saved by `+env-save'.
You need to run Emacs from terminal to get the environment variables.
MinEmacs then save them when calling `+env-save' to be used in GUI sessions as well."
  :group 'minemacs-core
  :type '(repeat string))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-vars)
;;; me-vars.el ends here
#+end_src

** me-use-package-pin-ref.el
=me-use-package-pin-ref.el= 使用确定版本的包
[[https://github.com/radian-software/straight.el#how-do-i-pin-package-versions-or-use-only-tagged-releases][How do I pin package versions or use only tagged releases?]]

文件头

#+begin_src emacs-lisp
;;; me-use-package-pin-ref.el --- Extend use-package to allow straight-x package pinning -*- lexical-   binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; Add support for pinning versions of individual packages. See:
;; github.com/radian-software/straight.el#how-do-i-pin-package-versions-or-use-only-tagged-releases

;;; Code:
#+end_src

扩展 =use-package= 支持固定版本的包

#+begin_src emacs-lisp
(with-eval-after-load 'straight
  ;; Add a profile (and lockfile) for stable package revisions.
  (add-to-list 'straight-profiles '(pinned . "pinned.el"))
  (require 'straight-x))

;; Allow pinning versions from `use-package' using the `:pin-ref' keyword
(with-eval-after-load 'use-package-core
  (add-to-list 'use-package-keywords :pin-ref)

  (defun use-package-normalize/:pin-ref (_name-symbol keyword args)
    (use-package-only-one (symbol-name keyword) args
      (lambda (_label arg)
        (cond
         ((stringp arg) arg)
         ((symbolp arg) (symbol-name arg))
         (t (use-package-error ":pin-ref wants a commit hash or a ref."))))))

  (defun use-package-handler/:pin-ref (name-symbol _keyword ref rest state)
    (let ((body (use-package-process-keywords name-symbol rest state)))
      (if (null ref)
          body
        `((let ((straight-current-profile 'pinned))
           (push '(,(symbol-name name-symbol) . ,ref) straight-x-pinned-packages)
           ,(macroexp-progn body)))))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-use-package-pin-ref)
;;; me-use-package-pin-ref.el ends here
#+end_src

** minemacs-loaded.el
=minemacs-loaded.el= 同步加载
Virtual module loaded at end of init.el (after custom-vars.el)
Used to synchronize loading some other stuff after loading Emacs

文件头

#+begin_src emacs-lisp
;;; minemacs-loaded.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; Virtual module loaded at end of init.el (after custom-vars.el)
;; Used to synchronize loading some other stuff after loading Emacs

;;; Code:
#+end_src

同步加载一些其他东西

#+begin_src emacs-lisp
;; Run hooks
(when minemacs-after-startup-hook
  (setq minemacs-after-startup-hook (reverse minemacs-after-startup-hook))
  (+log! "Running %d `minemacs-after-startup-hook' hooks."
         (length minemacs-after-startup-hook))
  (run-hooks 'minemacs-after-startup-hook))

(if minemacs-not-lazy
    (require 'minemacs-lazy)
  (+eval-when-idle-for! 2
    (require 'minemacs-lazy)))

(+log! "Providing `minemacs-loaded'.")
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'minemacs-loaded)
;;; minemacs-loaded.el ends here
#+end_src

** minemacs-lazy.el
=minemacs-lazy.el= 惰性加载hook
Virtual module loaded when idle after `minemacs-loaded'.
Used to synchronize loading some other stuff after loading Emacs.

文件头

#+begin_src emacs-lisp
;;; minemacs-lazy.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; Virtual module loaded when idle after `minemacs-loaded'.
;; Used to synchronize loading some other stuff after loading Emacs.

;; The hooks in `minemacs-lazy-hook' are loaded incrementally when Emacs goes
;; idle, but when `minemacs-not-lazy' is set to t, they will be all loaded at
;; once.

;;; Code:
#+end_src

=lazy hook=

#+begin_src emacs-lisp
;; Run hooks
(when minemacs-lazy-hook
  ;; Reverse the order to follow the order in which modules are loaded. Make
  ;; sure `gcmh-mode' is the last to be called. The `gc-cons-threshold' has been
  ;; set in "early-init.el" to a ridiculously high value to reduce the number of
  ;; garbage collections at startup, it will be overwritten by `gcmh-mode', so
  ;; we defer loading it to the end to maximize the benefit.
  (setq minemacs-lazy-hook (append (delq 'gcmh-mode (reverse minemacs-lazy-hook)) '(gcmh-mode)))
  (if minemacs-not-lazy
      (progn ; If `minemacs-no-lazy' is bound and true, force loading lazy hooks immediately
        (+log! "Loading %d lazy packages immediately."
               (length minemacs-lazy-hook))
        (run-hooks 'minemacs-lazy-hook))
    (+log! "Loading %d lazy packages incrementally." (length minemacs-lazy-hook))
    ;; Run hooks one by one, as a FIFO.
    (apply #'+eval-when-idle (append '(1) minemacs-lazy-hook))))

(+log! "Providing `minemacs-lazy'.")
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'minemacs-lazy)
;;; minemacs-lazy.el ends here
#+end_src

* elisp/
:properties:
:path:     ~/.emacs.d/elisp/
:end:
=elisp= 目录下是一些自己实现的扩展
** +binary.el
=+binary.el= 一些二进制相关的包

文件头

#+begin_src emacs-lisp
;;; +binary.el --- binary -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=objdump= 扩展  二进制相关

#+begin_src emacs-lisp
(defgroup minemacs-binary nil
  "MinEmacs binary files."
  :group 'minemacs)

(defcustom +binary-objdump-executable (executable-find "objdump")
  "Path to the executable \"objdump\" utility."
  :group 'minemacs-binary
  :type 'string)

(defcustom +binary-objdump-enable t
  "Enable or disable disassembling suitable files with objdump."
  :group 'minemacs-binary
  :type 'boolean)

(defcustom +binary-hexl-enable t
  "Enable or disable openning suitable files in `hexl-mode'."
  :group 'minemacs-binary
  :type 'boolean)

;;;###autoload
(defun +binary-objdump-buffer-p (&optional buffer)
  "Can the BUFFER be viewed as a disassembled code with objdump."
  (and +binary-objdump-enable
       (when-let* ((file (buffer-file-name (or buffer (current-buffer))))
                   (file (file-truename file)))
         (and +binary-objdump-executable
              (file-exists-p file)
              (not (file-directory-p file))
              (not (zerop (file-attribute-size (file-attributes file))))
              (not (string-match-p
                    "file format not recognized"
                    (with-temp-buffer
                      (shell-command (format "%s --file-headers %s"
                                             +binary-objdump-executable
                                             (shell-quote-argument file))
                                     (current-buffer))
                      (buffer-string))))))))

;; A predicate for detecting binary files. Inspired by:
;; emacs.stackexchange.com/q/10277/37002)
(defun +binary-buffer-p (&optional buffer)
  "Return whether BUFFER or the current buffer is binary.

A binary buffer is defined as containing at least one null byte.

Returns either nil, or the position of the first null byte."
  (with-current-buffer (or buffer (current-buffer))
    (save-excursion
      (goto-char (point-min))
      (search-forward (string ?\x00) nil t 1))))

;;;###autoload
(defun +binary-hexl-buffer-p (&optional buffer)
  "Is the current buffer should be viewed using `hexl-mode'."
  (and +binary-hexl-enable
       (+binary-buffer-p buffer)
       ;; Executables are viewed with objdump mode
       (not (+binary-objdump-buffer-p buffer))))

;;;###autoload
(define-derived-mode objdump-disassemble-mode
  asm-mode "Objdump Mode"
  "Major mode for viewing executable files disassembled using objdump."
  (if (+binary-objdump-buffer-p)
      (when-let ((file (buffer-file-name))
                 (buffer-read-only nil))
        (message "Disassembling file \"%s\" using objdump." (file-name-nondirectory file))
        (erase-buffer)
        (call-process "objdump" nil (current-buffer) nil "-d" file)
        (view-mode)
        (goto-char (point-min))
        (set-buffer-modified-p nil)
        (set-visited-file-name nil t)
        (buffer-disable-undo)
        (set-buffer-modified-p nil)
        (setq-local buffer-read-only t))
    (message "Objdump can not be used with this buffer.")))

;;;###autoload
(defun +binary-hexl-mode-maybe ()
  "If `hexl-mode' is not already active, and the current buffer
is binary, activate `hexl-mode'."
  (interactive)
  (unless (eq major-mode 'hexl-mode)
    (when (+binary-hexl-buffer-p)
      (hexl-mode))))

;;;###autoload
(defun +binary-setup-modes ()
  (add-to-list 'magic-fallback-mode-alist '(+binary-objdump-buffer-p . objdump-disassemble-mode) t)
  (add-to-list 'magic-fallback-mode-alist '(+binary-hexl-buffer-p . +binary-hexl-mode-maybe) t))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +binary.el ends here
#+end_src

** +buffer.el
=+buffer.el= 一些关于buffer的函数

文件头

#+begin_src emacs-lisp
;;; +buffer.el --- buffer misc cmds -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

一些关于buffer的函数 [[emacswiki.org/emacs/download/misc-cmds.el][misc-cmds]]
#+begin_src emacs-lisp
(defgroup minemacs-buffer nil
  "MinEmacs buffer stuff."
  :group 'minemacs)

;; From: emacswiki.org/emacs/download/misc-cmds.el
;; Candidate as a replacement for `kill-buffer', at least when used interactively.
;; For example: (define-key global-map [remap kill-buffer] 'kill-buffer-and-its-windows)
;; We cannot just redefine `kill-buffer', because some programs count on a
;; specific other buffer taking the place of the killed buffer (in the window).
;;;###autoload
(defun +kill-buffer-and-its-windows (buffer &optional msgp)
  "Kill BUFFER and delete its windows.  Default is `current-buffer'.
BUFFER may be either a buffer or its name (a string)."
  (interactive (list (read-buffer "Kill buffer: " (current-buffer) 'existing) 'MSGP))
  (setq buffer (get-buffer buffer))
  (if (buffer-live-p buffer) ; Kill live buffer only.
      (let ((wins (get-buffer-window-list buffer nil t))) ; On all frames.
        (when (kill-buffer buffer) ; Only delete windows if buffer killed.
          (dolist (win wins) ; (User might keep buffer if modified.)
            (when (window-live-p win)
              ;; Ignore error, in particular,
              ;; "Attempt to delete the sole visible or iconified frame".
              (condition-case nil (delete-window win) (error nil))))))
    (when msgp (user-error "Cannot kill buffer.  Not a live buffer: `%s'" buffer))))

;; From: emacswiki.org/emacs/download/misc-cmds.el
;;;###autoload
(defun +region-to-buffer (start end buffer arg)
  "Copy region to BUFFER: At beginning (prefix >= 0), end (< 0), or replace.
START and END are the region boundaries.
BUFFER is a buffer or its name (a string).
With prefix ARG >= 0: `append-to-buffer':
  Append contents of region to end of BUFFER.
  (Point is moved to end of BUFFER first.)
With prefix ARG < 0:  `prepend-to-buffer':
  Prepend contents of region to beginning of BUFFER.
  (Point is moved to beginning of BUFFER first.)
With no prefix ARG (nil): `copy-to-buffer'.
  Write region to BUFFER, replacing any previous contents."
  (interactive
   (let ((arg (and current-prefix-arg (prefix-numeric-value current-prefix-arg))))
     (list (region-beginning)
           (region-end)
           (read-buffer
            (concat (if arg
                        (if (natnump arg) "Append" "Prepend")
                      "Write")
                    " region to buffer: ")
            (if (fboundp 'another-buffer) ; Defined in `misc-fns.el'.
                (another-buffer nil t)
              (other-buffer (current-buffer))))
           arg)))
  (setq buffer (get-buffer-create buffer)) ; Convert to buffer.
  (when (eq buffer (current-buffer)) (error "Cannot copy region to its own buffer"))
  (cond ((natnump arg)
         (with-current-buffer buffer (goto-char (point-max)))
         (append-to-buffer buffer start end))
        (arg
         (with-current-buffer buffer (goto-char (point-min)))
         (prepend-to-buffer buffer start end))
        (t (copy-to-buffer buffer start end))))

;; From: emacswiki.org/emacs/download/misc-cmds.el
;;;###autoload
(defun +region-to-file (start end filename arg)
  "With prefix arg, this is `append-to-file'.  Without, it is `write-region'.
START and END are the region boundaries.
Prefix ARG non-nil means append region to end of  file FILENAME.
Prefix ARG nil means write region to FILENAME, replacing contents."
  (interactive
   (list (region-beginning)
         (region-end)
         (read-file-name (concat (if current-prefix-arg "Append" "Write")
                                 " region to file: "))
         current-prefix-arg))
  (let* ((curr-file (buffer-file-name))
         (same-file-p (and curr-file (string= curr-file filename))))
    (cond ((or (not same-file-p)
               (progn (when (fboundp 'flash-ding) (flash-ding))
                      (yes-or-no-p
                       (format
                        "Do you really want to REPLACE the contents of `%s' by just the REGION? "
                        (file-name-nondirectory curr-file)))))
           (write-region start end filename arg)
           (when same-file-p (revert-buffer t t)))
          (t (message "OK.  Not written.")))))

;;;###autoload
(defun +kill-some-buffers (&optional list)
  "Kill some buffers.  Asks the user whether to kill the modified ones.
Non-interactively, if optional argument LIST is non-nil, it
specifies the list of buffers to kill, asking for approval for each one.
See `kill-some-buffers'."
  (interactive)
  ;; Replace the `kill-buffer-ask' locally (used by `kill-some-buffers')
  ;; with our function which don't ask about unmodified buffers.
  (cl-letf (((symbol-function 'kill-buffer-ask) #'+kill-buffer-ask-if-modified))
    (kill-some-buffers list)))

(defcustom +kill-buffer-no-ask-list
  (list messages-buffer-name "*Warnings*")
  "A list of buffer names to be killed without confirmation."
  :group 'minemacs-buffer
  :type '(repeat string))

(with-eval-after-load 'comp
  (when (featurep 'native-compile)
    (setq
     +kill-buffer-no-ask-list
     (append +kill-buffer-no-ask-list
             (list comp-async-buffer-name comp-log-buffer-name)))))

;;;###autoload
(defun +kill-buffer-ask-if-modified (buffer)
  "Like `kill-buffer-ask', but kills BUFFER without confirmation if buffer is unmodified.
Kill without asking for buffer names in `+kill-buffer-no-ask-list'."
  (when (or (not (buffer-modified-p buffer))
            (member (buffer-name buffer) +kill-buffer-no-ask-list)
            (yes-or-no-p (format "Buffer %s HAS BEEN MODIFIED.  Kill? "
                                 (buffer-name buffer))))
    (kill-buffer buffer)))

;; From: emacswiki.org/emacs/download/misc-cmds.el
;;;###autoload
(defun +delete-extra-windows-for-buffer ()
  "Delete all other windows showing the selected window's buffer."
  (interactive)
  (let* ((selwin (selected-window))
         (buf (window-buffer selwin)))
    (walk-windows
     (lambda (ww)
       (unless (eq ww selwin)
         (when (eq (window-buffer ww) buf)
           (delete-window ww))))
     'NO-MINI 'THIS-FRAME)))

;; From: emacswiki.org/emacs/download/misc-cmds.el
;;;###autoload
(defun +delete-window-maybe-kill-buffer ()
  "Delete selected window.
If no other window shows its buffer, kill the buffer too."
  (interactive)
  (let* ((selwin (selected-window))
         (buf (window-buffer selwin)))
    (delete-window selwin)
    (unless (get-buffer-window buf 'visible) (kill-buffer buf))))

;;;###autoload
(defun +fill-scratch-buffer ()
  "Fill the `initial-scratch-message'.
When available, use \"fortune\" to add a random quote."
  ;; Print load time, and a quote to *scratch*
  (with-current-buffer (get-scratch-buffer-create)
    (erase-buffer)
    (insert (format
             ";; MinEmacs loaded in %.2fs with %d garbage collection%s done!\n"
             (string-to-number (car (string-split (emacs-init-time))))
             gcs-done (if (> gcs-done 1) "s" "")))
    (insert ";; ==============================\n")
    ;; Insert a random quote from "fortune" when the command is available
    (when (executable-find "fortune")
      (insert (string-join
               (mapcar (apply-partially #'concat ";; ")
                       (string-lines (shell-command-to-string "fortune")))
               "\n"))
      (insert "\n;; ==============================\n"))
    ;; Set initial scratch message
    (setq initial-scratch-message (buffer-string))))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +buffer.el ends here
#+end_src

** +eglot.el
=+eglot.el=  eglot 扩展

文件头

#+begin_src emacs-lisp
;;; +eglot.el --- eglot -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=eglot autoload= 注册modes 和 对应的lsp-server

#+begin_src emacs-lisp
;;;###autoload
(defun +eglot-register (modes &rest servers)
  "Register MODES with LSP SERVERS.
Examples:
  (+eglot-register 'vhdl-mode \"vhdl_ls\")
  (+eglot-register 'lua-mode \"lua-language-server\" \"lua-lsp\")
  (+eglot-register '(c-mode c++-mode) '(\"clangd\" \"--clang-tidy\" \"-j=12\") \"ccls\")"
  (declare (indent 0))
  (with-eval-after-load 'eglot
    (add-to-list
     'eglot-server-programs
     (cons modes (if (length> servers 1)
                     (eglot-alternatives (ensure-list servers))
                   (ensure-list (car servers)))))))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +eglot.el ends here
#+end_src

** ecryptfs.el
=ecryptfs.el= private文件夹的加密解密

文件头

#+begin_src emacs-lisp
;;; +ecryptfs.el --- ecryptfs -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; This allows me to mount my private directory encrypted using ecryptfs-utils.
;; It is a port of "ecryptfs-mount-private" shell command. It uses extracts the
;; encryption key from a GPG encrypted file containting the ecryptfs password.
;; The decryption of the password is performed using Emacs' `epg'.

;;; Code:
#+end_src

通过 =ecryptfs= 实现对private文件的加密和解密

#+begin_src emacs-lisp
(require 'epg)

(defgroup minemacs-ecryptfs nil
  "MinEmacs eCryptfs."
  :group 'minemacs)

(defcustom ecryptfs-private-dir-name "Private"
  "eCryptfs private directory name."
  :group 'minemacs-ecryptfs
  :type 'string)

(defcustom ecryptfs-root-dir "~/.ecryptfs/"
  "eCryptfs root configuration directory."
  :group 'minemacs-ecryptfs
  :type 'directory)

(defvar ecryptfs-buffer-name " *emacs-ecryptfs*")
(defvar ecryptfs-process-name "emacs-ecryptfs")
(defvar ecryptfs--mount-private-cmd "/sbin/mount.ecryptfs_private")
(defvar ecryptfs--umount-private-cmd "/sbin/umount.ecryptfs_private")

(defun ecryptfs--wrapped-passphrase-file ()
  (concat ecryptfs-root-dir "wrapped-passphrase"))

(defun ecryptfs--mount-passphrase-sig-file ()
  (concat ecryptfs-root-dir ecryptfs-private-dir-name ".sig"))

(defun ecryptfs--passphrase ()
  (string-trim-right
   (epg-decrypt-file
    (epg-make-context)
    (expand-file-name (concat ecryptfs-root-dir "my-pass.gpg"))
    nil)))

(defun ecryptfs--encrypt-filenames-p ()
  (/= 1 (with-temp-buffer
          (insert-file-contents (ecryptfs--mount-passphrase-sig-file))
          (count-lines (point-min) (point-max)))))

(defun ecryptfs-available-p ()
  (and (file-directory-p (expand-file-name ecryptfs-private-dir-name "~"))
       (cl-every #'file-exists-p (list ecryptfs--mount-private-cmd
                                       ecryptfs--umount-private-cmd
                                       (ecryptfs--wrapped-passphrase-file)
                                       (ecryptfs--mount-passphrase-sig-file)))))

(defun ecryptfs--unwrap-passphrase-command ()
  (format
   (if (ecryptfs--encrypt-filenames-p)
       "ecryptfs-insert-wrapped-passphrase-into-keyring %s '%s'"
     "ecryptfs-unwrap-passphrase %s '%s' | ecryptfs-add-passphrase -")
   (ecryptfs--wrapped-passphrase-file) (ecryptfs--passphrase)))

(defun ecryptfs-private-mounted-p ()
  (let ((mount (shell-command-to-string "mount")))
    (and (string-match-p (concat ".*" (expand-file-name ecryptfs-private-dir-name "~") ".*ecryptfs.*") mount)
         t)))

;;;###autoload
(defun ecryptfs-toggle-mount-private ()
  "Mount/Unmount eCryptfs' private directory."
  (interactive)
  (if (ecryptfs-private-mounted-p)
      (ecryptfs-umount-private)
    (ecryptfs-mount-private)))

;;;###autoload
(defun ecryptfs-mount-private ()
  "Mount eCryptfs' private directory."
  (interactive)
  (if (not (and (file-exists-p (ecryptfs--wrapped-passphrase-file))
                (file-exists-p (ecryptfs--mount-passphrase-sig-file))))
      (user-error "Encrypted private directory \"%s\" is not setup properly."
                  ecryptfs-private-dir-name)
    (let ((try-again t))
      (message "Encrypted filenames mode [%s]" (if (ecryptfs--encrypt-filenames-p) "ON" "OFF"))
      (while (and ;; In the first iteration, we try to silently mount the ecryptfs private directory,
              ;; this would succeed if the key is available in the keyring.
              (prog1 (not (zerop (shell-command ecryptfs--mount-private-cmd ecryptfs-buffer-name)))
                (message "Successfully mounted private directory."))
              (prog1 try-again (setq try-again nil)))
        (if (zerop (shell-command (ecryptfs--unwrap-passphrase-command) ecryptfs-buffer-name))
            (message "Successfully mounted private directory.")
          (user-error "A problem occured while mounting the private directory, see %s"
                      ecryptfs-buffer-name))))))

;;;###autoload
(defun ecryptfs-umount-private ()
  "Unmount eCryptfs' private directory."
  (interactive)
  (if (zerop (shell-command ecryptfs--umount-private-cmd ecryptfs-buffer-name))
      (message "Unmounted private directory successfully.")
    (user-error "Cannot unmount the private directory, seems to be already unmounted.")))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; ecryptfs.el ends here
#+end_src

** +io.el
=+io= io的扩展函数

文件头

#+begin_src emacs-lisp
;;; +io.el --- io -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

#+begin_src emacs-lisp
;;;###autoload
(defun +file-mime-type (file)
  "Get MIME type for FILE based on magic codes provided by the 'file' command.
Return a symbol of the MIME type, ex: `text/x-lisp', `text/plain',
`application/x-object', `application/octet-stream', etc."
  (if-let ((file-cmd (executable-find "file"))
           (mime-type (shell-command-to-string (format "%s --brief --mime-type %s" file-cmd file))))
      (intern (string-trim-right mime-type))
    (error "The \"file\" command isn't installed.")))

;;;###autoload
(defun +file-name-incremental (filename)
  "Return an unique file name for FILENAME.
If \"file.ext\" exists, returns \"file-0.ext\"."
  (let* ((ext (file-name-extension filename))
         (dir (file-name-directory filename))
         (file (file-name-base filename))
         (filename-regex (concat "^" file "\\(?:-\\(?1:[[:digit:]]+\\)\\)?" (if ext (concat "\\." ext) "")))
         (last-file (car (last (directory-files dir nil filename-regex))))
         (last-file-num (and last-file (string-match filename-regex last-file) (match-string 1 last-file)))
         (num (1+ (string-to-number (or last-file-num "-1")))))
    (file-name-concat dir (format "%s%s%s" file (if last-file (format "-%d" num) "") (if ext (concat "." ext) "")))))

;;;###autoload
(defun +file-read-to-string (filename)
  "Return a string with the contents of FILENAME."
  (when (and (file-exists-p filename) (not (file-directory-p filename)))
    (with-temp-buffer
      (insert-file-contents filename)
      (buffer-string))))

;;;###autoload
(defun +directory-subdirs (dir)
  "Return a list of sub-directories in DIR."
  (when dir
    (seq-filter #'file-directory-p
                (mapcar #'abbreviate-file-name
                        (directory-files dir t "[^.][^.]?$")))))

;;;###autoload
(defun +directory-ensure (&rest path-parts)
  "Concatenate PATH-PARTS to construct a path and return it.

Ensure the path exists, if not create it. The exact behavior is to create the
parent directory if the path is a file, and if the path is a directory, create
that directory."
  (let* ((path (mapconcat #'identity path-parts nil))
         (parent-dir (file-name-directory path)))
    (unless (file-directory-p parent-dir)
      (ignore-errors (mkdir parent-dir t))
      (unless (file-directory-p parent-dir)
        (+error! "Cannot create directory %s" parent-dir)))
    path))

;;;###autoload
(defun +delete-this-file (&optional path force-p)
  "Delete PATH.

If PATH is not specified, default to the current buffer's file.

If FORCE-P, delete without confirmation."
  (interactive
   (list (buffer-file-name (buffer-base-buffer))
         current-prefix-arg))
  (let* ((path (or path (buffer-file-name (buffer-base-buffer))))
         (short-path (abbreviate-file-name path)))
    (unless (and path (file-exists-p path))
      (user-error "Buffer is not visiting any file"))
    (unless (file-exists-p path)
      (error "File doesn't exist: %s" path))
    (unless (or force-p (y-or-n-p (format "Really delete %S?" short-path)))
      (user-error "Aborted"))
    (let ((buf (current-buffer)))
      (unwind-protect
          (progn (delete-file path t) t)
        (when (file-exists-p path)
          (error "Failed to delete %S" short-path))))))

;;;###autoload
(defun +move-this-file (new-path &optional force-p)
  "Move current buffer's file to NEW-PATH.

If FORCE-P, overwrite the destination file if it exists, without confirmation."
  (interactive
   (list (read-file-name "Move file to: ")
         current-prefix-arg))
  (unless (and buffer-file-name (file-exists-p buffer-file-name))
    (user-error "Buffer is not visiting any file"))
  (let ((old-path (buffer-file-name (buffer-base-buffer)))
        (new-path (expand-file-name new-path)))
    (when (directory-name-p new-path)
      (setq new-path (expand-file-name (file-name-nondirectory old-path) new-path)))
    (make-directory (file-name-directory new-path) t)
    (rename-file old-path new-path (or force-p 1))
    (set-visited-file-name new-path t t)
    ;; (doom-files--update-refs old-path new-path)
    (message "File moved to %S" (abbreviate-file-name new-path))))

;;;###autoload
(defun +tramp-sudo-file-path (file)
  "Construct a Tramp sudo path to FILE. Works for both local and remote files."
  (let ((host (or (file-remote-p file 'host) "localhost")))
    (concat "/" (when (file-remote-p file)
                  (concat (file-remote-p file 'method) ":"
                          (if-let (user (file-remote-p file 'user))
                              (concat user "@" host)
                            host)
                          "|"))
            "sudo:root@" host
            ":" (or (file-remote-p file 'localname)
                    file))))

;;;###autoload
(defun +sudo-find-file (file)
  "Open FILE as root."
  (interactive "FOpen file as root: ")
  (find-file (+tramp-sudo-file-path file)))

;;;###autoload
(defun +sudo-this-file ()
  "Open the current file as root."
  (interactive)
  (if-let ((this-file (or buffer-file-name
                          (when (derived-mode-p 'dired-mode 'wdired-mode)
                            default-directory))))
      (find-file (+tramp-sudo-file-path this-file))
    (user-error "Current buffer not bound to a file")))

;;;###autoload
(defun +sudo-save-buffer ()
  "Save this file as root."
  (interactive)
  (if buffer-file-name
      (if-let ((file (+tramp-sudo-file-path buffer-file-name))
               (buffer (find-file-noselect file))
               (origin (current-buffer)))
          (progn
            (copy-to-buffer buffer (point-min) (point-max))
            (unwind-protect
                (with-current-buffer buffer
                  (save-buffer))
              (unless (eq origin buffer)
                (kill-buffer buffer))
              (with-current-buffer origin
                (revert-buffer t t))))
        (user-error "Unable to open %S" file))
    (user-error "Current buffer not bound to a file")))

;;;###autoload
(defun +yank-this-file-name ()
  "Yank the file name of this buffer."
  (interactive)
  (if-let ((file (buffer-file-name)))
      (with-temp-buffer
        (insert file)
        (kill-ring-save (point-min) (point-max)))
    (user-error "This buffer isn't bound to a file.")))

;;;###autoload
(defun +clean-file-name (filename &optional downcase-p)
  "Clean file name."
  ;; Clean slashes, backslashes, ":", ";", spaces, and tabs
  (replace-regexp-in-string
   "[:;\t\n\r /\\_]+" "-"
   (replace-regexp-in-string
    "[‘’‚’“”„”\"`'()&]+" ""
    (if downcase-p (downcase filename) filename))))

(defcustom +html2pdf-default-backend 'wkhtmltopdf
  "The default backend to convert HTML files to PDFs in `+html2pdf'."
  :group 'minemacs-utils
  :type '(choice
          (const wkhtmltopdf)
          (const htmldoc)
          (const weasyprint)
          (const pandoc+context)))

;;;###autoload
(defun +html2pdf (infile outfile &optional backend)
  "Convert HTML file INFILE to PDF and save it to OUTFILE.
When BACKEND is provided, the corresponding program is used, otherwise, the
value of `+html2pdf-default-backend' is used."
  (if-let ((default-directory (file-name-directory infile))
           (backend (or backend +html2pdf-default-backend))
           (backend-command
            (pcase backend
              ('weasyprint
               (list "weasyprint"
                     "--encoding" "utf-8"
                     "--stylesheet" (expand-file-name "templates/weasyprint-pdf.css" minemacs-assets-dir)
                     infile outfile))
              ('htmldoc
               (list "htmldoc"
                     "--charset" "utf-8"
                     "--bodyfont" "sans" "--textfont" "sans" "--headfootfont" "sans"
                     "--top" "10#mm" "--bottom" "10#mm" "--right" "10#mm" "--left" "10#mm"
                     "--fontsize" "11"
                     "--size" "a4"
                     "--continuous"
                     "--outfile" outfile infile))
              ('wkhtmltopdf
               (list "wkhtmltopdf"
                     "--images" "--disable-javascript" "--enable-local-file-access"
                     "--encoding" "utf-8"
                     infile outfile))
              ('pandoc+context
               (list "pandoc"
                     "--pdf-engine=context"
                     "--variable" "fontsize=10pt"
                     "--variable" "linkstyle=slanted"
                     "-o" outfile infile)))))
      (apply #'call-process (append (list (car backend-command) nil nil nil) (cdr backend-command)))
    (user-error "Backend \"%s\" not available." backend)))

;;;###autoload
(defun +txt2html (infile outfile &optional mail-mode-p)
  "Convert plain-text file INFILE to HTML and save it to OUTFILE.
When MAIL-MODE-P is non-nil, --mailmode is passed to \"txt2html\"."
  (apply #'call-process (append '("txt2html" nil nil nil "-8")
                                (when mail-mode-p '("--mailmode"))
                                (list "--outfile" outfile infile))))

(defvar +save-as-pdf-filename nil
  "File name to use, if non-nil, for the output file.")

;;;###autoload
(defun +save-as-pdf (infile &optional mail-mode-p)
  "Save URL as PDF.
This function's signature is compatible with `browse-url-browser-function'
so it can be used to save HTML pages or emails to PDF.
When MAIL-MODE-P is non-nil, treat INFILE as a mail."
  (let* ((infile (string-trim-left infile "file://"))
         (outfile (+file-name-incremental
                   (or +save-as-pdf-filename
                       (expand-file-name
                        (file-name-with-extension (file-name-base infile) ".pdf")
                        (file-name-directory infile))))))
    (if (zerop
         ;; For HTML files, just call `+html2pdf'
         (if (string= "html" (file-name-extension infile))
             (+html2pdf infile outfile)
           ;; For non-HTML (plain-text) files, convert them to HTML then call `+html2pdf'
           (let ((tmp-html (make-temp-file "txt2html-" nil ".html")))
             (+txt2html infile tmp-html mail-mode-p)
             (+html2pdf tmp-html outfile))))
        (message "Exported PDF to %s"
                 (truncate-string-to-width
                  (abbreviate-file-name outfile)
                  (/ (window-width (minibuffer-window)) 2) nil nil t))
      (user-error
       (if (file-exists-p outfile)
           "PDF created but with some errors!"
         "An error occurred, cannot create the PDF!")))))

;;;###autoload
(defcustom +single-file-executable (executable-find "single-file")
  "The executable for \"single-file\" which is used archive HTML pages.")

;;;###autoload
(defun +single-file (url out-file)
  "Save URL into OUT-FILE as a standalone HTML file."
  (if (and +single-file-executable (executable-find +single-file-executable))
      (make-process
       :name "single-file-cli"
       :buffer "*single-file*"
       :command (list
                 +single-file-executable
                 "--browser-executable-path" browse-url-chromium-program
                 url out-file))
    (user-error "Please set `+single-file-executable' accordingly.")))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +io.el ends here
#+end_src

** +emacs.el
=+emacs.el= emacs的一些扩展

文件头

#+begin_src emacs-lisp
;;; +emacs.el --- emacs -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=.dir_local=
TODO:看不懂先这样

#+begin_src emacs-lisp
;;;###autoload
(defun +dir-locals-reload-for-this-buffer ()
  "Reload directory-local for the current buffer"
  (interactive)
  (let ((enable-local-variables :all))
    (hack-dir-local-variables-non-file-buffer)
    (+info! "Reloaded directory-local variables for buffer %s"
            (buffer-name (current-buffer)))))

;;;###autoload
(defun +dir-locals-reload-for-all-buffers-in-this-directory ()
  "For every buffer with the same `default-directory` as the
current buffer's, reload dir-locals."
  (interactive)
  (let ((dir default-directory))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (equal default-directory dir)
          (+dir-locals-reload-for-this-buffer))))))

(defun +dir-locals--autoreload-h ()
  (when (and (buffer-file-name)
             (equal dir-locals-file (file-name-nondirectory (buffer-file-name))))
    (+dir-locals-reload-for-all-buffers-in-this-directory)
    (message "Reloaded directory-local variables defined in %s." dir-locals-file)))

(defvar +dir-locals--autoreload-p nil)

;;;###autoload
(defun +dir-locals-toggle-autoreload (&optional enable)
  "Toggle autoloading directory-local variables after editing the \".dir-locals\" file.
If ENABLE is non-nil, force enabling autoreloading."
  (interactive)
  (if (or enable +dir-locals--autoreload-p)
      (progn
        (remove-hook 'after-save-hook #'+dir-locals--autoreload-h)
        (setq +dir-locals--autoreload-p nil)
        (message "Disabled auto-reloading directory-locals."))
    (add-hook 'after-save-hook #'+dir-locals--autoreload-h)
    (setq +dir-locals--autoreload-p t)
    (message "Enabled auto-reloading directory-locals.")))

;;;###autoload
(defun +dir-locals-open-or-create ()
  "Open or create the dir-locals.el for the current project."
  (interactive)
  (let* ((file-name (buffer-file-name))
         (base-dir (car (ensure-list (dir-locals-find-file file-name)))))
    (find-file
     (cond (base-dir (expand-file-name dir-locals-file base-dir))
           ((project-current) (expand-file-name dir-locals-file (project-root (project-current))))
           ((vc-root-dir) (expand-file-name dir-locals-file (vc-root-dir)))
           (t (expand-file-name dir-locals-file (file-name-directory file-name)))))))
#+end_src

文件保存前是否删除尾部多于的空格

#+begin_src emacs-lisp
;; The hook is defined and enabled by default in `me-defaults'
;;;###autoload
(defun +toggle-auto-whitespace-cleanup ()
  "Toggle auto-deleting trailing whitespaces."
  (interactive)
  (if (member #'+save--whitespace-cleanup-h before-save-hook)
      (progn
        (message "+toggle-auto-whitespace-cleanup: Disabled.")
        (remove-hook 'before-save-hook #'+save--whitespace-cleanup-h))
    (message "+toggle-auto-whitespace-cleanup: Enabled.")
    (add-hook 'before-save-hook #'+save--whitespace-cleanup-h)))
#+end_src

=what-faces= 查看pos位置font face

#+begin_src emacs-lisp
;; Adapted from: rougier/nano-emacs
;;;###autoload
(defun +what-faces (pos)
  "Get the font faces at POS."
  (interactive "d")
  (let ((faces (remq nil
                     (list
                      (get-char-property pos 'read-face-name)
                      (get-char-property pos 'face)
                      (plist-get (text-properties-at pos) 'face)))))
    (message "Faces: %s" faces)))
#+end_src

=screen-svg= svg截图

#+begin_src emacs-lisp
(defcustom +screenshot-delay 5
  "A delay to wait before taking the screenshot.
Applicable only when calling `+screenshot-svg' with a prefix."
  :group 'minemacs-utils
  :type 'number)

;; Inspired by: reddit.com/r/emacs/comments/idz35e/comment/g2c2c6y
;;;###autoload
(defun +screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring. If launched with a
prefix or universal argument, it waits for a moment (defined by
`+screenshot-delay') before taking the screenshot."
  (interactive)
  (if current-prefix-arg
      (run-with-timer +screenshot-delay nil #'+screenshot-svg--take-screenshot)
    (+screenshot-svg--take-screenshot)))

(defun +screenshot-svg--take-screenshot ()
  (let* ((filename (make-temp-file "emacs-" nil ".svg"))
         (data (x-export-frames nil 'svg)))
    (with-temp-file filename (insert data))
    (kill-new filename)
    (message "Screenshot saved to %s" filename)))
#+end_src

=webjump= 快捷web搜索

#+begin_src emacs-lisp
;;;###autoload
(defun +region-or-thing-at-point ()
  "Return the region or the thing at point."
  (when-let* ((thing (or
                      (prog1 (thing-at-point 'region t)
                        (deactivate-mark))
                      (thing-at-point 'symbol t)
                      (thing-at-point 'email t)
                      (thing-at-point 'number t)
                      (thing-at-point 'string t)
                      (thing-at-point 'word t))))
    (if (length> (string-lines thing) 1)
        ;; If the matching thing has multi-lines, use the first one
        (car (string-lines thing))
      thing)))

(defvar +webjump-read-string-initial-query nil)

(defun +webjump-read-string-with-initial-query (prompt)
  (let ((input (read-string (concat prompt ": ") +webjump-read-string-initial-query)))
    (if (webjump-null-or-blank-string-p input) nil input)))

;;;###autoload
(defun +webjump ()
  "Like `webjump', with initial query filled from `+region-org-thing-at-point'."
  (interactive)
  (require 'webjump)
  (let ((+webjump-read-string-initial-query (+region-or-thing-at-point)))
    (cl-letf (((symbol-function 'webjump-read-string) #'+webjump-read-string-with-initial-query))
      (webjump))))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +emacs.el ends here
#+end_src

** +keybinding.el
=+keybinding.el= 按键相关的扩展

文件头

#+begin_src emacs-lisp
;;; +keybinding.el --- +keybinding -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=general= 和 =evil= 会导致启动缓慢  需要延迟加载 意味着不能一开始就绑定按键 所以需要一些延迟加载宏的辅助

#+begin_src emacs-lisp
;; PERF+HACK: At some point, MinEmacs startup become too slow, specially when
;; initializing `general' and `evil'. After trying several configurations, I
;; figured out that deferring `general' solves the issue. However, deferring
;; `general' means that we cannot define the keybindings when loading other
;; packages, i.e. before `general' gets loaded and the MinEmacs definers (i.e.
;; `+minemacs--internal-map!', `+minemacs--internal-map-local!', ...) are made
;; available. We overcome this by defining these macros to define the
;; keybindings by wrapping the actual definition in a `with-eval-after-load'
;; block to be evaluated only after `general' gets loaded and configured and the
;; definers are ready (See `me-keybindings').
;;;###autoload
(defmacro +map! (&rest args)
  "A wrapper around `+minemacs--internal-map!'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (+minemacs--internal-map! ,@args)))

;;;###autoload
(defmacro +map-local! (&rest args)
  "A wrapper around `+minemacs--internal-map-local!'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (+minemacs--internal-map-local! ,@args)))

;; Wrappers around `general's VIM like definers, needs `general-evil-setup' to
;; be executed (See `me-keybindings')
;;;###autoload
(defmacro +nmap! (&rest args)
  "A wrapper around `general-nmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-nmap ,@args)))

;;;###autoload
(defmacro +vmap! (&rest args)
  "A wrapper around `general-vmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-vmap ,@args)))

;;;###autoload
(defmacro +mmap! (&rest args)
  "A wrapper around `general-mmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-mmap ,@args)))

;;;###autoload
(defmacro +imap! (&rest args)
  "A wrapper around `general-imap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-imap ,@args)))

;;;###autoload
(defmacro +emap! (&rest args)
  "A wrapper around `general-emap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-emap ,@args)))

;;;###autoload
(defmacro +omap! (&rest args)
  "A wrapper around `general-omap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-omap ,@args)))

;;;###autoload
(defmacro +rmap! (&rest args)
  "A wrapper around `general-rmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-rmap ,@args)))

;;;###autoload
(defmacro +iemap! (&rest args)
  "A wrapper around `general-iemap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-iemap ,@args)))

;;;###autoload
(defmacro +nvmap! (&rest args)
  "A wrapper around `general-nvmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-nvmap ,@args)))
#+end_src

文件尾
#+begin_src emacs-lisp
;;; +keybinding.el ends here
#+end_src

** +minemacs.el
=minemacs.el= 一些宏和方法用来简化配置

文件头

#+begin_src emacs-lisp
;;; +minemacs.el --- +keybinding -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

日志相关宏

#+begin_src emacs-lisp
;;;###autoload
(defmacro +error! (msg &rest vars)
  "Log error MSG and VARS using `message'."
  (when (>= minemacs-msg-level 1)
    `(apply #'message (list (concat "[MinEmacs:Error] " ,msg) ,@vars))))

;;;###autoload
(defmacro +info! (msg &rest vars)
  "Log info MSG and VARS using `message'."
  (when (>= minemacs-msg-level 2)
    `(let ((inhibit-message t))
      (apply #'message (list (concat "[MinEmacs:Info] " ,msg) ,@vars)))))

;;;###autoload
(defmacro +log! (msg &rest vars)
  "Log MSG and VARS using `message' when `minemacs-verbose' is non-nil."
  (when (>= minemacs-msg-level 3)
    `(let ((inhibit-message t))
      (apply #'message (list (concat "[MinEmacs:Log] " ,msg) ,@vars)))))

;;;###autoload
(defmacro +debug! (msg &rest vars)
  "Log error MSG and VARS using `message'."
  (when (>= minemacs-msg-level 4)
    `(let ((inhibit-message t))
      (apply #'message (list (concat "[MinEmacs:Debug] " ,msg) ,@vars)))))
#+end_src

=featurep= 检测emacs是否有这个特性

#+begin_src emacs-lisp
;;;###autoload
(defun +emacs-features-p (&rest feats)
  "Is features FEATS are enabled in this Emacs build."
  (cl-every (lambda (feat) (and (memq feat emacs/features) t)) feats))
#+end_src

=inhibit-message= 抑制函数的消息输出

#+begin_src emacs-lisp
;;;###autoload
(defmacro +fn-inhibit-messages! (fn &optional no-message-log)
  "Add an advice around the function FN to suppress messages in echo area.
If NO-MESSAGE-LOG is non-nil, do not print any message to *Messages* buffer."
  (let ((advice-fn (make-symbol (format "+%s--inhibit-messages-a" fn))))
    `(advice-add
      ',fn :around
      (defun ,advice-fn (origfn &rest args)
       (let ((message-log-max (unless ,no-message-log message-log-max)))
        (with-temp-message (or (current-message) "")
         (+log! "Inhibiting messages of %s" ,(symbol-name fn))
         (apply origfn args)))))))

;;;###autoload
(defmacro +shutup! (&rest body)
  "Suppress new messages temporarily in the echo area and the `*Messages*' buffer while BODY is evaluated."
  (if (not minemacs-verbose)
      `(let ((message-log-max nil))
        (with-temp-message (or (current-message) "") ,@body))
    `(progn ,@body)))

;;;###autoload
(defmacro +suppress! (&rest body)
  "Suppress new messages temporarily in the echo area while BODY is evaluated."
  (if (not minemacs-verbose)
      `(with-temp-message (or (current-message) "") ,@body)
    `(progn ,@body)))
#+end_src

=convert to interactive= 把不能交互的函数转为可交互

#+begin_src emacs-lisp
;;;###autoload
(defmacro +cmdfy! (&rest body)
  "Convert BODY to an interactive command."
  `(lambda ()
     (interactive)
     ,@body))
#+end_src

=set-fonts= 通过 =minemacs-fonts= 设置字体

#+begin_src emacs-lisp
;;;###autoload
(defun +set-fonts ()
  "Set Emacs' fonts from `minemacs-fonts'."
  (interactive)
  ;; TODO: use (font-family-list) to check if the font is available
  (custom-set-faces
   `(default
     ((t (:font ,(format "%s %d"
                  (or (plist-get minemacs-fonts :font-family)
                   (plist-get minemacs-default-fonts :font-family))
                  (or (plist-get minemacs-fonts :font-size)
                   (plist-get minemacs-default-fonts :font-size)))))))
   `(fixed-pitch
     ((t (:inherit (default)))))
   `(fixed-pitch-serif
     ((t (:inherit (default)))))
   `(variable-pitch
     ((t (:font ,(format "%s %d"
                  (or (plist-get minemacs-fonts :variable-pitch-font-family)
                   (plist-get minemacs-default-fonts :variable-pitch-font-family))
                  (or (plist-get minemacs-fonts :variable-pitch-font-size)
                   (plist-get minemacs-default-fonts :variable-pitch-font-size))))))))
  ;; Run hooks
  (run-hooks 'minemacs-after-set-fonts-hook))
#+end_src

=load-theme= 载入主题

#+begin_src emacs-lisp
;;;###autoload
(defun +load-theme ()
  "Load Emacs' theme from `minemacs-theme'."
  (interactive)
  (when minemacs-theme
    (+log! "Loading user theme: %s" minemacs-theme)
    ;; Fallback to built-in `tsdh-light' when `minemacs-theme' is not available.
    (unless (ignore-errors (load-theme minemacs-theme t))
      (+error! "Cannot load theme \"%s\", falling back to \"tsdh-light\"." minemacs-theme)
      (load-theme 'tsdh-light t)))
  ;; Run hooks
  (run-hooks 'minemacs-after-load-theme-hook))
#+end_src

=eval-when-idle= 空闲时执行

#+begin_src emacs-lisp
;; An internal variable to keep track of the tasks
(defvar +eval-when-idle--task-num 0)
(defcustom +eval-when-idle-delay 5.0
  "The default delay (in seconds) to consider in `+eval-when-idle!' macro."
  :group 'minemacs-core
  :type 'float)

;;;###autoload
(defun +eval-when-idle (delay &rest fns)
  "Queue FNS to be processed when Emacs becomes idle."
  (let* ((task-num (cl-incf +eval-when-idle--task-num))
         (task-name (make-symbol (format "+eval-when-idle--task-%d" task-num))))
    (with-memoization (get task-name 'timer)
      (run-with-idle-timer
       delay t
       (lambda ()
         (when-let (fn (pop fns))
           (+log! "Running task %d, calling function `%s'" task-num
                  (truncate-string-to-width (format "%s" fn) 40 nil nil "…"))
           (funcall fn))
         (unless fns
           (cancel-timer (get task-name 'timer))
           (put task-name 'timer nil)))))))

;;;###autoload
(defmacro +eval-when-idle! (&rest body)
  "Evaluate BODY when Emacs becomes idle."
  (declare (indent 0))
  `(+eval-when-idle ,+eval-when-idle-delay
    (lambda ()
      ,@body)))

;;;###autoload
(defmacro +eval-when-idle-for! (delay &rest body)
  "Evaluate BODY after DELAY seconds from Emacs becoming idle."
  (declare (indent 1))
  `(+eval-when-idle ,delay
    (lambda ()
      ,@body)))
#+end_src

=deferred=  延迟执行

#+begin_src emacs-lisp
;;;###autoload
(defmacro +deferred! (&rest body)
  "Run BODY after Emacs gets loaded, a.k.a. after `minemacs-loaded'."
  `(with-eval-after-load 'minemacs-loaded
    ,@body))

;;;###autoload
(defmacro +deferred-when! (condition &rest body)
  "Like `+deferred!', with BODY executed only if CONDITION is non-nil."
  (declare (indent 1))
  `(when ,condition (+deferred! ,@body)))

;;;###autoload
(defmacro +deferred-unless! (condition &rest body)
  "Like `+deferred!', with BODY executed only if CONDITION is nil."
  (declare (indent 1))
  `(unless ,condition (+deferred! ,@body)))

;;;###autoload
(defmacro +deferred-or-immediate! (condition &rest body)
  "Like `+deferred!', with BODY deferred if CONDITION is non-nil, otherwise it acts like `progn'."
  (declare (indent 1))
  `(if ,condition (+deferred! ,@body) (progn ,@body)))
#+end_src

=lazy=  惰性加载

#+begin_src emacs-lisp
;;;###autoload
(defmacro +lazy! (&rest body)
  "Run BODY as a lazy block (see `minemacs-lazy')."
  `(with-eval-after-load 'minemacs-lazy
    (+eval-when-idle-for! 1.0
     ,@body)))

;;;###autoload
(defmacro +lazy-when! (condition &rest body)
  "Like `+lazy!', with BODY executed only if CONDITION is non-nil."
  (declare (indent 1))
  `(when ,condition (+lazy! ,@body)))

;;;###autoload
(defmacro +lazy-unless! (condition &rest body)
  "Like `+lazy!', with BODY executed only if CONDITION is nil."
  (declare (indent 1))
  `(unless ,condition (+lazy! ,@body)))

;;;###autoload
(defmacro +lazy-or-immediate! (condition &rest body)
  "Like `+lazy!', with BODY deferred if CONDITION is non nil, otherwise it acts like `progn'."
  (declare (indent 1))
  `(if ,condition (+lazy! ,@body) (progn ,@body)))
#+end_src

=after-load= 当features加载完成后执行

#+begin_src emacs-lisp
;;;###autoload
(defmacro +after-load! (features &rest body)
  "Execute BODY after FEATURES have been loaded."
  (declare (indent 1))
  (let ((features (if (+quoted features) (+unquote features) (eval features))))
    (if (symbolp features)
        `(with-eval-after-load ',features ,@body)
      (let ((feature (car features)))
        (cond
         ((memq feature '(:or :any))
          (macroexp-progn
           (cl-loop
            for next in (cdr features)
            collect `(with-eval-after-load ',(+unquote next) ,@body))))
         ((memq feature '(:and :all))
          (dolist (next (reverse (cdr features)) (car body))
            (setq body `((with-eval-after-load ',(+unquote next) ,@body)))))
         (t `(+after-load! '(:all ,@features) ,@body)))))))
#+end_src

=hook= 延迟hook 和 hook一次

#+begin_src emacs-lisp
;; Adapted from: github.com/d12frosted/environment
;;;###autoload
(defmacro +hook-with-delay! (hook secs function &optional depth local)
  "Add the FUNCTION to the value of HOOK.
The FUNCTION is delayed to be evaluated in SECS once HOOK is
triggered.
DEPTH and LOCAL are passed as is to `add-hook'."
  (let* ((f-name (make-symbol (format "%s-on-%s-delayed-%ds-h" (+unquote function) (+unquote hook) secs)))
         (f-doc (format "Call `%s' in %d seconds" (symbol-name (+unquote function)) secs)))
    `(eval-when-compile
       (defun ,f-name () ,f-doc
        (run-with-idle-timer ,secs nil ,function))
       (add-hook ,hook #',f-name ,depth ,local))))

(defvar +hook-once-num 0)

;;;###autoload
(defmacro +hook-once! (hook &rest body)
  "Hook BODY in HOOK, it runs only once."
  (declare (indent 1))
  (let ((hook (+unquote hook))
        (fn-name (intern (format "+hook-once--function-%d-h" (cl-incf +hook-once-num)))))
    `(add-hook
      ',hook
      (defun ,fn-name ()
       ,(macroexp-progn body)
       (remove-hook ',hook ',fn-name)))))
#+end_src

=complie-function= 函数进行本地编译 如不支持则进行字节编译 并禁止编译过程中的日志输出

#+begin_src emacs-lisp
;; Adapted from: Doom Emacs
;;;###autoload
(defun +compile-functions (&rest fns)
  "Queue FNS to be byte/natively-compiled after a brief delay."
  (dolist (fn fns)
    (+eval-when-idle!
      (or (and (featurep 'native-compile)
               (or (subr-native-elisp-p (indirect-function fn))
                   ;; Do not log to `comp-log-buffer-name'
                   (cl-letf (((symbol-function 'comp-log-to-buffer) #'ignore))
                     (+shutup! (ignore-errors (native-compile fn))))))
          (byte-code-function-p fn)
          (let (byte-compile-warnings)
            (+shutup! (byte-compile fn)))))))
#+end_src

=env load & save= 环境变量的读取和保存

#+begin_src emacs-lisp
;;;###autoload
(defun +env-save ()
  "Load environment variables of the current session to the file
  \".emacs.d/local/system-env.el\"."
  (interactive)
  (with-temp-buffer
    (insert ";; -*- mode: emacs-lisp; no-byte-compile: t; no-native-compile: t; -*-\n\n")
    (dolist (env-var +env-save-vars)
      (when-let ((var-val (getenv env-var)))
        (when (equal "PATH" env-var)
          (insert
           (format
            "\n;; Helper function\n%s\n"
            '(defun +add-to-path (path)
              (unless (member path exec-path)
               (add-to-list 'exec-path path)))))
          (insert "\n;; Adding PATH content to `exec-path'\n")
          (dolist (path (parse-colon-path var-val))
            (when path
              (insert
               (format
                "(+add-to-path \"%s\")\n"
                path path))))
          (insert "\n"))
        (insert
         (format "(setenv \"%s\" \"%s\")\n" env-var var-val))))
    (write-file (concat minemacs-local-dir "system-env.el"))))

;;;###autoload
(defun +env-load ()
  "Load environment variables from the file saved in
  \".emacs.d/local/system-env.el\" if available."
  (interactive)
  (let ((env-file (concat minemacs-local-dir "system-env.el")))
    (when (file-exists-p env-file)
      (+load env-file))))
#+end_src

=ignore-root=  recentf 排除目录

#+begin_src emacs-lisp
;;;###autoload
(defun +ignore-root (&rest roots)
  "Add ROOTS to ignored projects, recentf, etc."
  (dolist (root roots)
    (with-eval-after-load 'recentf
      (add-to-list 'recentf-exclude root))))
#+end_src

=minemacs= 更新更新相关

#+begin_src emacs-lisp
(defvar minemacs--build-functions nil
  "These functions are run after completing package updates.")

;;;###autoload
(defmacro +register-build-function! (fn)
  "Register build function FN to be called at the end of `minemacs-update'."
  `(add-to-list 'minemacs--build-functions #',fn))

;;;###autoload
(defun minemacs-update ()
  "Update MinEmacs packages."
  (interactive)
  ;; Backup the current installed versions, this file can be restored if version
  ;; upgrade does break some packages.
  (message "[MinEmacs]: Creating backups for the current versions of packages")
  (let* ((backup-dir (concat minemacs-local-dir "minemacs/versions/"))
         (dest-file (concat backup-dir (format-time-string "default-%Y%m%d%H%M%S.el")))
         (src-file (concat straight-base-dir "straight/versions/default.el")))
    (unless (file-directory-p backup-dir) (mkdir backup-dir 'parents))
    (when (file-exists-p src-file)
      (message "[MinEmacs]: Creating backup from \"%s\" to \"%s\"" src-file dest-file)
      (copy-file src-file dest-file)))

  ;; Run `straight's update cycle, taking into account the explicitly pinned
  ;; packages versions.
  (message "[MinEmacs]: Pulling packages")
  (straight-x-pull-all)
  (message "[MinEmacs]: Freezing packages")
  (straight-x-freeze-versions)
  (message "[MinEmacs]: Rebuilding packages")
  (straight-rebuild-all)

  ;; Runn package-specific build functions (ex: `pdf-tools-install-noverify')
  (message "[MinEmacs]: Running additional package-specific build functions")
  (dolist (fn minemacs--build-functions)
    (message "MinEmacs: Running `%s'" fn)
    ;; Do not ask before installing
    (cl-letf (((symbol-function 'yes-or-no-p) #'always)
              ((symbol-function 'y-or-n-p) #'always))
      (funcall-interactively fn))))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +minemacs.el ends here
#+end_src

** netextender.el
:properties:
:header-args: :tangle no
:end:
=netextender.el= 程序netextender的封装
UNUSED: 暂时用不到

文件头

#+begin_src emacs-lisp
;;; netextender.el --- +keybinding -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=netextender=

#+begin_src emacs-lisp
(defvar netextender-process-name "netextender")
(defvar netextender-buffer-name " *NetExtender*")

(defgroup minemacs-netextender nil
  "MinEmacs NetExtender."
  :group 'minemacs)

(defcustom netextender-passphrase-file "~/.ssh/sslvpn.gpg"
  "GPG encrypted NetExtender connection parameters."
  :group 'minemacs-netextender
  :type 'file)

(defcustom netextender-command '("~/.local/bin/netextender")
  "Custom NetExtender launcher."
  :group 'minemacs-netextender
  :type '(choice string file))

;; If the command doesn't exist, generate it.
(unless (file-exists-p (car netextender-command))
  (setq netextender-command (cons (make-temp-file "netextender") (cdr netextender-command)))
  (set-file-modes (car netextender-command) #o755) ;; Make it executable
  (with-temp-buffer
    (insert
     (format "#!/bin/bash

if ! command -v netExtender &> /dev/null; then
  echo \"netExtender not found, installing from AUR using 'yay'\"
  yay -S netextender
fi

MY_LOGIN_PARAMS_FILE=\"%s\"

echo \"Y\\n\" | netExtender --auto-reconnect $(gpg -q --for-your-eyes-only --no-tty -d \"${MY_LOGIN_PARAMS_FILE}\")"
             (expand-file-name netextender-passphrase-file)))
    (write-file (car netextender-command))))

(defun netextender-check-system ()
  "Return non-nil if system setup is OK."
  (let* ((pppd-command "/usr/sbin/pppd")
         (pppd-modes (file-modes pppd-command)))
    ;; pppd must be run as root (via setuid)
    (if (and pppd-modes (zerop (logand (lsh 1 11) pppd-modes))) ;; Check if the setuid bit isn't set
        (prog1 nil ;; return nil
          (message "pppd needs root permissions, please set the setuid bit of %s." pppd-command))
      t)))

;;;###autoload
(defun netextender-start ()
  "Launch a NetExtender VPN session."
  (interactive)
  (if (netextender-check-system)
      (unless (get-process netextender-process-name)
        (if (make-process :name netextender-process-name
                          :buffer netextender-buffer-name
                          :command netextender-command)
            (message "Started NetExtender VPN session.")
          (user-error "Cannot start NetExtender.")))
    (user-error "Cannot start a netExtender VPN session.")))

(defun netextender-kill ()
  "Kill the created NetExtender VPN session."
  (interactive)
  (let ((netextender-process (get-process netextender-process-name)))
    (if netextender-process
        (if (kill-process netextender-process)
            (message "Killed NetExtender VPN session.")
          (user-error "Cannot kill NetExtender."))
      (message "No running NetExtender session."))))

;;;###autoload
(defun netextender-toggle ()
  "Toggle connection to NetExtender."
  (interactive)
  (if (get-process netextender-process-name)
      (netextender-kill)
    (netextender-start)))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; netextender.el ends here
#+end_src

** +project.el
=+project.el= 内置project的扩展

文件头

#+begin_src emacs-lisp
;;; +project.el --- project -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

自动扫描目录添加项目

#+begin_src emacs-lisp
(defgroup minemacs-project nil
  "MinEmacs project stuff."
  :group 'minemacs)

(defcustom +project-scan-dir-paths nil
  "A list of paths to scan and add to known projects list.
It can be a list of strings (paths) or a list of (cons \"~/path/to/projects\" recursive?)
to scan directories recursively."
  :group 'minemacs-project
  :type '(repeat (choice directory (cons directory boolean))))

;;;###autoload
(defun +project-scan-for-projects ()
  "Scan and remember projects under `+project-scan-dir-paths'."
  (interactive)
  (dolist (cons-dir +project-scan-dir-paths)
    (let* ((cons-dir (ensure-list cons-dir))
           (root-dir (car cons-dir))
           (recursive (cdr cons-dir))
           (sub-dirs (+directory-subdirs root-dir)))
      (dolist (dir sub-dirs)
        (project-remember-projects-under dir recursive)))))

;;;###autoload
(defun +project-add-project (dir &optional dont-ask)
  "Switch to another project at DIR.
When DIR is not detected as a project, ask to force it to be by adding a
\".project.el\" file."
  (interactive (list (project-prompt-project-dir)))
  (project-switch-project dir)
  (when (and (not (project-current))
             (or dont-ask
                 (yes-or-no-p "Directory not detected as a project, add \".project.el\"? ")))
    (with-temp-buffer
      (write-file (expand-file-name ".project.el" dir)))))

;;;###autoload
(defun +project-gdb ()
  "Invoke `gdb' in the project's root."
  (interactive)
  (let ((default-directory (project-root (project-current t))))
    (call-interactively #'gdb)))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +project.el ends here
#+end_src

** +primitives.el
=+primitives.el= 一些上古方法

文件头

#+begin_src emacs-lisp
;;; +primitives.el --- primitives -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=plist= & =alist= miss fuction

#+begin_src emacs-lisp
;;; === Some plist and alist missing functions ===

;;;###autoload
(defun +plist-keys (plist)
  "Return the keys of PLIST."
  (let (keys)
    (while plist
      (push (car plist) keys)
      (setq plist (cddr plist)))
    keys))

;;;###autoload
(defmacro +plist-push! (plist &rest key-vals)
  "Push KEY-VALS to PLIST."
  (declare (indent 1))
  (let ((out (list 'progn)))
    (while (length> key-vals 0)
      (let ((key (pop key-vals))
            (val (pop key-vals)))
        (add-to-list
         'out
         `(setq ,plist (plist-put ,plist ,key ,val)) t)))
    out))

;;;###autoload
(defun +plist-combine (&rest plists)
  "Create a single property list from all plists in PLISTS.
Modified from `org-combine-plists'. This supposes the values to be vectors,
and concatenate them."
  (let ((res (copy-sequence (pop plists)))
        prop val plist)
    (while plists
      (setq plist (pop plists))
      (while plist
        (setq prop (pop plist) val (pop plist))
        (setq res (plist-put res prop (vconcat val (plist-get res prop))))))
    res))

;;;###autoload
(defun +plist-delete (plist prop)
  "Delete property PROP from PLIST.
Adapted from `org-plist-delete'."
  (let (p)
    (while plist
      (if (not (eq prop (car plist)))
          (setq p (plist-put p (car plist) (nth 1 plist))))
      (setq plist (cddr plist)))
    p))

;;;###autoload
(defun +plist-to-alist (plist &optional trim-col)
  (let ((res '()))
    (while plist
      (let* ((key (pop plist))
             (val (pop plist))
             (key (if (and trim-col (string-prefix-p ":" (symbol-name key)))
                      (intern (substring (symbol-name key) 1))
                    key)))
        (push (cons key val) res)))
    (nreverse res)))

;;;###autoload
(defun +alist-to-plist (alist &optional add-col)
  (let ((res '()))
    (dolist (x alist)
      (push (if add-col (intern (format ":%s" (car x))) (car x)) res)
      (push (cdr x) res))
    (nreverse res)))

;;;###autoload
(defun +alist-set (key val alist &optional symbol)
  "Set property KEY to VAL in ALIST. Return new alist.
This creates the association if it is missing, and otherwise sets
the cdr of the first matching association in the list. It does
not create duplicate associations. By default, key comparison is
done with `equal'. However, if SYMBOL is non-nil, then `eq' is
used instead.

This method may mutate the original alist, but you still need to
use the return value of this method instead of the original
alist, to ensure correct results."
  ;; Implementation taken from `straight--alist-set'
  ;; See [1] for the genesis of this method, which should really be
  ;; built in.
  ;;
  ;; [1]: emacs.stackexchange.com/q/33892/12534
  (if-let ((pair (if symbol (assq key alist) (assoc key alist))))
      (setcdr pair val)
    (push (cons key val) alist))
  alist)
#+end_src

函数 =+serialize-sym= 的作用是将一个符号序列化为文件，并保存到指定的目录中。
它通过参数来控制文件名的格式和保存的目录，并在序列化过程中输出相应的日志信息。

#+begin_src emacs-lisp
;;; === Serialization ===

(defcustom +serialized-symbols-directory (concat minemacs-local-dir "+serialized-symbols/")
  "Default directory to store serialized symbols."
  :group 'minemacs-core
  :type 'directory)

;;;###autoload
(defun +serialize-sym (sym &optional dir filename-format)
  "Serialize SYM to DIR.
If FILENAME-FORMAT is non-nil, use it to format the file name (ex. \"file-%s.el\").
Return the written file name, or nil if SYM is not bound."
  (when (boundp sym)
    (let ((out-file (expand-file-name
                     (format (or filename-format "%s.el") (symbol-name sym))
                     (or dir +serialized-symbols-directory))))
      (+log! "Saving `%s' to file \"%s\"" (symbol-name sym) (abbreviate-file-name out-file))
      (with-temp-buffer
        (prin1 (eval sym) (current-buffer))
        (+shutup! (write-file out-file)))
      out-file)))

;;;###autoload
(defun +deserialize-sym (sym &optional dir mutate filename-format)
  "Deserialize SYM from DIR, if MUTATE is non-nil, assign the object to SYM.
If FILENAME-FORMAT is non-nil, use it to format the file name (ex. \"file-%s.el\").
Return the deserialized object, or nil if the SYM.el file dont exist."
  (let ((in-file (expand-file-name
                  (format (or filename-format "%s.el") (symbol-name sym))
                  (or dir +serialized-symbols-directory)))
        res)
    (when (file-exists-p in-file)
      (+log! "Loading `%s' from file \"%s\"" sym (abbreviate-file-name in-file))
      (with-temp-buffer
        (insert-file-contents in-file)
        (goto-char (point-min))
        (ignore-errors (setq res (read (current-buffer)))))
      (when mutate (set sym res)))
    res))
#+end_src

=misc= 一些小方法

#+begin_src emacs-lisp
;;; === Misc ===

;; See: emacs.stackexchange.com/q/3022/37002
;;;###autoload
(defun +reset-sym (sym)
  "Reset SYM to its standard value."
  (set sym (eval (car (get sym 'standard-value)))))

;;;###autoload
(defmacro +reset-var! (var)
  "Reset VAR to its standard value."
  `(setq ,var (eval (car (get ',var 'standard-value)))))

;; Adapted from `evil-unquote', takes functions into account
;;;###autoload
(defun +unquote (expr)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe expr) '(quote function))
    (setq expr (cadr expr)))
  expr)

;;;###autoload
(defun +quoted (expr)
  "Retrun t when EXP is quoted."
  (memq (car-safe expr) '(quote function)))

;;;###autoload
(defun +apply-partially-right (fun &rest args)
  "Like `apply-partially', but applies the ARGS to the right of FUN."
  (lambda (&rest args2)
    (apply fun (append args2 args))))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +primitives.el ends here
#+end_src

** +systemd.el
=+systemd.el= 启动 关闭 检查 服务状态 --user

文件头

#+begin_src emacs-lisp
;;; +systemd.el --- systemd wrapper -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=systemd wrapper=

#+begin_src emacs-lisp
;;;###autoload
(defun +systemd-running-p (service)
  "Check if the systemd SERVICE is running."
  (zerop (call-process "systemctl" nil nil nil "--user" "is-active" "--quiet" service ".service")))

;;;###autoload
(defun +systemd-command (service command &optional pre-fn post-fn)
  "Call systemd with COMMAND and SERVICE."
  (when pre-fn (funcall pre-fn))
  (let ((success (zerop (call-process "systemctl" nil nil nil "--user" command service ".service"))))
    (unless success
      (user-error "[systemd]: Failed on calling '%s' on service %s.service." command service))
    (when post-fn (funcall post-fn success))
    success))

;;;###autoload
(defun +systemd-start (service &optional pre-fn post-fn)
  "Start systemd SERVICE."
  (+systemd-command service "start" pre-fn post-fn))

;;;###autoload
(defun +systemd-stop (service &optional pre-fn post-fn)
  "Stops the systemd SERVICE."
  (+systemd-command service "stop" pre-fn post-fn))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +systemd.el ends here
#+end_src

** +unix.el
=+unix.el=  unix一些命令的包装

文件头

#+begin_src emacs-lisp
;;; +unix.el --- unix cmd wrapper -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=unix cmd wrapper=
函数 +read-shell-file-command 的作用是提示用户输入一个 shell 命令，并使用当前缓冲区的文件名作为默认参数。
它通过获取文件名和命令，将它们合并为一个字符串，并在迷你缓冲区中显示，让用户进行输入。

#+begin_src emacs-lisp
;; From: emacswiki.org/emacs/download/misc-cmds.el
(defun +read-shell-file-command (command)
  "Prompt for shell COMMAND, using current buffer's file as default arg.
If buffer is not associated with a file, you are prompted for a file.
COMMAND is a symbol."
  (let ((file (or (buffer-file-name) (read-file-name "File: "))))
    (setq file (and file (file-name-nondirectory file))
          command (format "%s  " command)) ; Convert to string.
    (read-from-minibuffer
     "" (cons (concat command (and file  (concat " " file))) (length command)))))

;;;###autoload
(defun +chmod-this-file (cmd)
  "Execute Unix command `chmod'.  Current buffer's file is default arg.
CMD is the command to execute (interactively, `chmod')."
  (interactive (list (+read-shell-file-command 'chmod)))
  (shell-command cmd))

;;;###autoload
(defun +chgrp-this-file (cmd)
  "Execute Unix command `chgrp'.  Current buffer's file is default arg.
CMD is the command to execute (interactively, `chgrp')."
  (interactive (list (+read-shell-file-command 'chgrp)))
  (shell-command cmd))

;;;###autoload
(defun +chown-this-file (cmd)
  "Execute Unix command `chown'.  Current buffer's file is default arg.
CMD is the command to execute (interactively, `chown')."
  (interactive (list (+read-shell-file-command 'chown)))
  (shell-command cmd))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; +unix.el ends here
#+end_src

** valgrind.el
=valgrind.el= 程序 =valgrind= 的包装

文件头

#+begin_src emacs-lisp
;;; valgrind.el --- valgrind wrapper -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=valgrind wrapper=

#+begin_src emacs-lisp
(require 'compile)

(defgroup valgrind nil
  "Run valgrind as inferior of Emacs, parse error messages."
  :group 'tools
  :group 'processes)

(defcustom valgrind-command "valgrind --leak-check=full "
  "*Last shell command used to run valgrind; default for next valgrind run.
Sometimes it is useful for files to supply local values for this variable.
You might also use mode hooks to specify it in certain modes, like this:
  (add-hook 'c-mode-hook
    (lambda ()
      (unless (or (file-exists-p \"makefile\")
                  (file-exists-p \"Makefile\"))
        (set (make-local-variable 'valgrind-command)
             (concat \"make -k \"
                     (file-name-sans-extension buffer-file-name))))))"
  :type 'string
  :group 'valgrind)

;; History of compile commands.
(defvar valgrind-history nil)

;; Integration with `savehist'
(with-eval-after-load 'savehist
  (add-to-list 'savehist-additional-variables 'valgrind-history))

;;;###autoload
(defun valgrind (command)
  "Run valgrind.
Runs COMMAND, a shell command, in a separate process asynchronously
with output going to the buffer `*valgrind*'.
You can then use the command \\[next-error] to find the next error message
and move to the source code that caused it."
  (interactive
   (if (or compilation-read-command current-prefix-arg)
       (list (read-from-minibuffer "Valgrind command: "
                                   (eval valgrind-command) nil nil
                                   '(valgrind-history . 1)))
     (list (eval valgrind-command))))
  (let ((default-directory (or (project-root (project-current)) default-directory)))
    (unless (equal command (eval valgrind-command))
      (setq valgrind-command command))
    (compilation-start command nil (lambda (mode) "*valgrind*"))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'valgrind)
;;; valgrind.el ends here
#+end_src

* modules/
:properties:
:path:     ~/.emacs.d/modules/
:end:
=modules= 目录下是各个模块
** [✘] me-biblio.el
:properties:
:header-args: :tangle no
:end:
=me-biblio.el= bibliography 用来做文献引用
UNUSED: 暂时用不到

文件头

#+begin_src emacs-lisp
;;; me-biblio.el --- bibliography -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=oc=
#+begin_src emacs-lisp
(use-package oc
  :straight (:type built-in)
  :after org
  :demand t
  :custom
  (org-cite-export-processors '((latex biblatex) (t csl)))
  (org-support-shift-select t)
  :config
  (+map-local! :keymaps 'org-mode-map
    "C" #'org-cite-insert))

(use-package oc-csl
  :straight (:type built-in)
  :after oc
  :demand t)

(use-package oc-natbib
  :straight (:type built-in)
  :after oc
  :demand t)

(use-package oc-biblatex
  :straight (:type built-in)
  :after oc
  :demand t)
#+end_src

=zotxt=

#+begin_src emacs-lisp
(use-package zotxt
  :straight t
  :preface
  (defconst +zotero-available-p (executable-find "zotero"))
  :when +zotero-available-p
  :init
  (+map-local! :keymaps 'org-mode-map
    "z" #'org-zotxt-mode)
  (+map-local! :keymaps 'markdown-mode-map
    "z" #'zotxt-citekey-mode))
#+end_src

=citar=
#+begin_src emacs-lisp
(use-package citar
  :straight t
  :after oc
  :demand t
  :custom
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  (citar-symbol-separator "  ")
  :config
  (with-eval-after-load 'all-the-icons
    (defun +citar--set-symbols ()
      (setq citar-symbols
            `((file ,(nerd-icons-codicon "nf-cod-file_pdf" :face 'error) . " ")
              (note ,(nerd-icons-faicon "nf-fa-file_text" :face 'warning) . " ")
              (link ,(nerd-icons-mdicon "nf-md-link" :face 'org-link) . " "))))

    ;; Properly setup citar-symbols
    (if (display-graphic-p)
        (+citar--set-symbols)
      (add-hook
       'server-after-make-frame-hook
       (defun +citar--set-symbols-once-h ()
         (when (display-graphic-p)
           (+citar--set-symbols)
           (remove-hook 'server-after-make-frame-hook
                        #'+citar--set-symbols-once-h)))))))
(use-package citar-org-roam
  :straight t
  :after citar org-roam
  :demand t
  :commands +org-roam-node-from-cite
  :config
  ;; Modified form: jethrokuan.github.io/org-roam-guide/
  (defun +org-roam-node-from-cite (entry-key)
    (interactive (list (citar-select-ref)))
    (let ((title (citar-format--entry
                  "${author editor} (${date urldate}) :: ${title}"
                  (citar-get-entry entry-key))))
      (org-roam-capture- :templates
                         `(("r" "reference" plain
                            "%?"
                            :if-new (file+head "references/${citekey}.org"
                                     ,(concat
                                       ":properties:\n"
                                       ":roam_refs: [cite:@${citekey}]\n"
                                       ":end:\n"
                                       "#+title: ${title}\n"))
                            :immediate-finish t
                            :unnarrowed t))
                         :info (list :citekey entry-key)
                         :node (org-roam-node-create :title title)
                         :props '(:finalize find-file))))
  (citar-org-roam-mode 1))

(use-package citar-embark
  :straight t
  :after citar embark
  :demand t
  :config
  (citar-embark-mode 1))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-biblio)
;;; me-biblio.el ends here
#+end_src

** [✘] me-binary.el
:properties:
:header-args: :tangle no
:end:
=me-binary.el= 二进制一些信息的查看

文件头

#+begin_src emacs-lisp
;;; me-binary.el --- stuff to work with binary files -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

加载 =+binary-setup-modes=

#+begin_src emacs-lisp
;; +binary-* are autoloaded
(+deferred!
 ;; BUG: Loading continuously on `dirvish'.
 ;; BUG: Showing up randomly on `tramp' files.
 (setq +binary-objdump-enable nil)
 (+binary-setup-modes))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-binary)
;;; me-binary.el ends here
#+end_src

** me-checkers.el
=me-checkers.el= 实时检查和显示源代码中的语法错误

文件头

#+begin_src emacs-lisp
;;; me-checkers.el --- syntax checking -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=flymake=

#+begin_src emacs-lisp
(use-package flymake
  :straight (:type built-in)
  :init
  (+map! "tf" #'flymake-mode)
  :custom
  (flymake-fringe-indicator-position 'right-fringe)
  :config
  (+map-local! :keymaps 'flymake-mode-map
    "f"  '(nil :wk "flymake")
    "fn" #'flymake-goto-next-error
    "fN" #'flymake-goto-prev-error
    "fs" #'flymake-start
    "fb" #'flymake-show-buffer-diagnostics
    "fp" #'flymake-show-project-diagnostics)

  ;; Use the session's load-path with flymake
  (setq elisp-flymake-byte-compile-load-path load-path)
  ;; Larger right frings
  (set-fringe-style '(8 . 13))

  ;; Better fringe bitmaps
  (when (fboundp 'define-fringe-bitmap)
    (define-fringe-bitmap '+flymake-bitmap-arrow
      [#b11111000
       #b01111100
       #b00111110
       #b00011111
       #b00111110
       #b01111100
       #b11111000])

    (define-fringe-bitmap '+flymake-bitmap-arrow-hi-res
      [#b01111000000
       #b00111100000
       #b00011110000
       #b00001111000
       #b00000111100
       #b00000011110
       #b00000011110
       #b00000111100
       #b00001111000
       #b00011110000
       #b00111100000
       #b01111000000]
      nil 13)

    (define-fringe-bitmap '+flymake-bitmap-left-arrow-hi-res
      [#b00000011110
       #b00000111100
       #b00001111000
       #b00011110000
       #b00111100000
       #b01111000000
       #b01111000000
       #b00111100000
       #b00011110000
       #b00001111000
       #b00000111100
       #b00000011110]
      nil 13)

    (setq flymake-error-bitmap '(+flymake-bitmap-left-arrow-hi-res compilation-error)
          flymake-warning-bitmap '(+flymake-bitmap-left-arrow-hi-res compilation-warning)
          flymake-note-bitmap '(+flymake-bitmap-left-arrow-hi-res compilation-info))))

;;   (defhydra +flycheck-main (:color blue :hint nil :foreign-keys warn)
;;     "
;; [Flymake]                                              [_q_] quit
;;   ├──────────────────────────────────────────────────────────────────────╮
;;   │  [_B_] Buffer diagnostics  [_P_] Project diagnostics  [_L_] Log buffer     │
;;   │  [_n_] Next error          [_N_] Prev error           [_S_] Start          │
;;   ╰──────────────────────────────────────────────────────────────────────╯
;; "
;;     ("B" flymake-show-buffer-diagnostics)
;;     ("P" flymake-show-project-diagnostics)
;;     ("L" flymake-switch-to-log-buffer)
;;     ("n" flymake-goto-next-error)
;;     ("N" flymake-goto-prev-error)
;;     ("S" flymake-start)
;;     ("q" nil :color blue)))

(use-package flymake-easy
  :straight t)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-checkers)
;;; me-checkers.el ends here
#+end_src

** me-daemon.el
=me-daemon.el= 后台运行

文件头

#+begin_src emacs-lisp
;;; me-daemon.el --- daemon -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=email (mu4e)=

#+begin_src emacs-lisp
;; Email (mu4e)
(+lazy-when! (memq 'me-email minemacs-modules)
  (when (require 'mu4e nil t)
    (unless (mu4e-running-p)
      (+info! "Starting `mu4e' in background.")
      (let ((inhibit-message t))
        (mu4e t)))))
#+end_src

=rss (elfeed)=

#+begin_src emacs-lisp
;; RSS (elfeed)
(+lazy-when! (memq 'me-rss minemacs-modules)
  (run-at-time
   (* 60 5) ;; 5min
   (* 60 60) ;; 1h
   (lambda ()
     (+info! "Updating RSS feed.")
     (let ((inhibit-message t))
       (elfeed-update)))))
#+end_src

=emacs server=

#+begin_src emacs-lisp
;; When we start in a non-daemon Emacs, we start a server whe Emacs is idle.
(+lazy-unless! (daemonp)
  (require 'server) ; For using `server-running-p'
  (unless (server-running-p)
    (let ((inhibit-message t))
      (+info! "Starting Emacs daemon in background.")
      (server-start nil t))))

;; Reload theme when creating a frame on the daemon
(add-hook
 'server-after-make-frame-hook
 (defun +daemon--reload-theme-h ()
   (load-theme minemacs-theme t)))

(+hook-once! server-after-make-frame-hook
  (when (and (display-graphic-p)
             (bound-and-true-p display-battery-mode))
    (display-battery-mode -1)
    (display-battery-mode 1)))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-daemon)
;;; me-daemon.el ends here
#+end_src

** me-data.el
=me-data.el= 一些配置文件相关包(csv, yaml, xml, graphviz, ...)

文件头

#+begin_src emacs-lisp
;;; me-data.el --- Data and visualizaion formats (csv, yaml, xml, graphviz, ...) -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=csv-mode=

#+begin_src emacs-lisp
(use-package csv-mode
  :straight t
  :mode "\\.csv\\'"
  :config
  (+map-local! :keymaps 'csv-mode-map
    "r" #'+csv-rainbow
    "a" #'csv-align-fields
    "u" #'csv-unalign-fields
    "s" #'csv-sort-fields
    "S" #'csv-sort-numeric-fields
    "k" #'csv-kill-fields
    "t" #'csv-transpose)

  ;; Adapted from: reddit.com/r/emacs/comments/26c71k/comment/chq2r8m
  (defun +csv-rainbow (&optional separator)
    "Colorize CSV columns."
    (interactive (list (when current-prefix-arg (read-char "Separator: "))))
    (require 'color)
    (font-lock-mode 1)
    (let* ((separator (or separator ?\,))
           (n (count-matches (string separator) (point-at-bol) (point-at-eol)))
           (colors (cl-loop for i from 0 to 1.0 by (/ 2.0 n)
                            collect (apply #'color-rgb-to-hex
                                           (color-hsl-to-rgb i 0.3 0.5)))))
      (cl-loop for i from 2 to (1+ n) by 2
               for c in colors
               for r = (format "^\\([^%c\n]*[%c\n]\\)\\{%d\\}" separator separator i)
               do (font-lock-add-keywords nil `((,r (1 '(face (:foreground ,c))))))))))
#+end_src

=yaml-mode=

#+begin_src emacs-lisp
(use-package yaml-mode
  :straight t
  :mode "Procfile\\'")

(use-package yaml-pro
  :straight t
  :hook (yaml-mode . yaml-pro-mode)
  :hook (yaml-ts-mode . yaml-pro-ts-mode))
#+end_src

=toml-mode=

#+begin_src emacs-lisp
(use-package toml-mode
  :straight t
  :mode "\\.toml\\'")
#+end_src

=json-mode=

#+begin_src emacs-lisp
(use-package json-mode
  :straight t
  :mode "\\.js\\(?:on\\|[hl]int\\(?:rc\\)?\\)\\'"
  :config
  (+map-local! :keymaps 'json-mode-map
    "p" #'json-mode-show-path
    "t" #'json-toggle-boolean
    "d" #'json-mode-kill-path
    "x" #'json-nullify-sexp
    "+" #'json-increment-number-at-point
    "-" #'json-decrement-number-at-point
    "f" #'json-mode-beautify))
#+end_src

=graphviz-dot-mode=
暂时不用

#+begin_src emacs-lisp :tangle no
;; (use-package graphviz-dot-mode
;;   :straight (graphviz-dot-mode :files ("graphviz-dot-mode.el" "texinfo"))
;;   :custom
;;   (graphviz-dot-view-command "xdot %s")
;;   (graphviz-dot-preview-extension "svg")
;;   :config
;;   (+map-local! :keymaps 'graphviz-dot-mode-map
;;     "p" #'graphviz-dot-preview
;;     "P" #'graphviz-dot-view
;;     "l" #'graphviz-turn-on-live-preview
;;     "L" #'graphviz-turn-off-live-preview)
;;   (+eglot-register 'graphviz-dot-mode '("dot-language-server" "--stdio")))
#+end_src

=nxml=

#+begin_src emacs-lisp
(use-package nxml-mode
  :straight (:type built-in)
  :config
  (+eglot-register '(nxml-mode xml-mode) "lemminx"))
#+end_src

=plantuml-mode= 是一个用于在 Emacs 编辑器中编辑和预览 PlantUML 图表的插件. PlantUML 是一种使用简单文本描述创建UML图表的工具. 主要用来画uml类图

#+begin_src emacs-lisp
(use-package plantuml-mode
  :straight t
  :mode "\\.plantuml\\'"
  :hook (plantuml-mode . +plantuml-mode-setup)
  :custom
  (plantuml-jar-path (concat minemacs-local-dir "plantuml/plantuml.jar"))
  (plantuml-indent-level 2)
  :config
  (setq
   plantuml-default-exec-mode
   (cond
    ;; Prefer the system's executable when available
    ((executable-find plantuml-executable-path) 'executable)
    ;; Then, use the JAR if it exists or try to download it
    ((let ((ret (or (file-exists-p plantuml-jar-path)
                    (and (not noninteractive) (ignore-errors (plantuml-download-jar))))))
       (or (eq ret t) (and (stringp ret) (not (string-equal ret "Aborted.")))))
     'jar)
    ;; Fall back to the server configured at `plantuml-server-url'
    'server))

  ;; Define `capf' function, based on `plantuml-complete-symbol'
  (defun +plantuml-completion-at-point ()
    "Perform symbol-at-pt completion on word before cursor."
    (when (derived-mode-p 'plantuml-mode) ; do not fire up on other modes
      (let* ((end-pos (point))
             (sym-at-pt (or (thing-at-point 'symbol) ""))
             (max-match (try-completion sym-at-pt plantuml-kwdList)))
        (unless (null max-match)
          (list (- end-pos (length sym-at-pt))
                end-pos
                (if (eq max-match t)
                    (list keyword)
                  (all-completions sym-at-pt plantuml-kwdList)))))))

  ;; Add support for `capf'
  (defun +plantuml-mode-setup ()
    (add-to-list 'completion-at-point-functions #'+plantuml-completion-at-point))

  (+map-local! :keymaps 'plantuml-mode-map
    "p" #'plantuml-preview-buffer
    "P" #'plantuml-preview
    "d" `(,(+cmdfy!
            (if plantuml-mode-debug-enabled
                (plantuml-disable-debug)
              (plantuml-enable-debug)))
          :wk "Toggle debug")))
#+end_src

=mermaid-mode= 是一个用于在 Emacs 编辑器中编辑和预览 Mermaid 图表的插件。Mermaid 是一种用简单文本描述创建流程图、时序图、甘特图等各种图表的工具. 主要用来画简单图标

#+begin_src emacs-lisp
(use-package mermaid-mode
  :straight t
  :config
  (+map-local! :keymaps 'mermaid-mode-map
    "c" 'mermaid-compile
    "f" 'mermaid-compile-file
    "b" 'mermaid-compile-buffer
    "r" 'mermaid-compile-region
    "b" 'mermaid-open-browser
    "d" 'mermaid-open-doc))

(use-package ob-mermaid
  :straight (:host github :repo "arnm/ob-mermaid")
  :after ob
  :demand t
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages '((mermaid . t)))))
#+end_src

=d2-mode= 暂时不用

#+begin_src emacs-lisp :tangle no
(use-package d2-mode
  :straight t
  :mode "\\.d2\\'"
  :config
  (+map-local! :keymaps 'd2-mode-map
    "cc" #'d2-compile
    "cf" #'d2-compile-file
    "cb" #'d2-compile-buffer
    "cr" #'d2-compile-region
    "cF" #'d2-compile-file-and-browse
    "cB" #'d2-compile-buffer-and-browse
    "cR" #'d2-compile-region-and-browse
    "o"  #'d2-open-browser
    "v"  #'d2-view-current-svg
    "h"  #'d2-open-doc))

(use-package ob-d2
  :straight t
  :after ob
  :demand t
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages '((d2 . t)))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-data)
;;; me-data.el ends here
#+end_src

** me-debug.el
=me-debug.el= 调试器相关 gdb gud

文件头

#+begin_src emacs-lisp
;;; me-debug.el --- debugging stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=gdb-mi= 提供了一个与 GDB 交互的界面。使用 gdb-mi，您可以在 Emacs 中设置断点、运行程序、查看调试信息等。

#+begin_src emacs-lisp
(use-package gdb-mi
  :straight (:type built-in)
  :custom
  (gdb-show-main t) ; display source file containing main routine at startup
  (gdb-many-windows t) ; start in gdb-many-windows mode
  (gdb-debug-log-max 1024) ; default 128
  (gdb-restore-window-configuration-after-quit t)
  (gdb-thread-buffer-verbose-names nil)
  (gdb-window-configuration-directory (+directory-ensure minemacs-local-dir "gdb/"))
  (gdb-max-source-window-count 1) ; IDEA: maybe increase it!
  (gdb-display-io-nopopup nil) ; IDEA: maybe change it!
  :config
  ;; Add an overlay for the current line (mimics dap-mode)
  (defvar +gud-overlay
    (let* ((overlay (make-overlay (point-min) (point-min))))
      (overlay-put overlay 'face 'highlight)
      overlay)
    "Overlay variable for GUD highlighting.")

  (advice-add
   'gud-display-line :after
   (defun +gud--display-overlay-a (true-file _line)
     (let* ((overlay +gud-overlay)
            (buffer (gud-find-file true-file)))
       (with-current-buffer buffer
         (move-overlay overlay (line-beginning-position) (line-end-position) (current-buffer))))))

  (add-hook
   'kill-buffer-hook
   (defun +gud--delete-overlay-h ()
     (when (derived-mode-p 'gud-mode)
       (delete-overlay +gud-overlay)))))
#+end_src

=realgud= 提供了一套集成的调试器前端，用于与多种调试器进行交互.支持多种调试器，包括 GNU GDB、Python 的 pdb、Ruby 的 byebug、JavaScript 的 Node.js 调试器等。它提供了一组命令和快捷键，使您能够设置断点、单步执行、查看变量和堆栈信息等.

#+begin_src emacs-lisp
(use-package realgud
  :straight t
  :init
  (+map-local! :keymaps '(c-mode-map c++-mode-map python-mode-map
                          c-ts-mode-map c++-ts-mode-map python-ts-mode-map
                          rust-mode-map rust-ts-mode-map
                          sh-mode-map bash-ts-mode-map)
    "r" '(nil :wk "realgud")
    "rd" #'+realgud:start
    "rh" #'+realgud-hydra/body))

(use-package realgud-lldb
  :straight t
  :init
  (defalias 'realgud:lldb #'realgud--lldb)
  :commands (realgud--lldb realgud:lldb lldb))

(use-package realgud-ipdb
  :straight t
  :commands (ipdb realgud:ipdb))
#+end_src

=disaster= 查看汇编

#+begin_src emacs-lisp :tangle no
(use-package disaster
  :straight t
  :preface
  (defconst +objdump-available-p (executable-find "objdump"))
  :when +objdump-available-p
  :init
  (+map-local! :keymaps '(c-mode-map c++-mode-map fortran-mode-map)
    "D" #'disaster))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-debug)
;;; me-debug.el ends here
#+end_src

** me-docs.el
=me-docs.el= 文档格式相关

文件头

#+begin_src emacs-lisp
;;; me-docs.el --- Documents (PDF, EPUB, DOC...) -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=doc-view= 是 Emacs 内置的一个模式，用于查看和浏览各种格式的文档，如 PDF、PostScript 和 DVI. 它提供了一种方便的方式来阅读和浏览大型文档，无需使用外部程序.

#+begin_src emacs-lisp
(use-package doc-view
  :straight (:type built-in)
  :custom
  (doc-view-mupdf-use-svg (+emacs-features-p 'rsvg)))
#+end_src

=pdf-tools= 用于增强 Emacs 对 PDF 文件的支持。它提供了更丰富的功能和更高级的操作选项。

#+begin_src emacs-lisp
(use-package pdf-tools
  :straight t
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :magic ("%PDF" . pdf-view-mode)
  :custom
  (pdf-view-display-size 'fit-page)
  (pdf-view-image-relief 2)
  (pdf-view-use-scaling t)
  :init
  (+register-build-function! pdf-tools-install))
#+end_src

=nov= 用于在 Emacs 中阅读 EPUB 电子书. 它提供了一个简单而轻量级的 EPUB 阅读器, 使您能够在 Emacs 中舒适地阅读电子书.

#+begin_src emacs-lisp
(use-package nov
  :straight t
  :mode ("\\.epub\\'" . nov-mode)
  :custom
  (nov-save-place-file (concat minemacs-local-dir "nov/save-place.el"))
  :config
  (+nmap! :keymaps 'nov-mode-map
    "RET" #'nov-scroll-up)
  (defun doom-modeline-segment--nov-info ()
    (concat " " (propertize (cdr (assoc 'creator nov-metadata))
                            'face 'doom-modeline-project-parent-dir)
            " " (cdr (assoc 'title nov-metadata))
            " " (propertize (format "%d/%d" (1+ nov-documents-index)
                                    (length nov-documents))
                            'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 80
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)

    (setq-local
     mode-line-format
     `((:eval
        (doom-modeline-segment--workspace-name))
       (:eval
        (doom-modeline-segment--window-number))
       (:eval
        (doom-modeline-segment--nov-info))
       ,(propertize
         " %P "
         'face 'doom-modeline-buffer-minor-mode)
       ,(propertize
         " "
         'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
         'display `((space
                     :align-to
                     (- (+ right right-fringe right-margin)
                      ,(* (let ((width (doom-modeline--font-width)))
                           (or (and (= width 1) 1)
                            (/ width (frame-char-width) 1.0)))
                        (string-width
                         (format-mode-line
                          (cons ""
                           '(:eval (doom-modeline-segment--major-mode))))))))))
       (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src

=crdt= CRDT包允许在Emacs中使用CRDT数据类型，并提供了一些CRDT操作的函数和命令。它使得在分布式环境中多个Emacs实例之间同步和共享数据变得更加容易。

#+begin_src emacs-lisp :tangle no
(use-package crdt
  :straight t
  :preface
  (defconst +tuntox-available-p (executable-find "tuntox"))
  (defconst +stunnel-available-p (executable-find "stunnel"))
  :when (or +tuntox-available-p +stunnel-available-p)
  :init
  (cond (+tuntox-available-p
         (setq crdt-use-tuntox t
               crdt-tuntox-password-in-url t))
        (+stunnel-available-p
         (setq crdt-use-stunnel t))))
#+end_src

[[https://github.com/misohena/el-easydraw][edraw]] 简易绘图 =edraw-org= 您可以使用 Edraw Max 创建各种类型的图表（如流程图、组织结构图、思维导图等），然后将生成的图表代码插入到 Org 文档中。这样，您可以在 Org 文档中以文本形式编辑和管理图表，并在需要时渲染为实际的图形。

#+begin_src emacs-lisp
(defconst +easydraw-available-p (+emacs-features-p 'rsvg 'zlib 'libxml2))

(use-package edraw
  :straight (:host github :repo "misohena/el-easydraw")
  :when +easydraw-available-p)

(use-package edraw-org
  :hook (org-mode . edraw-org-setup-default)
  :when +easydraw-available-p)
#+end_src

=markdown= =poly-markdown= 您可以在 Markdown 文档中嵌入代码块，并使用不同的编程语言编写这些代码块。这些代码块可以包含任何支持的编程语言，如 Python、JavaScript、Ruby 等。您可以在代码块中编写和执行代码，以及查看代码的输出结果。

#+begin_src emacs-lisp
(use-package markdown-mode
  :straight t
  :mode ("README\\.md\\'" . gfm-mode)
  :custom
  (markdown-hide-markup t)
  (markdown-enable-math t))

(use-package poly-markdown
  :straight t)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-docs)
;;; me-docs.el ends here
#+end_src

[[edraw:][test_edVdraw]]

** me-eaf.el
=me-eaf.el= 在emacs里运行其他程序

文件头

#+begin_src emacs-lisp
;;; me-eaf.el --- EAF applications -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=emacs-application-framework= Emacs Application Framework (EAF) 是一个基于 Emacs 的框架，旨在将现代应用程序引入 Emacs 环境。它提供了在 Emacs 中运行 Web 应用程序、图形界面应用程序和其他外部应用程序的能力。

#+begin_src emacs-lisp
(unless (+emacs-features-p 'lucid)
  (use-package eaf
    :straight (:host github :repo "emacs-eaf/emacs-application-framework" :files (:defaults "*"))
    :init
    (+map! "oo" #'eaf-open)
    ;; Evil integration doesn't work, start `eaf-mode' in `emacs-state'.
    (with-eval-after-load 'evil
      (evil-set-initial-state 'eaf-mode 'emacs))
    (+register-build-function! eaf-install-and-update)
    :commands eaf-file-sender-qrcode-in-dired +eaf-open-mail-as-html +browse-url-eaf eaf-open-browser
    :custom
    ;; Generic
    (eaf-apps-to-install
     '(browser mindmap jupyter file-sender video-player markdown-previewer))
    (eaf-start-python-process-when-require t)
    (eaf-kill-process-after-last-buffer-closed t)
    (eaf-fullscreen-p nil)
    (eaf-config-location (concat minemacs-local-dir "eaf/"))
    ;; Debug
    (eaf-enable-debug nil)
    ;; Web engine
    (eaf-webengine-font-family (plist-get minemacs-fonts :font-family))
    (eaf-webengine-fixed-font-family (plist-get minemacs-fonts :font-family))
    (eaf-webengine-serif-font-family (plist-get minemacs-fonts :variable-pitch-font-family))
    (eaf-webengine-font-size 16)
    (eaf-webengine-fixed-font-size 16)
    (eaf-webengine-enable-scrollbar t)
    (eaf-webengine-scroll-step 200)
    (eaf-webengine-default-zoom 1.25)
    (eaf-webengine-show-hover-link t)
    (eaf-webengine-download-path "~/Downloads")
    (eaf-webengine-enable-plugin t)
    (eaf-webengine-enable-javascript t)
    (eaf-webengine-enable-javascript-access-clipboard t)
    ;; Web browser
    (eaf-browser-continue-where-left-off t)
    (eaf-browser-enable-adblocker t)
    (eaf-browser-ignore-history-list '("google.com/search" "file://"))
    (eaf-browser-translate-language "en")
    (eaf-browser-blank-page-url "https://www.duckduckgo.com")
    (eaf-browser-chrome-history-file (concat minemacs-local-dir "eaf/browser/chrome-history"))
    (eaf-browser-default-search-engine "duckduckgo")
    (eaf-browser-continue-where-left-off t)
    (eaf-browser-aria2-auto-file-renaming t)
    ;; Video player
    (eaf-video-player-keybinding
     '(("p" . "toggle_play")
       ("q" . "close_buffer")
       ("h" . "play_backward")
       ("l" . "play_forward")
       ("j" . "decrease_volume")
       ("k" . "increase_volume")
       ("f" . "toggle_fullscreen")
       ("R" . "restart")))
    ;; Jupyter
    (eaf-jupyter-font-family (plist-get minemacs-fonts :font-family))
    (eaf-jupyter-font-size 14)
    ;; PDF viewer
    (eaf-pdf-outline-buffer-indent 2)
    :config
    ;; Try to load enabled apps, and install them if they aren't installed
    (let (not-installed-apps)
      (dolist (app eaf-apps-to-install)
        (unless (require (intern (format "eaf-%s" app)) nil t)
          (push app not-installed-apps)))
      (when not-installed-apps
        (warn "Some apps are not installed: %s" not-installed-apps)))

    (defun +browse-url-eaf (url &rest args)
      "Open URL in EAF Browser."
      (interactive (browse-url-interactive-arg "URL: "))
      (eaf-open-browser (browse-url-encode-url url) args))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-eaf)
;;; me-eaf.el ends here
#+end_src

** me-editor.el
=me-editor.el= 编辑相关

文件头

#+begin_src emacs-lisp
;;; me-editor.el --- Editing stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

[[https://github.com/minad/tempel][Tempel]] 可以在 org-mode 中使用，通过定义不同的模板，可以根据模板快速生成代码、文档等。Tempel 的模板支持嵌套，可以根据不同的参数值生成不同的代码。

#+begin_src emacs-lisp
(use-package tempel
  :straight t
  :custom
  (tempel-trigger-prefix "<") ;; Require trigger prefix before template name when completing.
  (tempel-path (concat minemacs-root-dir "templates/tempel/*.eld"))
  :bind (("M-\"" . tempel-complete) ;; Alternative tempel-expand
         ("M-*" . tempel-insert)
         :map tempel-map
         ("TAB" . tempel-next)
         ("<backtab>" . tempel-previous))
  :hook ((prog-mode text-mode) . +tempel-setup-capf-h)
  :hook (prog-mode . tempel-abbrev-mode)
  :defines +tempel-setup-capf-h
  :config
  ;; Setup completion at point
  (defun +tempel-setup-capf-h ()
    ;; Add the Tempel Capf to `completion-at-point-functions'.
    ;; `tempel-expand' only triggers on exact matches. Alternatively use
    ;; `tempel-complete' if you want to see all matches, but then you
    ;; should also configure `tempel-trigger-prefix', such that Tempel
    ;; does not trigger too often when you don't expect it. NOTE: We add
    ;; `tempel-expand' *before* the main programming mode Capf, such
    ;; that it will be tried first.
    (setq-local
     completion-at-point-functions
     (if (derived-mode-p 'org-mode 'markdown-mode)
         '(tempel-complete)
       (cons #'tempel-complete completion-at-point-functions))))
  (global-tempel-abbrev-mode 1))

(use-package tempel-collection
  :straight t
  :after tempel
  :demand t)
#+end_src

=header2= 在新建文件时按照模板生成一个标准的文件头

#+begin_src emacs-lisp
(use-package header2
  :straight t
  :hook (prog-mode . auto-make-header)
  :custom
  (header-date-format t)
  (header-copyright "Machine Studio")
  (make-header-hook
   '(
     ;; header-mode-line
     header-title
     header-blank
     header-file-name
     header-description
     ;; header-status
     header-author
     header-maintainer
     header-copyright
     header-creation-date
     ;; header-rcs-id
     header-version
     ;; header-pkg-requires
     ;; header-sccs
     header-modification-date
     header-modification-author
     header-update-count
     ;; header-url
     ;; header-doc-url
     ;; header-keywords
     ;; header-compatibility
     header-blank
     ;; header-lib-requires
     header-end-line
     header-commentary
     header-blank
     header-blank
     header-blank
     header-end-line
     ;; header-history
     ;; header-blank
     ;; header-blank
     ;; header-rcs-log
     ;; header-end-line
     header-free-software
     header-code
     header-eof)))
#+end_src

[[https://github.com/rolandwalker/unicode-fonts][unicode-fonts]] 它为 Emacs 中的 Unicode 字符提供了良好的显示效果。在 Emacs 中，如果一个字体不能正确地显示 Unicode 字符，这些字符将以方块或空心的框框代替。unicode-fonts 包可以解决这个问题，它会检测 Emacs 中所使用的字体是否支持 Unicode 字符，并动态地将 Unicode 字符映射到支持它们的字体上，从而让 Unicode 字符在 Emacs 中正常地显示。

#+begin_src emacs-lisp
(use-package unicode-fonts
  :straight t
  :hook (minemacs-after-startup . +unicode-fonts-setup)
  :config
  (defun +unicode-fonts-setup ()
    "Prefer the `:unicode-font-family' from `minemacs-fonts'."
    (when-let ((frame (selected-frame)))
      (when (display-multi-font-p frame)
        (with-selected-frame frame
          (when-let ((unicode-font-family (plist-get minemacs-fonts :unicode-font-family)))
            (dolist (unicode-block unicode-fonts-block-font-mapping)
              (push unicode-font-family (cadr unicode-block))))
          (unicode-fonts-setup))))))
#+end_src

[[https://github.com/mickeynp/ligature.el][ligature]] 它可以在 Emacs 中启用和显示代码连字(ligatures)。

#+begin_src emacs-lisp
(when (and (>= emacs-major-version 28) (+emacs-features-p 'harfbuzz 'cairo))
  (use-package ligature
    :straight t
    :after minemacs-loaded
    :hook (prog-mode . ligature-mode)
    :config
    ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))
    ;; Enable traditional ligature support in eww-mode, if the
    ;; `variable-pitch' face supports it
    (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
    ;; Enable all "Cascadia Code" ligatures in programming modes
    (ligature-set-ligatures
     'prog-mode
     '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
       "\\\\" "://"))))
#+end_src

=rainbow-delimiters= 在 Emacs 中显示彩虹颜色的括号匹配, 它可以帮助你更容易地识别代码中的括号嵌套结构。当你在编写代码时，每对括号会以不同的颜色进行高亮显示，帮助你更好地理解代码的结构。这对于大型代码文件或深层嵌套的括号非常有用。

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :straight t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

=highlight-numbers= 用于在代码中高亮数字。它适用于各种编程语言，包括但不限于 Emacs Lisp、Python、C、Java 等。

#+begin_src emacs-lisp
(use-package highlight-numbers
  :straight t
  :hook ((prog-mode conf-mode) . highlight-numbers-mode)
  :config
  ;; Original "\\_<[[:digit:]].*?\\_>"
  (setq highlight-numbers-generic-regexp "\\_<[[:digit:]]+\\(?:\\.[0-9]*\\)?\\_>"))
#+end_src

[[https://github.com/Fuco1/smartparens][Smartparens]] 提供了一些智能的括号匹配和操作功能。主要功能包括：
+ 自动匹配括号：输入左括号时自动插入右括号，光标在左括号处时高亮右括号。
+ 括号包围：快速将一个词语包围在括号、引号等符号中。
+ 括号删除：删除一个括号时自动删除匹配的另一个括号，删除一对括号时也可以将中间的内容一起删除。
+ 括号替换：可以快速将一个类型的括号替换成另一个类型的括号。
+ 括号交换：可以快速交换一对括号中的内容，或者将一对括号移动到另一个位置。

#+begin_src emacs-lisp
(use-package smartparens
  :straight t
  :hook (prog-mode . smartparens-mode)
  :config
  (with-eval-after-load 'evil-mc
    ;; Make evil-mc cooperate with smartparens better
    (let ((vars (cdr (assq :default evil-mc-cursor-variables))))
      (unless (memq (car sp--mc/cursor-specific-vars) vars)
        (setcdr (assq :default evil-mc-cursor-variables)
                (append vars sp--mc/cursor-specific-vars))))))

;; Default `smartparens' configuration (for example, do not complete a single
;; quote)
(use-package smartparens-config
  :after smartparens
  :demand t)
#+end_src

[[https://github.com/magnars/expand-region.el][expand-region]] 它允许你增加当前光标所在位置选定区域的大小。它能够自动检测当前光标所在的语法结构，如单词、句子、段落、函数、括号等，并选中其整个区域。使用它，你可以更快地选择一大段文本，而不必手动一个字符一个字符地选择。

#+begin_src emacs-lisp
;; I learn this trick from ReneFroger, need latest expand-region
;; @see https://github.com/redguardtoo/evil-matchit/issues/38
(use-package expand-region
  :straight t
  :init
  (+vmap! "v" #'er/expand-region))
#+end_src

[[https://github.com/minad/goggles][Goggles]] 使用脉冲突出显示修改后的区域 目前支持 undo、yank、kill 和 delete 命令

#+begin_src emacs-lisp
(use-package goggles
  :straight t
  :hook ((prog-mode text-mode) . goggles-mode)
  :config
  ;; Pulse for evil commands
  (goggles-define undo primitive-undo evil-undo)
  (goggles-define yank yank yank-pop evil-yank evil-yank-line)
  (goggles-define kill kill-region)
  (goggles-define delete delete-region evil-delete evil-delete-line))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-editor)
;;; me-editor.el ends here
#+end_src

** me-email.el
=me-email.el= 在emacs中完成email

文件头

#+begin_src emacs-lisp
;;; me-email.el --- Editing stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=mu4e= 是一个基于 Emacs 的电子邮件客户端，它是针对邮件检索和管理的 mu 邮件搜索引擎的一个前端界面。它提供了一个强大而灵活的界面，使您可以在 Emacs 中方便地阅读、编写和管理电子邮件.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.mailrc\\'" . conf-space-mode))

(defconst +mu4e-load-path "/usr/share/emacs/site-lisp/mu4e/")

(defgroup minemacs-mu4e nil
  "MinEmacs mu4e tweaks."
  :group 'minemacs)

(defconst +mu4e-available-p
  (and (executable-find "mu")
       (executable-find "msmtp")
       (executable-find "mbsync")
       (file-directory-p +mu4e-load-path)))

(use-package mu4e
  :when +mu4e-available-p
  :load-path +mu4e-load-path
  :commands mu4e-compose-new mu4e--start mu4e
  :hook (mu4e-headers-mode . (lambda ()
                               (visual-line-mode -1)
                               (display-line-numbers-mode -1)))
  :init
  (+map! "om" #'mu4e)
  :custom
  (mu4e-confirm-quit t)
  (mu4e-search-results-limit 1000)
  (mu4e-index-cleanup t)
  (mu4e-attachment-dir "~/Downloads/mu4e-attachements/")
  (mu4e-update-interval (* 1 60)) ;; Every 1 min
  (mu4e-context-policy 'pick-first) ;; Start with the first context
  (mu4e-compose-context-policy 'ask) ;; Always ask which context to use when composing a new mail
  (mu4e-sent-messages-behavior 'sent) ;; Will be overwritten for Gmail accounts
  (mu4e-get-mail-command "mbsync -a") ;; Use mbsync to get mails
  (mu4e-index-update-error-warning nil) ;; Do not show warning after update
  (mu4e-hide-index-messages t) ;; Hide minibuffer messages after indexing
  (mu4e-change-filenames-when-moving t)
  (mu4e-completing-read-function #'completing-read) ;; Use `vertico' instead of `ido'
  (mu4e-main-hide-personal-addresses t) ;; Don't display a list of my own addresses!
  (mu4e-modeline-support nil) ;; `mu4e-alert' is much nicer.
  (mu4e-eldoc-support t)
  (sendmail-program (executable-find "msmtp")) ;; Use msmtp to send mails
  (send-mail-function #'smtpmail-send-it)
  (message-sendmail-f-is-evil t)
  (message-sendmail-extra-arguments '("--read-envelope-from"))
  (message-send-mail-function #'message-send-mail-with-sendmail)
  (message-sendmail-envelope-from 'obey-mail-envelope-from)
  (message-mail-user-agent 'mu4e-user-agent)
  (message-kill-buffer-on-exit t) ;; Close after sending
  (mail-envelope-from 'header)
  (mail-specify-envelope-from t)
  (mail-user-agent 'mu4e-user-agent)
  (read-mail-command 'mu4e)
  :config
  (+nvmap! :keymaps 'mu4e-view-mode-map
    "p" #'mu4e-view-save-attachments)
  (+nvmap! :keymaps '(mu4e-headers-mode-map mu4e-view-mode-map)
    "gw" #'+mu4e-open-mail-as-html
    "g RET" #'browse-url-at-point)
  (+map-local! :keymaps '(mu4e-compose-mode-map org-msg-edit-mode-map)
    "s" #'message-send-and-exit
    "d" #'message-kill-buffer
    "S" #'message-dont-send)

  (defun +mu4e-open-mail-as-html ()
    "Open the HTML mail in EAF Browser."
    (interactive)
    (if-let ((msg (mu4e-message-at-point t))
             ;; Bind browse-url-browser-function locally, so it works
             ;; even if EAF Browser is not set as a default browser.
             (browse-url-browser-function
              (cond
               ((featurep 'me-eaf) #'eaf-open-browser)
               (t #'browse-url-xdg-open))))
        (mu4e-action-view-in-browser msg)
      (message "No message at point.")))

  ;; Force running update and index in background
  (advice-add
   'mu4e-update-mail-and-index :around
   (defun +mu4e--update-mail-quitely-a (origfn run-in-background)
     (+info! "Getting new emails")
     (apply origfn '(t)))))

;; Reply to iCalendar meeting requests
(use-package mu4e-icalendar
  :when +mu4e-available-p
  :load-path +mu4e-load-path
  :after mu4e
  :demand t
  :config
  (mu4e-icalendar-setup))

(use-package me-mu4e-ui
  :after mu4e
  :demand t
  :config
  ;; Setup the UI (mostly inspired by Doom Emacs, with a lot of improvements)
  (+mu4e-ui-setup))

(use-package me-mu4e-gmail
  :after mu4e
  :demand t
  :config
  ;; Setup Gmail specific hacks (adapted from Doom Emacs, with a lot of
  ;; improvements)
  (+mu4e-gmail-setup))

(use-package me-mu4e-extras
  :after mu4e
  :demand t
  :config
  ;; Enable MinEmacs's mu4e extra features, including:
  ;; - Auto BCC the `+mu4e-auto-bcc-address';
  ;; - Prompt for the "From" address from the account aliases `+mu4e-account-aliases';
  ;; - Check for the subject before sending;
  ;; - Add an action to save the mail as PDF;
  ;; - Add an action to save all the attachements;
  ;; - Add an action to save the message at point.
  (+mu4e-extras-setup)
  ;; Redefine bookmarks queries to ignore spams
  (+mu4e-extras-ignore-spams-in-bookmarks-setup))

(use-package org-msg
  :straight t
  :after mu4e
  :demand t
  :custom
  (org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil tex:dvipng")
  (org-msg-startup "hidestars indent inlineimages")
  (org-msg-greeting-name-limit 3)
  (org-msg-convert-citation t)
  (org-msg-default-alternatives '((new . (utf-8 html))
                                  (reply-to-text . (utf-8 html))
                                  (reply-to-html . (utf-8 html))))
  (org-msg-attached-file-reference
   (rx (or (seq "attach" (or "ment" "ed"))
           (seq "enclosed")
           (seq "attach" (any ?é ?e) (? "e") (? "s"))
           (seq "ci" (or " " "-") "joint" (? "e")) ;; ci-joint
           (seq (or (seq "pi" (any ?è ?e) "ce") "fichier" "document") (? "s") (+ (or " " eol)) "joint" (? "e") (? "s")) ;; pièce jointe
           (seq (or (seq space "p" (zero-or-one (any ?- ?.)) "j" (any space ?: ?\; ?, ?.))))))) ;; p.j
  :config
  (+nvmap! :keymaps 'org-msg-edit-mode-map
    "TAB" #'org-msg-tab
    "gg"  #'org-msg-goto-body)
  (+map-local! :keymaps 'org-msg-edit-mode-map
    "a"  '(nil :wk "attach")
    "aa" #'org-msg-attach-attach
    "ad" #'org-msg-attach-delete
    "p"  #'org-msg-preview)
  (org-msg-mode 1))

(use-package mu4e-alert
  :straight t
  :after mu4e
  :demand t
  :custom
  (mu4e-alert-icon "/usr/share/icons/Papirus/64x64/apps/mail-client.svg")
  (mu4e-alert-set-window-urgency nil)
  (mu4e-alert-group-by :to)
  (mu4e-alert-email-notification-types '(subjects))
  :init
  (defcustom +mu4e-alert-bell-command
    (when (or os/linux os/bsd)
      '("paplay" . "/usr/share/sounds/freedesktop/stereo/message.oga"))
    "A cons list of the command and arguments to play the notification bell."
    :group 'minemacs-mu4e
    :type '(cons string string))
  :config
  ;; Enable on mu4e notifications in doom-modeline
  (setq doom-modeline-mu4e t)

  ;; Ignore spams!
  (setq mu4e-alert-interesting-mail-query
        (+mu4e-extras-ignore-spams-query mu4e-alert-interesting-mail-query))

  (mu4e-alert-enable-mode-line-display)
  (mu4e-alert-enable-notifications)
  (mu4e-alert-set-default-style 'libnotify)

  (defun +mu4e-name-or-email (msg)
    (let* ((from (car (plist-get msg :from)))
           (name (plist-get from :name)))
      (if (or (null name) (eq name ""))
          (plist-get from :email)
        name)))

  (defun +mu4e-alert-grouped-mail-notif-formatter (mail-group _all-mails)
    (when +mu4e-alert-bell-command
      (start-process "mu4e-alert-bell" nil (car +mu4e-alert-bell-command) (cdr +mu4e-alert-bell-command)))
    (let ((mail-count (length mail-group)))
      (list
       :title (format "You have %d unread email%s"
                      mail-count (if (> mail-count 1) "s" ""))
       :body (concat
              "• "
              (string-join
               (mapcar
                (lambda (msg)
                  (format "<b>%s</b>: %s"
                          (+mu4e-name-or-email msg)
                          (plist-get msg :subject)))
                mail-group)
               "\n• ")))))

  (setq mu4e-alert-grouped-mail-notification-formatter
        #'+mu4e-alert-grouped-mail-notif-formatter))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-email)
;;; me-email.el ends here
#+end_src

** me-extra.el
=me-extra.el= 一些扩展函数

文件头

#+begin_src emacs-lisp
;;; me-extra.el --- Some extra functionalities -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=better-jumper= 它提供了一种更高效的跳转和导航方式，以帮助您在代码中快速定位和跳转到定义、引用和其他关键位置。

#+begin_src emacs-lisp
(use-package better-jumper
  :straight t
  :hook (minemacs-after-startup . better-jumper-mode)
  :init
  ;; Map extra mouse buttons to jump forward/backward
  (+mmap!
    "C-o" #'better-jumper-jump-backward
    "C-S-o" #'better-jump-forward))
#+end_src

=crux= 它提供了一系列有用的命令和函数，旨在提高 Emacs 的操作效率和工作流程。

#+begin_src emacs-lisp
(use-package crux
  :straight t
  :init
  (+map!
    "fo" #'crux-open-with
    "fU" #'crux-sudo-edit
    "fD" #'crux-delete-file-and-buffer
    "fC" #'crux-copy-file-preserve-attributes
    "id" #'crux-insert-date
    "bo" #'crux-kill-other-buffers))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-extra)
;;; me-extra.el ends here
#+end_src

** me-files.el
=me-files.el= 文件相关

文件头

#+begin_src emacs-lisp
;;; me-files.el --- File management -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=dirvish= 是 Emacs 中一个目录管理工具，它提供了类似于 Vim 中 NERDTree 的功能，让用户可以在 Emacs 中浏览文件系统，打开文件、目录或新建文件。通过使用 dirvish，用户可以在不离开 Emacs 的情况下管理文件系统，提高工作效率。

#+begin_src emacs-lisp
(use-package dirvish
  :straight t
  :hook (minemacs-after-startup . dirvish-override-dired-mode)
  :custom
  (dirvish-attributes '(subtree-state nerd-icons file-size vc-state git-msg))
  (dirvish-cache-dir (+directory-ensure minemacs-cache-dir "dirvish/"))
  (dirvish-mode-line-format '(:left (sort file-time symlink) :right (omit yank index)))
  (dirvish-side-width 30)
  (dirvish-fd-default-dir "~/")
  (dirvish-use-header-line t) ; 'global make header line span all panes
  (dirvish-use-mode-line t)
  :init
  (+map!
    ;; Open
    "o-" '(dirvish :wk "Dirvish")
    "oq" '(dirvish-quick-access :wk "Dirvish quick access")
    ;; Search
    "sd" '(dirvish-fd :wk "Dirvish fd"))
  :config
  (+nvmap! :keymaps 'dirvish-mode-map
    "q" #'dirvish-quit
    "s" #'dirvish-subtree-toggle
    "h" #'dired-up-directory
    "l" #'dired-find-file
    "y" #'dirvish-yank-menu))
#+end_src

=vlf-setup= 用于设置 Emacs 中大文件的查看和编辑功能

#+begin_src emacs-lisp
(use-package vlf-setup
  :straight vlf
  :after minemacs-loaded
  :demand t)
#+end_src

=treemacs= 文件游览导航

#+begin_src emacs-lisp
(use-package treemacs
  :straight t
  :init
  (+map!
    "op" '(treemacs :wk "Side panel"))
  :custom
  (treemacs-persist-file (concat minemacs-local-dir "treemacs/persist.el"))
  (treemacs-last-error-persist-file (concat minemacs-local-dir "treemacs/last-error-persist.el"))
  (treemacs-width 30))

(use-package treemacs-evil
  :straight t
  :after treemacs evil
  :demand t)

(use-package treemacs-nerd-icons
  :straight t
  :after treemacs nerd-icons
  :demand t
  :config
  (treemacs-load-theme "nerd-icons"))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-files)
;;; me-files.el ends here
#+end_src

** me-fun.el
=me-fun.el= 一些有趣的包

文件头

#+begin_src emacs-lisp
;;; me-fun.el --- Some funny stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=xkcd= 漫画阅读

#+begin_src emacs-lisp
(use-package xkcd
  :straight t
  :init
  (+map! "ox" #'xkcd)
  :custom
  (xkcd-cache-dir (+directory-ensure minemacs-local-dir "xkcd/"))
  (xkcd-cache-latest (concat minemacs-local-dir "xkcd/latest"))
  :config
  (+nvmap! :keymaps 'xkcd-mode-map
    "j" #'xkcd-next
    "k" #'xkcd-prev
    "l" #'xkcd-get-latest
    "L" #'xkcd-get-latest-cached
    "<right>" #'xkcd-next
    "<left>" #'xkcd-prev
    "o" #'xkcd-open-browser
    "O" #'xkcd-open-explanation-browser
    "r" #'xkcd-rand
    "y" #'xkcd-copy-link)
  (+ignore-root xkcd-cache-dir))
#+end_src

=speed-type= 用于提供打字速度测试和训练的功能

#+begin_src emacs-lisp
(use-package speed-type
  :straight t)
#+end_src

[[https://github.com/zkry/asm-blox][asm-blow]] 是一款受WebAssembly Text格式（WAT）启发的编程游戏。

#+begin_src emacs-lisp
(use-package asm-blox
  :straight t)
#+end_src

=Zone= 是 Emacs 内置的一个模式，它可以在编辑器的空闲时间创建动画效果。

#+begin_src emacs-lisp
(use-package zone
  :straight (:type built-in)
  :config
  (zone-when-idle 30))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-fun)
;;; me-fun.el ends here
#+end_src

** me-gnus.el
=me-gnus.el= email 的 gnu实现

文件头

#+begin_src emacs-lisp
;;; me-gnus.el --- Email stuff using Gnus -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=email use gnus=

#+begin_src emacs-lisp
;; See: emacswiki.org/emacs/GnusTutorial
;; github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org
(setq gnus-init-file (concat minemacs-config-dir "gnus.el"))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide me-gnus)
;;; me-gnus.el ends here
#+end_src

** me-latex.el
=me-latex.el= LaTeX是一种文本排版系统，通常用于制作科技论文、报告、学术出版物、书籍、幻灯片等等。

文件头

#+begin_src emacs-lisp
;;; me-latex.el --- LaTeX related stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

TODO: 学习LaTeX

#+begin_src emacs-lisp
;; Adapted from Doom Emacs
(use-package tex
  :straight auctex
  :hook ((tex-mode TeX-mode latex-mode LaTeX-mode) . TeX-source-correlate-mode)
  :hook ((tex-mode TeX-mode latex-mode LaTeX-mode) . hs-minor-mode)
  :custom
  (TeX-parse-self t) ; parse on load
  (TeX-auto-save t)  ; parse on save
  (TeX-auto-local ".auctex-auto") ; use hidden directories for AUCTeX files.
  (TeX-style-local ".auctex-style")
  (TeX-source-correlate-method 'synctex)
  (TeX-source-correlate-start-server nil) ; don't start the Emacs server when correlating sources.
  (TeX-electric-sub-and-superscript t) ; automatically insert braces after sub/superscript in `LaTeX-math-mode'.
  (TeX-save-query nil) ; just save, don't ask before each compilation.
  (TeX-engine 'xetex) ; use XeLaTeX by default
  (TeX-PDF-mode t) ; export to PDF by default
  :init
  (+map-local! :keymaps '(tex-mode-map TeX-mode-map latex-mode-map LaTeX-mode-map)
    "c" #'TeX-command-run-all
    "m" #'TeX-command-master
    "e" #'TeX-engine-set
    "v" #'TeX-view)
  :config
  (when (functionp 'pdf-tools-install)
    (add-to-list 'TeX-view-program-selection '(output-pdf "PDF Tools"))))

(use-package latex
  :straight auctex
  :config
  ;; Add the TOC entry to the sectioning hooks.
  (setq LaTeX-fill-break-at-separators nil
        LaTeX-item-indent 0))

;; Adapted from Doom Emacs
(use-package auctex-latexmk
  :straight t
  :after latex
  :demand t
  :hook (LaTeX-mode . +tex--set-latexmk-as-default-cmd-h)
  :defines +tex--set-latexmk-as-default-cmd-h
  :custom
  (auctex-latexmk-inherit-TeX-PDF-mode t)
  :config
  (setq-default
   TeX-command-list
   (cons
    '("LatexMk-2" "latexmk -shell-escape %(-PDF)%S%(mode) %(file-line-error) %(extraopts) %t" TeX-run-latexmk nil
      (plain-tex-mode latex-mode doctex-mode) :help "Run LatexMk with shell-escape")
    TeX-command-list))

  (defun +tex--set-latexmk-as-default-cmd-h ()
    (setq TeX-command-default "LatexMk-2"))

  ;; Add LatexMk as a TeX target.
  (auctex-latexmk-setup))

(use-package bibtex
  :straight (:type built-in)
  :hook (bibtex-mode . display-line-numbers-mode)
  :custom
  (bibtex-dialect 'biblatex)
  (bibtex-align-at-equal-sign t)
  (bibtex-text-indentation 20)
  :config
  (+map-local! :keymaps 'bibtex-mode-map
    "l" #'bibtex-fill-entry
    "r" #'bibtex-reformat))

;; Inspired by Doom Emacs
(use-package reftex
  :straight (:type built-in)
  :hook (LaTeX-mode . turn-on-reftex)
  :hook (reftex-toc-mode . reftex-toc-rescan)
  :custom
  ;; Get RefTeX working with BibLaTeX. See: tex.stackexchange.com/a/31992/43165
  (reftex-cite-format
   '((?a . "\\autocite[]{%l}")
     (?b . "\\blockcquote[]{%l}{}")
     (?c . "\\cite[]{%l}")
     (?f . "\\footcite[]{%l}")
     (?n . "\\nocite{%l}")
     (?p . "\\parencite[]{%l}")
     (?s . "\\smartcite[]{%l}")
     (?t . "\\textcite[]{%l}"))
   ;; This is needed when `reftex-cite-format' is set. See:
   ;; superuser.com/a/1386206
   (LaTeX-reftex-cite-format-auto-activate nil)
   (reftex-plug-into-AUCTeX t)
   (reftex-toc-split-windows-fraction 0.3))
  :config
  (+map-local! :keymaps 'reftex-mode-map
    ";" 'reftex-toc)
  (+nvmap! :keymaps 'reflex-toc-mode-map
    "j"   #'next-line
    "k"   #'previous-line
    "q"   #'kill-buffer-and-window
    "ESC" #'kill-buffer-and-window)
  (with-eval-after-load 'evil
    (add-hook 'reftex-mode-hook #'evil-normalize-keymaps)))

(use-package me-latex-fonts
  :after latex
  :demand t)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-latex)
;;; me-latex.el ends here
#+end_src

** me-lifestyle.el
=me-lifestyle.el= 一种生活方式

文件头

#+begin_src emacs-lisp
;;; me-lifestyle.el --- *Highly* opinionated lifestyles apps -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=awqat= 它提供了显示伊斯兰教离线礼拜时间表的功能.

#+begin_src emacs-lisp
(use-package awqat
  :straight (:host github :repo "zkry/awqat")
  :commands awqat-times-for-day
  :custom
  ;; In your "config.el", you need to set `calendar-latitude' and
  ;; `calendar-longitude' (both defined in `solar'). Alongside with the
  ;; calculation method, either by setting the right angles for Fajr and Isha,
  ;; or by using one of the predefined presets (see `awqat' for more
  ;; information).
  (awqat-mode-line-format (concat " " (nerd-icons-mdicon "nf-md-mosque") " ${prayer} (${hours}h${minutes}m) "))
  (awqat-update-interval 30.0))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-lifestyle)
;;; me-lifestyle.el ends here
#+end_src

** me-lisp.el
=me-lisp.el= lisp相关的包和设置

文件头

#+begin_src emacs-lisp
;;; lisp.el --- Lisp, Scheme, Elisp -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=parinfer-rust-mode=
+ 在系统架构为 x86_64 时使用 Rust 实现的 parinfer-rust-mode 插件。 parinfer-rust-mode 是一个可以自动匹配括号和引号的插件，可以方便 Lisp 方言编程的使用。
+ 这段代码还设置了 parinfer-rust 的自动下载和存储路径，并将 parinfer-rust-mode 添加到了 emacs-lisp-mode、clojure-mode、scheme-mode、lisp-mode、racket-mode 和 hy-mode 这些模式的 hook 中，以便在这些模式下启用 parinfer-rust-mode。

#+begin_src emacs-lisp
(when (+emacs-features-p 'modules)
  (use-package parinfer-rust-mode
    :straight t
    :when (eq sys/arch 'x86_64)
    :custom
    (parinfer-rust-library-directory (concat minemacs-local-dir "parinfer-rust/"))
    (parinfer-rust-auto-download (eq sys/arch 'x86_64))
    :hook ((emacs-lisp-mode
            clojure-mode
            scheme-mode
            lisp-mode
            racket-mode
            hy-mode)
           . parinfer-rust-mode)))
#+end_src

TODO: 有空在看

#+begin_src emacs-lisp
;; Common Lisp
(use-package sly
  :straight t
  :custom
  (sly-mrepl-history-file-name (+directory-ensure minemacs-local-dir "sly/mrepl-history.el"))
  (sly-net-coding-system 'utf-8-unix)
  :config
  (dolist (impl '("lisp"   ; Default Lisp implementation on the system
                  "clisp"  ; GNU CLISP
                  "abcl"   ; Armed Bear Common Lisp
                  "ecl"    ; Embeddable Common-Lisp
                  "gcl"    ; GNU Common Lisp
                  "ccl"    ; Clozure Common Lisp
                  "cmucl"  ; CMU Common Lisp
                  "clasp"  ; Common Lisp on LLVM
                  "sbcl")) ; Steel Bank Common Lisp
    (when (executable-find impl)
      (add-to-list
       'sly-lisp-implementations
       `(,(intern impl) (,impl) :coding-system utf-8-unix))))
  (setq inferior-lisp-program (caar (cdar sly-lisp-implementations))
        sly-default-lisp (caar sly-lisp-implementations))

  (+map-local! :keymaps '(lisp-mode-map)
    "s"  #'sly
    "c"  '(nil :wk "compile")
    "cc" #'sly-compile-file
    "cC" #'sly-compile-and-load-file
    "cd" #'sly-compile-defun
    "cr" #'sly-compile-region
    "g"  '(nil :wk "goto/find")
    "gn" #'sly-goto-first-note
    "gL" #'sly-load-file
    "gn" #'sly-next-note
    "gN" #'sly-previous-note
    "gs" #'sly-stickers-next-sticker
    "gS" #'sly-stickers-prev-sticker
    "gN" #'sly-previous-note
    "gd" #'sly-edit-definition
    "gD" #'sly-edit-definition-other-window
    "gb" #'sly-pop-find-definition-stack
    "h"  '(nil :wk "help/info")
    "hs" #'sly-describe-symbol
    "hf" #'sly-describe-function
    "hc" #'sly-who-calls
    "hC" #'sly-calls-who
    "hs" #'sly-who-calls
    "hC" #'sly-calls-who
    "hd" #'sly-disassemble-symbol
    "hD" #'sly-disassemble-definition
    "r"  '(nil :wk "repl")
    "rr" #'sly-restart-inferior-lisp
    "rc" #'sly-mrepl-clear-repl
    "rs" #'sly-mrepl-sync
    "rn" #'sly-mrepl-new
    "rq" #'sly-quit-lisp))

;; Scheme
(use-package racket-mode
  :straight t)

(use-package geiser
  :straight t
  :custom
  (geiser-default-implementation 'guile))

(use-package geiser-chez
  :straight t)

(use-package geiser-chibi
  :straight t)

(use-package geiser-chicken
  :straight t)

(use-package geiser-gambit
  :straight t)

(use-package geiser-gauche
  :straight t)

(use-package geiser-guile
  :straight t)

(use-package geiser-kawa
  :straight t)

(use-package geiser-mit
  :straight t)

(use-package geiser-racket
  :straight t)

(use-package geiser-stklos
  :straight t)

;; Clojure
(use-package clojure-mode
  :straight t)

(use-package cider
  :straight t)

(use-package macrostep
  :straight t
  :init
  (+map-local! :keymaps '(emacs-lisp-mode-map lisp-mode-map)
    "m" '(macrostep-expand :wk "Expand macro")))

(use-package macrostep-geiser
  :straight t
  :after geiser
  :hook ((geiser-mode geiser-repl-mode) . macrostep-geiser-setup)
  :init
  (+map-local! :keymaps '(geiser-mode-map geiser-repl-mode-map)
    "m" '(macrostep-expand :wk "Expand macro")
    "M" #'macrostep-geiser-expand-all))

(use-package sly-macrostep
  :straight t
  :after sly
  :demand t
  :init
  (+map-local! :keymaps '(sly-mode-map sly-editing-mode-map sly-mrepl-mode-map)
    "m" '(macrostep-expand :wk "Expand macro")))

;; Emacs Lisp
(use-package elisp-mode
  :straight (:type built-in)
  :hook (emacs-lisp-mode . (lambda () (setq-local tab-width 8))) ;; to view built-in packages correctly
  :after minemacs-loaded ; prevent elisp-mode from being loaded too early
  :init
  (+map-local! :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map ielm-map lisp-mode-map racket-mode-map scheme-mode-map)
    "p" #'check-parens)
  :config
  (+map-local! :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
    "d"   '(nil :wk "edebug")
    "df"  'edebug-defun
    "dF"  'edebug-all-forms
    "dd"  'edebug-all-defs
    "dr"  'edebug-remove-instrumentation
    "do"  'edebug-on-entry
    "dO"  'edebug-cancel-on-entry
    "db"  '(nil :wk "breakpoints")
    "dbb" 'edebug-set-breakpoint
    "dbr" 'edebug-unset-breakpoint
    "dbn" 'edebug-next-breakpoint
    "e"   '(nil :wk "eval")
    "eb"  'eval-buffer
    "ed"  'eval-defun
    "ee"  'eval-last-sexp
    "er"  'eval-region
    "eR"  'elisp-eval-region-or-buffer
    "el"  'load-library
    "g"   '(nil :wk "goto/find")
    "gf"  'find-function-at-point
    "gR"  'find-function
    "gv"  'find-variable-at-point
    "gV"  'find-variable
    "gL"  'find-library
    "c"   '(nil :wk "compile")
    "cc"  #'elisp-byte-compile-buffer
    "cf"  #'elisp-byte-compile-file
    "cn"  #'emacs-lisp-native-compile-and-load
    "cb"  #'emacs-lisp-byte-compile-and-load)
  (+map-local! :keymaps '(edebug-mode-map)
    "e"   '(nil :wk "eval")
    "ee"  'edebug-eval-last-sexp
    "eE"  'edebug-eval-expression
    "et"  'edebug-eval-top-level-form))

(use-package me-elisp-extras
  :after elisp-mode minemacs-loaded
  :demand t
  :config
  (+elisp-indent-setup)
  (+elisp-highlighting-setup))

(use-package elisp-demos
  :straight t
  :after elisp-mode minemacs-loaded
  :demand t
  :init
  (+map! :infix "he"
    "d" #'elisp-demos-find-demo
    "D" #'elisp-demos-add-demo)
  (advice-add #'describe-function-1 :after #'elisp-demos-advice-describe-function-1)
  (advice-add #'helpful-update :after #'elisp-demos-advice-helpful-update))

(use-package helpful
  :straight t
  :init
  (+map! :keymaps 'emacs-lisp-mode-map
    :infix "h"
    "p" #'helpful-at-point
    "o" #'helpful-symbol
    "c" #'helpful-command
    "F" #'helpful-function
    "f" #'helpful-callable))

(use-package info-colors
  :straight t
  :hook (Info-selection . info-colors-fontify-node))

(use-package eros
  :straight t
  :after elisp-mode minemacs-loaded
  :demand t
  :custom
  (eros-eval-result-prefix "⟹ ")
  :config
  (eros-mode 1))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-lisp)
;;; me-lisp.el ends here
#+end_src

** me-lsp.el
=me-lsp.el= lsp-mode相关包

文件头

#+begin_src emacs-lisp
;;; me-lsp.el --- Debugging and programming using lsp-mode and dap-mode -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=lsp-mode= 用于提供对 Language Server Protocol（语言服务器协议）的支持。它使 Emacs 能够与各种编程语言的语言服务器进行通信，从而提供代码补全、语法检查、重构等功能。

#+begin_src emacs-lisp
(use-package lsp-mode
  :straight t
  :preface
  (setq lsp-use-plists t)
  :commands +lsp-auto-enable
  :custom
  (lsp-session-file (concat minemacs-local-dir "lsp/session.el"))
  (lsp-server-install-dir (concat minemacs-local-dir "lsp/servers/"))
  (lsp-keep-workspace-alive nil)
  (lsp-log-io nil)
  (lsp-idle-delay 1.0)
  (lsp-log-max (when minemacs-debug message-log-max))
  ;; Less intrusive UI
  (lsp-eldoc-render-all nil) ; clangd docs looks ugly on eldoc-box!
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-lens-enable nil)
  ;; Maybe set to nil and enable modes manually (`lsp-completion-mode',
  ;; `lsp-modeline-diagnostics-mode', ...)
  (lsp-auto-configure t)
  ;; Those stuff should be managed by Emacs's builtins (whitespace-cleanup, treesit, ...)
  (lsp-semantic-tokens-enable t) ; when t, hides unreachable ifdefs!
  (lsp-enable-on-type-formatting nil)
  (lsp-enable-text-document-color nil)
  (lsp-trim-trailing-whitespace nil)
  (lsp-insert-final-newline nil)
  (lsp-trim-final-newlines nil)
  :init
  (+map!
    :infix "c"
    "l"  '(nil :wk "lsp session")
    "ll" #'lsp
    "lA" #'+lsp-auto-enable)
  (defcustom +lsp-auto-enable-modes
    '(c++-mode c++-ts-mode c-mode c-ts-mode
      python-mode python-ts-mode
      rust-mode rust-ts-mode cmake-mode
      js-mode js-ts-mode typescript-mode typescript-ts-mode
      json-mode json-ts-mode js-json-mode)
    "Modes for which LSP-mode can be automatically enabled by `+lsp-auto-enable'."
    :group 'minemacs-prog
    :type '(repeat symbol))
  :config
  (defun +lsp-auto-enable ()
    "Auto-enable LSP-mode in configured modes in `+lsp-auto-enable-modes'."
    (interactive)
    (dolist (mode +lsp-auto-enable-modes)
      (let ((hook (intern (format "%s-hook" mode))))
        (add-hook hook #'lsp-deferred)
        (remove-hook hook #'eglot-ensure))))

  (+map! :keymaps 'lsp-mode-map
    :infix "c"
    "fF" #'lsp-format-buffer
    "d"  '(lsp-find-declaration :wk "Find declaration")
    "D"  '(lsp-find-definition :wk "Find definition")
    "i"  '(lsp-find-implementation :wk "Find implementation")
    "t"  '(lsp-find-type-definition :wk "Find type definition")
    "a"  '(lsp-execute-code-action :wk "Code actions")
    "r"  '(nil :wk "refactor")
    "rr" '(lsp-rename :wk "Rename")
    "lq" '(lsp-workspace-shutdown :wk "Shutdown")
    "lr" '(lsp-workspace-restart :wk "Restart")))

(use-package ccls
  :straight t
  :custom
  ;; Customization of CCLS, see:
  ;; github.com/MaskRay/ccls/wiki/Customization#initialization-options
  ;; github.com/MaskRay/ccls/blob/master/src/config.hh
  (ccls-initialization-options
   '(:index (:comments 2
             :trackDependency 1
             :threads 4)
     :completion (:detailedLabel t
                  :caseSensitivity 1
                  :dropOldRequests t
                  :duplicateOptional t
                  :filterAndSort t
                  :maxNum 100
                  :placeholder t ; :json-false
                  :include (:maxPathSize 30
                            :blacklist []
                            :whitelist []
                            :suffixWhitelist [".h" ".hh" ".hxx" ".hpp" ".inc"]))
     :diagnostics (:onChange 1000 ; 1s
                   :onOpen 0
                   :onSave 0
                   :spellChecking t
                   :blacklist []
                   :whilist []
                   :caseSensitivity 1)
     :clang (:extraArgs ["--clang-tidy"]
             :excludeArgs []))))

(use-package lsp-pyright
  :straight t
  :after lsp-mode
  :demand t)

(use-package consult-lsp
  :straight t
  :after consult lsp-mode
  :init
  (+map! :keymaps 'lsp-mode-map
    "cs" '(consult-lsp-file-symbols :wk "Symbols")))
#+end_src
=dap-mode= 用于提供对调试器协议（Debugger Adapter Protocol）的支持。它使 Emacs 用户能够与各种编程语言的调试器进行交互，并提供了一套统一的接口和命令来进行断点设置、变量查看、单步执行等调试操作。
#+begin_src emacs-lisp
(use-package dap-mode
  :straight t
  :init
  (+map-local!
    :keymaps '(c-mode-map c++-mode-map python-mode-map
               rust-mode-map sh-mode-map bash-ts-mode-map
               js-mode-map js-ts-mode-map ruby-mode-map
               perl-mode-map)
    "d" '(nil :wk "dap")
    "dd" #'dap-debug
    "dt" #'dap-debug-edit-template
    "dh" #'dap-hydra/body)
  :hook (dap-stopped . (lambda (arg) (call-interactively #'dap-hydra)))
  :custom
  (dap-utils-extension-path (concat minemacs-local-dir "dap/extension/"))
  (dap-breakpoints-file (concat minemacs-local-dir "dap/breakpoints.el"))
  (dap-auto-configure-features '(locals breakpoints controls tooltip))
  (dap-auto-show-output nil))

(use-package dap-gdb-lldb
  :after dap-mode
  :demand t
  :custom
  (dap-gdb-lldb-extension-version
   (+github-latest-release "WebFreak001" "code-debug" "0.26.1")))

(use-package dap-cpptools
  :after dap-mode
  :demand t
  :custom
  (dap-cpptools-extension-version
   (+github-latest-release "microsoft" "vscode-cpptools" "1.14.4")))

(use-package dap-codelldb
  :after dap-mode
  :demand t
  :custom
  (dap-codelldb-extension-version
   (+github-latest-release "vadimcn" "codelldb" "1.9.0")))

(use-package dap-python
  :after dap-mode
  :demand t)

(use-package dap-mouse
  :after dap-mode
  :demand t)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-lsp)
;;; me-lsp.el ends here
#+end_src

** me-math.el
=me-math.el= 对于数学的支持

文件头

#+begin_src emacs-lisp
;;; me-math.el --- Mathematics stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=maxima=
+ Maxima是一个计算机代数系统,可以用于符号计算 数值计算 绘图和数据可视化等各种数学应用,它是一个免费的开源软件
+ iMaxima是Maxima的一个前端界面，它基于Emacs并提供了图形界面，方便用户进行符号计算
#+begin_src emacs-lisp
(defconst +maxima-path-p "/usr/share/emacs/site-lisp/maxima/")
(defconst +maxima-available-p (and (executable-find "maxima")
                                   (file-directory-p +maxima-path-p)))
(use-package maxima
  :load-path +maxima-path-p
  :when +maxima-available-p
  :mode ("\\.ma[cx]\\'" . maxima-mode)
  :interpreter ("maxima" . maxima-mode)
  :commands inferior-maxima-mode
  :custom
  (maxima-display-maxima-buffer nil))

(use-package imaxima
  :load-path +maxima-path-p
  :when +maxima-available-p
  :commands imaxima imath-mode
  :hook (imaxima-startup . maxima-inferior-mode) ; To get syntax highlighting
  :custom
  (imaxima-use-maxima-mode-flag nil))
#+end_src

暂时不用

#+begin_src emacs-lisp
(use-package math-preview ; Needed by ein to render equations
  :straight t)

(use-package ein
  :straight t
  :mode ("\\.ipynb\\'" . ein:ipynb-mode)
  :custom
  (ein:output-area-inlined-images t)
  :init
  (+map! :infix "o"
    "j" '(nil :wk "ein")
    "jr" #'ein:run
    "jl" #'ein:login
    "jf" #'ein:file-open
    "jn" #'ein:notebook-open)
  :config
  (+map-local! :keymaps 'ein:ipynb-mode-map
    "o" #'ein:process-find-file-callback
    "O" #'ein:process-open-notebook
    "r" #'ein:gat-run-remote
    "l" #'ein:gat-run-local)

  (setq-default ein:markdown-enable-math t)

  (with-eval-after-load 'org
    (org-babel-do-load-languages 'org-babel-load-languages (append org-babel-load-languages '((ein . t))))
    (setq org-src-lang-modes (append org-src-lang-modes '(("ein-python" . python) ("ein-r" . r) ("ein-julia" . julia))))))

(use-package julia-mode
  :straight t)

(use-package ess
  :straight t)

(use-package ess-view
  :straight t)

(use-package ess-R-data-view
  :straight t)

(use-package poly-R
  :straight t)

(use-package octave
  :straight (:type built-in)
  :mode ("\\.m\\'" . octave-mode)
  :config
  (defun +octave-eval-last-sexp ()
    "Evaluate Octave sexp before point and print value into current buffer."
    (interactive)
    (inferior-octave t)
    (let ((print-escape-newlines nil)
          (opoint (point)))
      (prin1
       (save-excursion
         (forward-sexp -1)
         (inferior-octave-send-list-and-digest
          (list (concat (buffer-substring-no-properties (point) opoint) "\n")))
         (mapconcat 'identity inferior-octave-output-list "\n")))))

  (with-eval-after-load 'eros
    (defun +eros-octave-eval-last-sexp ()
      "Wrapper for `+octave-eval-last-sexp' that overlays results."
      (interactive)
      (eros--eval-overlay
       (+octave-eval-last-sexp)
       (point)))

    (+map-local! :keymaps 'octave-mode-map
      "e"  '(nil :wk "eval")
      "ee" #'+eros-octave-eval-last-sexp)))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-math)
;;; me-math.el ends here
#+end_src

** me-media.el
=me-media.el= 多媒体相关

文件头

#+begin_src emacs-lisp
;;; me-media.el --- Multimedia stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=empv= 是一款 Emacs 下的音乐播放器，可以播放本地音乐文件和网络音乐资源，支持多种音频格式。empv 的特点是使用简单，快捷键容易记忆，并支持集成到 Emacs 窗口中。empv 可以使用 Emacs Lisp 的方式进行配置，例如自定义快捷键、主题等。empv 依赖于其他工具，例如 MPlayer、mpv 等。

#+begin_src emacs-lisp
(defcustom +mpv-command (executable-find "mpv")
  "The MPV command."
  :group 'minemacs-utils)

(defvar +mpv-buffer-name " *MPV*")
(defvar +mpv-process-name "mpv")

(when (executable-find +mpv-command)
  (defun +browse-url-mpv (url &optional args)
    "Open URL with MPV."
    (start-process +mpv-process-name +mpv-buffer-name +mpv-command url))

  (setq browse-url-browser-function
        `((,(rx (seq "http" (? ?s) "://" (? "www.") (or "youtube.com" "youtu.be"))) . +browse-url-mpv)
          ("." . browse-url-default-browser))))

(use-package empv
  :straight (:host github :repo "isamert/empv.el")
  :preface
  (defconst +mpv-available-p (executable-find +mpv-command))
  :when +mpv-available-p
  :init
  (+map! :infix "o"
    "v"  '(nil :wk "empv")
    "vp" '(empv-play :wk "Play")
    "vy" '(consult-empv-youtube :wk "Seach Youtube")
    "vr" '(empv-play-radio :wk "Play radio")
    "vs" '(empv-playtlist-save-to-file :wk "Save current playlist")
    "vD" '(+empv-download-playtlist-files :wk "Download current's playlist files"))
  :custom
  ;; See: docs.invidious.io/instances/
  (empv-invidious-instance "https://invidious.projectsegfau.lt/api/v1")
  (empv-audio-dir "~/Music")
  (empv-video-dir "~/Videos")
  (empv-max-directory-search-depth 6)
  (empv-radio-log-file (expand-file-name "logged-radio-songs.org" org-directory))
  (empv-audio-file-extensions '("webm" "mp3" "ogg" "wav" "m4a" "flac" "aac" "opus"))
  :config
  (defun +empv--dl-playlist (playlist &optional dist)
    (let ((default-directory
           (or dist
               (let ((d (expand-file-name "empv-downloads" empv-audio-dir)))
                 (unless (file-directory-p d) (mkdir d t)) d)))
          (vids (seq-filter
                 #'identity ;; Filter nils
                 (mapcar
                  (lambda (item)
                    (when-let
                        ((vid (when (string-match
                                     (rx (seq "watch?v=" (group-n 1 (one-or-more (or alnum "_" "-")))))
                                     item)
                                (match-string 1 item))))
                      vid))
                  playlist)))
          (proc-name "empv-yt-dlp"))
      (unless (zerop (length vids))
        (message "Downloading %d songs to %s" (length vids) default-directory)
        (when (get-process proc-name)
          (kill-process proc-name))
        (make-process :name proc-name
                      :buffer (format "*%s*" proc-name)
                      :command (append
                                (list
                                 (executable-find "yt-dlp")
                                 "--no-abort-on-error"
                                 "--no-colors"
                                 "--extract-audio"
                                 "--no-progress"
                                 "-f" "bestaudio")
                                vids)
                      :sentinel (lambda (prc event)
                                  (when (string= event "finished\n")
                                    (message "Finished downloading playlist files!")))))))

  (defun +empv-download-playtlist-files (&optional path)
    (interactive "DSave download playlist files to: ")
    (empv--playlist-apply #'+empv--dl-playlist path)))
#+end_src

=emms= 是 Emacs 多媒体系统（Emacs Multimedia System）的缩写，是 Emacs 中一个用于播放和管理音频和视频文件的工具。其支持多种媒体文件格式，包括 Ogg、MP3、FLAC、WAV、MIDI、OGM、MPEG、AVI、FLV 等。用户可以通过 Emacs 命令界面来浏览自己的音乐和视频文件集合，并且进行播放、暂停、停止等基本操作。EMMS 还提供了一个交互式搜索功能，用户可以通过搜索关键字来查找自己的音乐和视频文件，并且进行播放操作。除此之外，EMMS 还支持 ID3 标签编辑和一些可定制的选项。
#+begin_src emacs-lisp
(use-package emms
  :straight t)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-media)
;;; me-media.el ends here
#+end_src

** me-multi-cursors.el
=me-multi-cursors.el= 多光标解决方案

文件头

#+begin_src emacs-lisp
;;; me-multi-cursors.el --- Programming stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=iedit= 可以在多个位置同时编辑的包。它可以用来一次性编辑一个文件中的多个位置，或者在多个文件中同时编辑某些文本

#+begin_src emacs-lisp
(use-package iedit
  :straight t
  :after minemacs-lazy
  :demand t
  :preface
  (+fn-inhibit-messages! iedit-update-key-bindings))

(use-package evil-iedit-state
  :straight t
  :after iedit evil
  :demand t
  :config
  ;; Use the `iedit' key to trigger `evil-iedit-state/iedit-mode'.
  (define-key global-map iedit-toggle-key-default #'evil-iedit-state/iedit-mode))
#+end_src

=evil-mc= 的主要功能是在一个 Emacs 缓冲区中使用多个光标，用于在多个地方进行同时编辑。它的设计初衷是模仿 Sublime Text 中的多光标功能。evil-mc 可以使用类似于 Sublime Text 中的快捷键来添加或删除光标，以及在多个光标之间切换。它还支持在多个缓冲区之间进行多光标编辑，并提供了一些用于自定义光标样式的选项。

#+begin_src emacs-lisp
(use-package evil-mc
  :straight t
  :hook (minemacs-after-startup . global-evil-mc-mode)
  :config
  ;; Use "gz" instead of "gr", this last is mapped to `xref-find-references' in
  ;; some programming modes.
  (evil-define-key* '(normal visual) evil-mc-key-map (kbd "gr") nil)
  (evil-define-key* '(normal visual) evil-mc-key-map (kbd "gz") evil-mc-cursors-map)

  ;; Add support to repeat these commands when prefixed with a number
  (dolist (cmd '(evil-mc-make-and-goto-first-cursor evil-mc-make-and-goto-last-cursor
                 evil-mc-make-and-goto-prev-cursor evil-mc-make-and-goto-next-cursor
                 evil-mc-skip-and-goto-prev-cursor evil-mc-skip-and-goto-next-cursor
                 evil-mc-make-and-goto-prev-match evil-mc-make-and-goto-next-match
                 evil-mc-skip-and-goto-prev-match evil-mc-skip-and-goto-next-match))
    (advice-add
     cmd :around
     (lambda (fn)
       (dotimes (i (if (integerp current-prefix-arg) current-prefix-arg 1))
         (funcall fn)))))

  ;; Custom commands to execute with `evil-mc'
  (setq
   evil-mc-custom-known-commands
   '((backward-kill-word (:default . evil-mc-execute-default-call-with-count))
     (evil-escape (:default . evil-mc-execute-default-evil-normal-state))
     (evil-delete-back-to-indentation (:default . evil-mc-execute-default-call))
     (undo-fu-only-redo (:default . evil-mc-execute-default-redo))
     (undo-fu-only-undo (:default . evil-mc-execute-default-undo))
     (corfu-complete (:default . evil-mc-execute-default-complete))
     (evil-numbers/dec-at-pt-incremental (:default . evil-mc-execute-default-call-with-count))
     (evil-numbers/inc-at-pt-incremental (:default . evil-mc-execute-default-call-with-count))
     (evil-org-delete (:default . evil-mc-execute-default-evil-delete))
     (ess-smart-comma (:default . evil-mc-execute-call))
     (evil-digit-argument-or-evil-beginning-of-visual-line
      (:default . evil-mc-execute-default-call)
      (visual . evil-mc-execute-visual-call)))))

(use-package me-evil-mc-evil-escape
  :after evil-mc evil-escape
  :demand t)
#+end_src

=evil-multiedit= 的主要功能是进行文本匹配和替换，以及删除或插入一些文本。它的设计初衷是提供类似于 Sublime Text 的多选编辑和替换的功能。evil-multiedit 提供了一些可以用于匹配和选定多个文本区域的快捷键。它还支持使用正则表达式和 Emacs Lisp 表达式进行文本匹配和替换。

#+begin_src emacs-lisp
(use-package evil-multiedit
  :straight t
  :after iedit evil
  :demand t
  :init
  (+nvmap! :infix "g"
    "ze" '(nil :wk "evil-multiedit")
    "zem" #'evil-multiedit-match-all
    "zed" #'evil-multiedit-match-and-next
    "zeD" #'evil-multiedit-match-and-prev
    "zes" #'evil-multiedit-match-symbol-and-next
    "zeS" #'evil-multiedit-match-symbol-and-prev
    "zen" #'evil-multiedit-next
    "zeN" #'evil-multiedit-prev
    "zet" #'evil-multiedit-toggle-or-restrict-region
    "zeT" #'evil-multiedit-toggle-marker-here
    "zeq" #'evil-multiedit-abort)
  :config
  (evil-multiedit-default-keybinds))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-multi-cursors)
;;; me-multi-cursors.el ends here
#+end_src

** me-natural-langs.el
=me-natural-langs.el= 自然语言拼写翻译

文件头

#+begin_src emacs-lisp
;;; me-natural-langs.el --- Natural languages stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=Spell-fu= 是一个 Emacs 拼写检查的工具，它支持多种语言和拼写检查引擎，并且提供了许多有用的功能，比如实时检查拼写错误、推荐单词、自定义词典等,
它可以与 flyspell 配合使用，也可以直接在 buffer 中检查拼写错误。使用 Spell-fu，你可以在 Emacs 中更加方便地进行拼写检查，提高写作效率和文档质量。

#+begin_src emacs-lisp
(use-package spell-fu
  :straight t
  :preface
  (defconst +aspell-available-p (executable-find "aspell"))
  :when +aspell-available-p
  ;;:hook (text-mode . spell-fu-mode)
  :custom
  (spell-fu-directory (+directory-ensure minemacs-local-dir "spell-fu/"))
  :init
  (+map! "ts" #'spell-fu-mode)
  (+nvmap! "z=" #'+spell-fu-correct) ;; autoloaded from "me-spell-fu.el"

  (defcustom +spell-excluded-faces-alist
    '((markdown-mode
       . (markdown-code-face
          markdown-html-attr-name-face
          markdown-html-attr-value-face
          markdown-html-tag-name-face
          markdown-inline-code-face
          markdown-link-face
          markdown-markup-face
          markdown-plain-url-face
          markdown-reference-face
          markdown-url-face))
      (org-mode
       . (org-block
          org-block-begin-line
          org-block-end-line
          org-cite
          org-cite-key
          org-code
          org-date
          org-footnote
          org-formula
          org-inline-src-block
          org-latex-and-related
          org-link
          org-meta-line
          org-property-value
          org-ref-cite-face
          org-special-keyword
          org-tag
          org-todo
          org-todo-keyword-done
          org-todo-keyword-habt
          org-todo-keyword-kill
          org-todo-keyword-outd
          org-todo-keyword-todo
          org-todo-keyword-wait
          org-verbatim))
      (latex-mode
       . (font-latex-math-face
          font-latex-sedate-face
          font-lock-function-name-face
          font-lock-keyword-face
          font-lock-variable-name-face)))
    "Faces in certain major modes that spell-fu will not spellcheck."
    :group 'minemacs-ui
    :type '(repeat (cons symbol (repeat face))))

  (add-hook
   'spell-fu-mode-hook
   (defun +spell-fu--init-excluded-faces-h ()
     "Set `spell-fu-faces-exclude' according to `+spell-excluded-faces-alist'."
     (when-let (excluded (cdr (cl-find-if #'derived-mode-p +spell-excluded-faces-alist :key #'car)))
       (setq-local spell-fu-faces-exclude excluded)))))
#+end_src

=go-translate= 是一款基于 Google Translate 的 Emacs 翻译插件。它可以将当前 buffer 中的选中文本翻译成另一种语言，并将翻译结果显示在另一个 buffer 中。
TODO: 看一下怎么用

#+begin_src emacs-lisp
(use-package go-translate
  :straight (:host github :repo "lorniu/go-translate")
  :commands +gts-yank-translated-region +gts-translate-with
  :init
  (+map-local! :keymaps '(org-mode-map text-mode-map markdown-mode-map
                          tex-mode-map TeX-mode-map latex-mode-map LaTeX-mode-map)
    "t" '(nil :wk "translate")
    "tb" `(,(+cmdfy! (+gts-translate-with 'bing)) :wk "Translate with Bing")
    "td" `(,(+cmdfy! (+gts-translate-with 'deepl)) :wk "Translate with DeepL")
    "tg" `(,(+cmdfy! (+gts-translate-with 'google)) :wk "Translate with Google")
    "tr" #'+gts-yank-translated-region
    "tt" #'+gts-translate-with
    "tT" #'gts-do-translate)
  :custom
  ;; Your languages pairs
  (gts-translate-list '(("en" "zh-CN")
                        ("zh-CN" "en")))
  :config
  ;; Config the default translator, which will be used by the command `gts-do-translate'
  (setq gts-default-translator
        (gts-translator
         ;; Used to pick source text, from, to. choose one.
         :picker (gts-prompt-picker)
         ;; One or more engines, provide a parser to give different output.
         :engines (gts-google-engine :parser (gts-google-summary-parser))
         ;; Render, only one, used to consumer the output result.
         :render (gts-buffer-render)))

  ;; Custom texter which remove newlines in the same paragraph
  (defclass +gts-translate-paragraph (gts-texter) ())

  (cl-defmethod gts-text ((_ +gts-translate-paragraph))
    (when (use-region-p)
      (let ((text (buffer-substring-no-properties (region-beginning) (region-end))))
        (with-temp-buffer
          (insert text)
          (goto-char (point-min))
          (let ((case-fold-search nil))
            (while (re-search-forward "\n[^\n]" nil t)
              (replace-region-contents
               (- (point) 2) (- (point) 1)
               (lambda (&optional a b) " ")))
            (buffer-string))))))

  ;; Custom picker to use the paragraph texter
  (defclass +gts-paragraph-picker (gts-picker)
    ((texter :initarg :texter :initform (+gts-translate-paragraph))))

  (cl-defmethod gts-pick ((o +gts-paragraph-picker))
    (let ((text (gts-text (oref o texter))))
      (when (or (null text) (zerop (length text)))
        (user-error "Make sure there is any word at point, or selection exists"))
      (let ((path (gts-path o text)))
        (setq gts-picker-current-path path)
        (cl-values text path))))

  (defun +gts-yank-translated-region ()
    (interactive)
    (gts-translate
     (gts-translator
      :picker (+gts-paragraph-picker)
      :engines (gts-google-engine)
      :render (gts-kill-ring-render))))

  (defun +gts-translate-with (&optional engine)
    (interactive)
    (let* ((caption-pair (mapcar (lambda (pair) (cons (format "From %s to %s" (upcase (car pair)) (upcase (cadr pair))) pair)) gts-translate-list))
           (gts-translate-list (if (length= gts-translate-list 1)
                                   gts-translate-list
                                 (list (cdr (assoc (completing-read "Translate: " (mapcar #'car caption-pair)) caption-pair)))))
           (engine (or engine (intern (completing-read "Engine: " '(deepl google bing))))))
      (gts-translate
       (gts-translator
        :picker (+gts-paragraph-picker)
        :engines
        (cond ((eq engine 'deepl)
               (gts-deepl-engine
                :auth-key ;; Get API key from ~/.authinfo.gpg (machine api-free.deepl.com)
                (funcall
                 (plist-get (car (auth-source-search :host "api-free.deepl.com" :max 1))
                            :secret))
                :pro nil))
              ((eq engine 'bing) (gts-bing-engine))
              (t (gts-google-engine)))
        :render (gts-buffer-render))))))
#+end_src

=lexic= 是一个 Emacs 的扩展包，它提供了一个简单的界面来查询多个在线词典（如 Wiktionary、Free Dictionary 等），以及一个本地的词典查询器（基于 sdcv）。它可以用来快速查询单词的含义、拼写、发音等信息。
使用 lexic 包，你可以在 Emacs 中方便地查找单词的定义，而无需切换到浏览器或其他外部应用程序。如果你经常需要查询单词的含义或者需要翻译文本，lexic 是一个非常有用的工具。

#+begin_src emacs-lisp
(use-package lexic
  :straight t
  :preface
  (defconst +sdcv-available-p (executable-find "sdcv"))
  :when +sdcv-available-p
  :init
  (+map! :infix "s"
    "l" #'lexic-search-word-at-point
    "L" #'lexic-search)
  :config
  (+nvmap! :keymaps 'lexic-mode-map
    "q" #'lexic-return-from-lexic
    "RET" #'lexic-search-word-at-point
    "a" #'outline-show-all
    "h" `(,(+cmdfy! (outline-hide-sublevels 3)) :wk "Hide sublevels")
    "o" #'lexic-toggle-entry
    "n" #'lexic-next-entry
    "N" `(,(+cmdfy! (lexic-next-entry t)) :wk "Last entry")
    "p" #'lexic-previous-entry
    "P" `(,(+cmdfy! (lexic-previous-entry t)) :wk "First entry")
    "E" `(,(+cmdfy!
            (lexic-return-from-lexic)
            (switch-to-buffer (lexic-get-buffer)))
          :wk "Expand")
    "M" `(,(+cmdfy!
            (lexic-return-from-lexic)
            (lexic-goto-lexic))
          :wk "Minimise")
    "C-p" #'lexic-search-history-backwards
    "C-n" #'lexic-search-history-forwards
    "/" `(,(+cmdfy! (call-interactively #'lexic-search)) :wk "Search")))
#+end_src

=me-eglot-ltex=
TODO：暂时不知道干什么用的

#+begin_src emacs-lisp
;; Add this to .dir-locals.el
;; ((nil (eglot-workspace-configuration
;;        . ((ltex . ((language . "fr")
;;                    (disabledRules . ((fr . ["FRENCH_WHITESPACE"])))
;;                    (additionalRules . ((languageModel . "/usr/share/ngrams/")))))))))
(use-package me-eglot-ltex
  :after eglot
  :demand t
  :config
  (eglot-ltex-enable-handling-client-commands)
  (+eglot-register
    '(text-mode org-mode markdown-mode rst-mode latex-mode tex-mode bibtex-mode context-mode git-commit-mode)
    '("ltex-ls" "--server-type=TcpSocket" "--port" :autoport)))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-natura-langs)
;;; me-natural-langs.el ends here
#+end_src

** me-notes.el
=me-notes.el= 笔记相关

文件头

#+begin_src emacs-lisp
;;; me-notes.el --- Notes management -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=Org-roam= 用于构建个人笔记库，并以交互式图的形式呈现笔记之间的联系。Org-roam 基于 Org-mode，是 Emacs 社区中目前最热门的笔记管理工具之一。

#+begin_src emacs-lisp
(use-package org-roam
  :straight t
  :init
  (+map! :infix "n"
    "f" #'org-roam-node-find
    "r" #'org-roam-ref-find
    "i" #'org-roam-node-insert
    "R" #'org-roam-node-random
    "B" #'org-roam-buffer-display-dedicated))

(use-package org-roam-protocol
  :after org-roam
  :demand t
  :custom
  (org-roam-protocol-store-links t)
  ;; Add this as bookmarklet in your browser
  ;; javascript:location.href='org-protocol://roam-ref?template=r&ref=%27+encodeURIComponent(location.href)+%27&title=%27+encodeURIComponent(document.title)+%27&body=%27+encodeURIComponent(window.getSelection())
  (org-roam-capture-ref-templates
   '(("r" "ref" plain "%?"
      :if-new (file+head "web/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+created: %U\n\n${body}\n")
      :unnarrowed t)))
  :config
  ;; Save a local snapshot of the captured web page using "single-file-cli"
  (advice-add
   'org-roam-protocol-open-ref :after
   (defun +org-roam-protocol--single-file-snapshot-a (info)
     (+single-file
      (plist-get info :ref)
      (+file-name-incremental
       (expand-file-name
        (concat "web/snapshots/" (+clean-file-name (plist-get info :title)) ".html")
        org-roam-directory))))))

(use-package org-roam-ui
  :straight t
  :init
  (+map! "nR" #'org-roam-ui-open))

(use-package consult-org-roam
  :straight t
  :init
  (+map! :infix "n"
    "s" #'consult-org-roam-search
    "l" #'consult-org-roam-forward-links
    "b" #'consult-org-roam-backlinks
    "F" #'consult-org-roam-file-find)
  :custom
  (consult-org-roam-grep-func #'consult-ripgrep)
  (consult-org-roam-buffer-narrow-key ?r) ; custom narrow key for `consult-buffer'
  (consult-org-roam-buffer-after-buffers t)
  :config
  (consult-org-roam-mode 1)
  ;; Eventually suppress previewing for certain functions
  (consult-customize consult-org-roam-forward-links :preview-key (kbd "M-.")))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-notes)
;;; me-notes.el ends here
#+end_src

** me-org.el
=me-org.el= org tweak

文件头

#+begin_src emacs-lisp
;;; me-org.el --- Org related stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

org-mode tweak

#+begin_src emacs-lisp
(defgroup minemacs-org nil
  "MinEmacs org-mode tweaks."
  :group 'minemacs)

(use-package org
  :straight (:type built-in)
  :after minemacs-loaded
  :preface
  ;; Set to nil so we can detect user changes (in config.el)
  (setq org-directory nil)
  :custom
  (org-tags-column 0)
  (org-auto-align-tags nil)
  (org-startup-indented nil)
  (org-cycle-hide-block-startup t)
  (org-return-follows-link t) ; RET follows link (a key bind has to be defined for Evil, see below)
  (org-fold-catch-invisible-edits 'smart) ; try not to accidently do weird stuff in invisible regions
  (org-fold-core-style 'overlays) ; Fix `evil' search problem (to be used with `evil-search')
  (org-fontify-quote-and-verse-blocks t)
  (org-special-ctrl-a/e t)
  (org-insert-heading-respect-content t)
  (org-hide-emphasis-markers t)
  (org-use-property-inheritance t) ; it's convenient to have properties inherited
  (org-ellipsis " ↩")
  (org-log-done 'time) ; having the time an item is done sounds convenient
  (org-list-allow-alphabetical t) ; have a. A. a) A) list bullets
  (org-export-in-background t) ; run export processes in external emacs process
  (org-export-async-init-file (expand-file-name (concat minemacs-modules-dir "extras/me-org-export-async-init.el")))
  (org-export-with-smart-quotes t) ; convert "this" to « this »
  (org-export-with-sub-superscripts '{}) ; Only explicit _{} ^{} are interpreted as sub/superscripts
  (org-export-with-broken-links 'mark) ; Do not rise error on broken links, but mark them in the output file
  (org-highlight-latex-and-related '(native script entities))
  (org-pretty-entities t)
  (org-pretty-entities-include-sub-superscripts t)
  (org-use-sub-superscripts '{}) ; Do the same when rendering the Org buffer
  (org-edit-src-content-indentation 0) ; do not indent the content of src blocks
  (org-edit-src-turn-on-auto-save t) ; auto-save org-edit-src
  (org-edit-src-auto-save-idle-delay auto-save-timeout) ; use the defaults
  :config
  (+map-local! :keymaps 'org-mode-map
    "l"  '(nil :wk "link")
    "ll" #'org-insert-link
    "e"  #'org-export-dispatch
    "c"  #'org-edit-src-code
    "s"  '(nil :wk "babel-session")
    "sc" #'org-babel-switch-to-session-with-code
    "ss" #'org-babel-switch-to-session
    "sp" #'org-babel-pop-to-session
    "sP" #'org-babel-pop-to-session-maybe
    "sl" #'org-babel-load-in-session
    "sL" #'org-babel-load-in-session-maybe
    "si" #'org-babel-initiate-session)
  (+map-local! :keymaps 'org-src-mode-map
    "s" #'org-edit-src-save
    "q" #'org-edit-src-abort
    "e" #'org-edit-src-exit)
  (+nmap! :keymaps 'org-mode-map
    "RET" #'org-open-at-point)

  (cond
   ((executable-find "latexmk")
    (setq
     org-latex-pdf-process
     '("latexmk -c -bibtex-cond1 %f" ; ensure cleaning ".bbl" files
       "latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f")))

   ;; Tectonic can be interesting. However, it don't work right now
   ;; with some of my documents (natbib + sagej...)
   ((executable-find "tectonic")
    (setq
     org-latex-pdf-process
     '("tectonic -X compile --outdir=%o -Z shell-escape -Z continue-on-errors %f"))))

  (setq org-export-async-debug minemacs-debug) ;; Can be useful!

  ;; Dynamically change font size for Org heading levels, starting from
  ;; `+org-level-base-size', and shrinking by a factor of 0.9 at each level.
  (defvar +org-level-base-size 1.3)

  (dotimes (level 8)
    (let ((size (max 1.0 (* +org-level-base-size (expt 0.9 level)))))
      (set-face-attribute
       (intern (format "org-level-%d" (1+ level))) nil
       :weight 'bold
       :height size)))

  (org-babel-do-load-languages
   'org-babel-load-languages
   (cl-loop
    for lang in '(C R js dot awk sed sql org shell ditaa latex julia sqlite octave
                  maxima eshell scheme python fortran gnuplot plantuml makefile)
    collect (cons lang t)))

  (with-eval-after-load 'org-src
    (setq org-src-lang-modes
          (append
           '(("dot" . graphviz-dot))
           (delete (assoc "dot" org-src-lang-modes #'equal) org-src-lang-modes))))

  (with-eval-after-load 'plantuml-mode
    (setq org-plantuml-jar-path plantuml-jar-path
          org-plantuml-exec-mode plantuml-default-exec-mode
          org-plantuml-executable-path plantuml-executable-path)))

(use-package me-org-extras
  :after org
  :demand t
  :config
  (+org-extras-outline-path-setup)
  (+org-extras-pretty-latex-fragments-setup)
  (+org-extras-latex-classes-setup)
  (+org-extras-responsive-images-setup)
  (+org-extras-equation-numbering-setup)
  (+org-extras-multifiles-document-setup)
  (+org-extras-lower-case-keywords-and-properties-setup))

(use-package org-contrib
  :straight t
  :after org
  :demand t)

(use-package engrave-faces
  :straight t
  :after org)

;; Org export
(use-package ox-latex
  :after org
  :custom
  (org-latex-prefer-user-labels t)
  ;; Default `minted` options, can be overwritten in file/dir locals
  (org-latex-minted-options
   '(("frame"         "lines")
     ("fontsize"      "\\footnotesize")
     ("tabsize"       "2")
     ("breaklines"    "true")
     ("breakanywhere" "true") ;; break anywhere, no just on spaces
     ("style"         "default")
     ("bgcolor"       "GhostWhite")
     ("linenos"       "true")))
  :config
  ;; Add this to your config to be able to export with minted:
  ;; (with-eval-after-load 'ox-latex
  ;;   (add-to-list 'org-latex-packages-alist '("" "minted"))
  ;;   (add-to-list 'org-latex-packages-alist '("svgnames" "xcolor"))
  ;;   (setq org-latex-src-block-backend 'minted
  ;;         org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f")))

  ;; Map some org-mode blocks' languages to lexers supported by minted
  ;; you can see supported lexers by running this command in a terminal:
  ;; 'pygmentize -L lexers'
  (dolist (pair '((ipython    "python")
                  (jupyter    "python")
                  (scheme     "scheme")
                  (lisp-data  "lisp")
                  (conf-unix  "unixconfig")
                  (conf-space "unixconfig")
                  (authinfo   "unixconfig")
                  (gdb-script "unixconfig")
                  (conf-toml  "yaml")
                  (conf       "ini")
                  (gitconfig  "ini")
                  (systemd    "ini")))
    (unless (member pair org-latex-minted-langs)
      (add-to-list 'org-latex-minted-langs pair))))

(use-package ox-hugo
  :straight t
  :after org
  :demand t)

(use-package ox-extra
  :after org
  :demand t
  :config
  (ox-extras-activate '(latex-header-blocks ignore-headlines)))

;; Other Org features
(use-package org-appear
  :straight t
  :hook (org-mode . org-appear-mode)
  :custom
  (org-appear-inside-latex t)
  (org-appear-autokeywords t)
  (org-appear-autoentities t)
  (org-appear-autoemphasis t)
  (org-appear-autosubmarkers t)
  (org-appear-autolinks 'just-brackets)
  :config
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))

(use-package org-modern
  :straight t
  :hook (org-mode . org-modern-mode)
  :hook (org-agenda-finalize . org-modern-agenda)
  :custom-face
  ;; Force monospaced font for tags
  (org-modern-tag ((t (:inherit org-verbatim :weight regular :foreground "black" :background "LightGray" :box "black"))))
  :custom
  (org-modern-star '("◉" "○" "◈" "◇" "✳" "◆" "✸" "▶"))
  (org-modern-table-vertical 5)
  (org-modern-table-horizontal 2)
  (org-modern-list '((?+ . "➤") (?- . "–") (?* . "•")))
  (org-modern-block-fringe nil)
  (org-modern-todo-faces
   ;; Tweak colors, and force it to be monospaced, useful when using
   ;; mixed-pitch-mode.
   '(("IDEA" . (:inherit org-verbatim :weight semi-bold
                :foreground "white" :background "goldenrod"))
     ("NEXT" . (:inherit org-verbatim :weight semi-bold
                :foreground "white" :background "IndianRed1"))
     ("STRT" . (:inherit org-verbatim :weight semi-bold
                :foreground "white" :background "OrangeRed"))
     ("WAIT" . (:inherit org-verbatim :weight semi-bold
                :foreground "white" :background "coral"))
     ("KILL" . (:inherit org-verbatim :weight semi-bold
                :foreground "white" :background "DarkGreen"))
     ("PROJ" . (:inherit org-verbatim :weight semi-bold
                :foreground "white" :background "LimeGreen"))
     ("HOLD" . (:inherit org-verbatim :weight semi-bold
                :foreground "white" :background "orange"))
     ("DONE" . (:inherit org-verbatim :weight semi-bold
                :foreground "black" :background "LightGray")))))

(use-package org-agenda
  :straight (:type built-in)
  :custom
  (org-agenda-tags-column 0)
  (org-agenda-block-separator ?─)
  (org-agenda-time-grid
   '((daily today require-timed)
     (800 1000 1200 1400 1600 1800 2000)
     " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  (org-agenda-current-time-string
   "⭠ now ─────────────────────────────────────────────────"))

;; For latex fragments
(use-package org-fragtog
  :straight t
  :hook (org-mode . org-fragtog-mode)
  :custom
  (org-fragtog-preview-delay 0.2))

(use-package org-present
  :straight t
  :init
  (+map! "oP" :keymaps 'org-mode-map #'org-present)
  :config
  (setq org-present-text-scale 2.5)

  (defvar-local +org-present--vcm-params
      '(:enabled nil
        :width nil
        :center-text nil)
    "Variable to hold `visual-fill-column-mode' parameters")

  (add-hook
   'org-present-mode-hook
   (defun +org-present--on-h ()
     (setq-local
      face-remapping-alist
      '((default (:height 1.5) variable-pitch)
        (header-line (:height 2.0) variable-pitch)
        (org-document-title (:height 2.0) org-document-title)
        (org-code (:height 1.55) org-code)
        (org-verbatim (:height 1.55) org-verbatim)
        (org-block (:height 1.25) org-block)
        (org-block-begin-line (:height 0.7) org-block)))
     ;; (org-present-big)
     (org-display-inline-images)
     (org-present-hide-cursor)
     (org-present-read-only)
     (when (bound-and-true-p visual-fill-column-mode)
       (+plist-push! +org-present--vcm-params
         :enabled visual-fill-column-mode
         :width visual-fill-column-width
         :center-text visual-fill-column-center-text))
     (setq-local visual-fill-column-width 120
                 visual-fill-column-center-text t)
     (visual-fill-column-mode 1)))

  (add-hook
   'org-present-mode-quit-hook
   (defun +org-present--off-h ()
     (setq-local
      face-remapping-alist
      '((default default default)))
     ;; (org-present-small)
     (org-remove-inline-images)
     (org-present-show-cursor)
     (org-present-read-write)
     (visual-fill-column-mode -1)
     (unless (plist-get +org-present--vcm-params :enabled)
       (setq-local visual-fill-column-width (plist-get +org-present--vcm-params :width)
                   visual-fill-column-center-text (plist-get +org-present--vcm-params :center-text))
       (visual-fill-column-mode 1)))))

(use-package evil-org
  :straight t
  :hook (org-mode . evil-org-mode))

(use-package evil-org-agenda
  :after evil-org
  :demand t
  :config
  (evil-org-agenda-set-keys))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide  'me-org)
;;; me-org.el ends here
#+end_src

** me-prog.el
=me-prog.el= 编程相关

文件头

#+begin_src emacs-lisp
;;; me-prog.el --- Programming stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=Tree-sitter= 是一种用于解析源代码的工具,它可以生成一棵抽象语法树(AST),用于语法高亮、自动补全、代码重构等应用

#+begin_src emacs-lisp
(if (not (+emacs-features-p 'tree-sitter))
    ;; Use the external `tree-sitter' module
    (+load minemacs-modules-dir "obsolete/me-tree-sitter.el")

  ;; Use built-in `treesit' when available
  (use-package treesit
    :straight (:type built-in)
    :custom
    (treesit-font-lock-level 4))

  (use-package treesit-auto
    :straight (:host github :repo "renzmann/treesit-auto")
    :hook (minemacs-after-startup . global-treesit-auto-mode)
    :commands treesit-auto-install-all
    :custom
    (treesit-auto-install 'prompt)
    :init
    (+register-build-function! treesit-auto-install-all)
    :config
    ;; Install all languages when calling `treesit-auto-install-all'
    (setq treesit-language-source-alist (treesit-auto--build-treesit-source-alist))))
#+end_src

=hideif= hide-ifdef-mode，可以根据预处理指令 #ifdef、#ifndef、#else、#endif 来折叠和展开代码块，以达到在不同条件下隐藏和显示代码的目的。

#+begin_src emacs-lisp
(use-package hideif
  :straight (:type built-in)
  :init
  ;; If `me-lsp' is enabled, `lsp-semantic-tokens-mode' should do a better job,
  ;; so we don't enable `hide-ifdef-mode'.
  (unless (memq 'me-lsp minemacs-modules)
    (dolist (h '(c++-mode-hook c++-ts-mode-hook c-mode-hook c-ts-mode-hook cuda-mode-hook))
      (add-hook h #'hide-ifdef-mode)))
  :custom
  (hide-ifdef-shadow t)
  (hide-ifdef-initially t))
#+end_src


=eglot= 提供了一个通用的 Emacs 客户端来连接不同的语言服务器，比如 LSP（Language Server Protocol）服务器，以提供对编程语言的支持。这样可以在 Emacs 中使用许多高级 IDE 功能，如代码补全、代码导航、错误检查等。

#+begin_src emacs-lisp
(use-package eglot
  :straight `(:type ,(if (< emacs-major-version 29) 'git 'built-in))
  :commands +eglot-auto-enable
  :hook (eglot-managed-mode . eglot-inlay-hints-mode)
  :custom
  (eglot-autoshutdown t) ; shutdown after closing the last managed buffer
  (eglot-sync-connect 0) ; async, do not block
  (eglot-extend-to-xref t) ; can be interesting!
  (eglot-report-progress nil) ; disable annoying messages in echo area!
  :init
  ;; Register global keybinding
  (+map! :infix "c"
    "e"  '(nil :wk "eglot session")
    "ee" #'eglot
    "eA" #'+eglot-auto-enable)
  (defcustom +eglot-auto-enable-modes
    '(c++-mode c++-ts-mode c-mode c-ts-mode
      python-mode python-ts-mode
      rust-mode cmake-mode
      js-mode js-ts-mode typescript-mode typescript-ts-mode
      json-mode json-ts-mode js-json-mode)
    "Modes for which Eglot can be automatically enabled by `+eglot-auto-enable'."
    :group 'minemacs-prog
    :type '(repeat symbol))
  :config
  (defun +eglot-auto-enable ()
    "Auto-enable Eglot in configured modes in `+eglot-auto-enable-modes'."
    (interactive)
    (dolist (mode +eglot-auto-enable-modes)
      (let ((hook (intern (format "%s-hook" mode))))
        (add-hook hook #'eglot-ensure)
        (remove-hook hook #'lsp-deferred))))

  (+map! :keymaps 'eglot-mode-map
    :infix "c"
    "fF" #'eglot-format-buffer
    "d"  '(eglot-find-declaration :wk "Find declaration")
    "i"  '(eglot-find-implementation :wk "Find implementation")
    "t"  '(eglot-find-typeDefinition :wk "Find type definition")
    "a"  '(eglot-code-actions :wk "Code actions")
    "r"  '(nil :wk "refactor")
    "rr" '(eglot-rename :wk "Rename")
    "rR" '(eglot-code-action-rewrite :wk "Rewrite")
    "rf" '(eglot-code-action-quickfix :wk "Quick fix")
    "ri" '(eglot-code-action-inline :wk "Inline")
    "re" '(eglot-code-action-extract :wk "Extract")
    "ro" '(eglot-code-action-organize-imports :wk "Organize imports")
    "eq" '(eglot-shutdown :wk "Shutdown")
    "er" '(eglot-reconnect :wk "Reconnect")
    "eQ" '(eglot-shutdown-all :wk "Shutdown all")
    "w"  '(eglot-show-workspace-configuration :wk "Eglot workspace config"))

  (+eglot-register
    '(c++-mode c++-ts-mode c-mode c-ts-mode)
    '("clangd"
      "--background-index"
      "-j=12"
      "--query-driver=/usr/bin/**/clang-*,/bin/clang,/bin/clang++,/usr/bin/gcc,/usr/bin/g++"
      "--clang-tidy"
      ;; "--clang-tidy-checks=*"
      "--all-scopes-completion"
      "--cross-file-rename"
      "--completion-style=detailed"
      "--header-insertion-decorators"
      "--header-insertion=iwyu"
      "--pch-storage=memory")
    "ccls")

  ;; From: github.com/MaskRay/ccls/wiki/eglot#misc
  (defun +eglot-ccls-inheritance-hierarchy (&optional derived)
    "Show inheritance hierarchy for the thing at point.
If DERIVED is non-nil (interactively, with prefix argument), show
the children of class at point."
    (interactive "P")
    (if-let* ((res (jsonrpc-request
                    (eglot--current-server-or-lose)
                    :$ccls/inheritance
                    (append (eglot--TextDocumentPositionParams)
                            `(:derived ,(if derived t :json-false))
                            '(:levels 100) '(:hierarchy t))))
              (tree (list (cons 0 res))))
        (with-help-window "*ccls inheritance*"
          (with-current-buffer standard-output
            (while tree
              (pcase-let ((`(,depth . ,node) (pop tree)))
                (cl-destructuring-bind (&key uri range) (plist-get node :location)
                  (insert (make-string depth ?\ ) (plist-get node :name) "\n")
                  (make-text-button
                   (+ (pos-bol 0) depth) (pos-eol 0)
                   'action (lambda (_arg)
                             (interactive)
                             (find-file (eglot--uri-to-path uri))
                             (goto-char (car (eglot--range-region range)))))
                  (cl-loop for child across (plist-get node :children)
                           do (push (cons (1+ depth) child) tree)))))))
      (eglot--error "Hierarchy unavailable"))))

(use-package consult-eglot
  :straight t
  :after consult eglot
  :init
  (+map! :keymaps 'eglot-mode-map
    "cs" '(consult-eglot-symbols :wk "Symbols"))
  :config
  ;; Provide `consult-lsp' functionality from `consult-eglot', useful for
  ;; packages that relays on `consult-lsp' (like `dirvish-subtree').
  (unless (memq 'me-lsp minemacs-modules)
    (defalias 'consult-lsp-file-symbols #'consult-eglot-symbols)))
#+end_src

=eldoc= 会在编辑Lisp代码时在minibuffer中显示当前函数的签名和一些文档。
=eldoc-box= 增强了 eldoc-mode 的体验，为 eldoc-mode 提供了更好的可读性和可视化效果。在默认情况下，eldoc-mode 会在 minibuffer 中显示函数和变量的签名和文档。但是，当签名和文档很长时，可能会出现问题，因为它们会占用 minibuffer 的大部分空间。而 eldoc-box 将函数和变量的签名和文档显示在 Emacs 的当前窗口中，使用一种称为 "box" 的方式。它还提供了其他功能，例如可以调整 box 的大小、更改颜色等。

#+begin_src emacs-lisp
(use-package eldoc
  :straight (:type built-in)
  :custom
  (eldoc-documentation-strategy #'eldoc-documentation-compose))

(use-package eldoc-box
  :straight t
  :hook (prog-mode . eldoc-box-hover-at-point-mode)
  :hook (eglot-managed-mode . eldoc-box-hover-at-point-mode))
#+end_src

=cov= 它可以在Emacs中对C/C++代码的测试覆盖率进行分析，并在代码中高亮显示哪些代码行被测试覆盖到

#+begin_src emacs-lisp
(use-package cov
  :straight (:host github :repo "abougouffa/cov" :branch "feat/gcov-cmake")
  :custom
  (cov-highlight-lines t)
  :config
  (defun +cov-coverage-mode ()
    (interactive)
    (if cov-coverage-mode
        (progn
          (setq cov-coverage-mode nil)
          (message "Disabled coverage mode, showing how often lines are executed."))
      (setq cov-coverage-mode t)
      (message "Enabled coverage mode."))
    (cov-update)))
#+end_src

=compile-multi=
+ 它允许你在一个窗口中运行多个编译命令，并将它们分别输出到不同的缓冲区中。
+ 它可以提高你的工作效率，因为你可以在一个窗口中同时运行和监视多个编译任务，而不必切换到不同的窗口和缓冲区。此外，它还提供了一些方便的快捷键，以方便你快速地切换和管理不同的编译任务。

#+begin_src emacs-lisp
(use-package compile-multi
  :straight t
  :commands +project-compile-multi
  :init
  (+map! "pC" #'+project-compile-multi)
  :config
  (defun +project-compile-multi ()
    "Like `project-compile', but uses `compile-multi'."
    (declare (interactive-only compile))
    (interactive)
    (let ((default-directory (project-root (project-current t)))
          (compilation-buffer-name-function
           (or project-compilation-buffer-name-function
               compilation-buffer-name-function)))
      (call-interactively #'compile-multi))))
#+end_src

=compile= 是Emacs自带的编译命令，可以用来编译和运行各种程序。它可以在Emacs中启动一个子进程来执行编译和运行命令，并将输出显示在一个专门的 buffer 中。
通常，你可以通过 M-x compile 命令来打开 *compilation* buffer，并在其中运行你需要的编译命令，例如 make

#+begin_src emacs-lisp
(use-package compile
  :straight (:type built-in)
  :commands +toggle-burry-compilation-buffer-if-successful
  ;; Enable ANSI colors in compilation buffer
  :hook (compilation-filter . ansi-color-compilation-filter)
  :custom
  (compilation-scroll-output t) ; Keep scrolling the compilation buffer, `first-error' can be interesting
  (compilation-always-kill t) ; Always kill current compilation process before starting a new one
  (compilation-skip-visited t) ; Skip visited messages on compilation motion commands
  (compilation-window-height 12) ; Keep it readable
  :config
  ;; Integration of `compile' with `savehist'
  (with-eval-after-load 'savehist
    (add-to-list 'savehist-additional-variables 'compile-history))

  ;; Auto-close the compilation buffer if succeeded without warnings.
  ;; Adapted from: stackoverflow.com/q/11043004/3058915
  (defun +compilation--bury-if-successful-h (buf str)
    "Bury the compilation buffer if it succeeds without warnings."
    (when (and
           (string-match "compilation" (buffer-name buf))
           (string-match "finished" str)
           (not (with-current-buffer buf
                  (save-excursion
                    (goto-char (point-min))
                    (search-forward "warning" nil t)))))
      (run-with-timer
       3 nil
       (lambda (b)
         (with-selected-window (get-buffer-window b)
           (kill-buffer-and-window))
         (unless (current-message)
           (message "Compilation finished without warnings.")))
       buf)))

  (defun +toggle-burry-compilation-buffer-if-successful ()
    "Toggle auto-burying the successful compilation buffer."
    (interactive)
    (if (memq '+compilation--bury-if-successful-h compilation-finish-functions)
        (progn
          (message "Disabled burying compilation buffer.")
          (remove-hook 'compilation-finish-functions #'+compilation--bury-if-successful-h))
      (message "Enabled burying compilation buffer.")
      (add-hook 'compilation-finish-functions #'+compilation--bury-if-successful-h))))
#+end_src

=Apheleia= 是一个自动化代码格式化和修复工具，可以用于Emacs和VSCode编辑器。
它使用LSP协议，支持各种语言和格式器，并可以集成到编辑器中进行自动化格式化、保存前格式化等操作。
它的目的是提高代码质量、一致性和可读性，并减少手动格式化代码的时间和工作量。

#+begin_src emacs-lisp
(use-package apheleia
  :straight t
  :init
  (+map! "cff" #'apheleia-format-buffer)
  :config
  (dolist (alist '((lisp-data-mode . lisp-indent)
                   (emacs-lisp-mode . lisp-indent)
                   (sh-mode . shfmt)))
    (add-to-list 'apheleia-mode-alist alist)))
#+end_src

=Editorconfig= 是一种跨编辑器的文件格式，旨在通过定义和维护一致的编码风格，从而使跨多个编辑器和IDE的协作更容易。
+ 在一个项目中，您可以创建一个名为 =.editorconfig= 的文件，指定您希望项目中的各种文件的格式规则。这些规则可以是缩进类型、缩进大小、换行符类型等等。
+ 不同的编辑器和IDE都有支持EditorConfig的插件或者内置支持，能够自动识别 =.editorconfig= 文件并将其中的规则应用到项目中的相应文件。
+ =EditorConfig= 能够减轻协作过程中由于使用不同的编辑器或IDE而产生的格式差异所带来的困难。

#+begin_src emacs-lisp
(use-package editorconfig
  :straight t
  :hook (prog-mode . editorconfig-mode)
  :init
  (+map!
    "fc" '(editorconfig-find-current-editorconfig :wk "Find current EditorConfig")
    "cfe" #'editorconfig-format-buffer))
#+end_src

+ =clang-format= 是一个由 Clang 项目提供的代码格式化工具，可以自动将代码格式化为符合某个指定的格式规范。
+ =clang-format= 支持的语言非常广泛，包括 C、C++、Objective-C、Java、JavaScript、TypeScript、Swift、Protobuf、WebAssembly 等等，支持大部分常见的格式化规则，并且可以通过配置文件自定义格式化规则。
+ 在 Emacs 中，可以使用 clang-format.el 这个 package 来调用 clang-format，从而在 Emacs 中实现代码格式化的功能。

#+begin_src emacs-lisp
(use-package clang-format
  :straight t
  :init
  (+map! :keymaps '(c-mode-map c++-mode-map c-ts-mode-map c++-ts-mode-map
                    cuda-mode-map scad-mode-map)
    "cfc" #'clang-format-buffer))
#+end_src

+ =vimrc-mode=

#+begin_src emacs-lisp
;;; Modes
(use-package vimrc-mode
  :straight t
  :mode "\\.vim\\(rc\\)?\\'")
#+end_src

+ =cmake-mode= 本身提供了基本的语法高亮功能，但是 cmake-font-lock 可以增强这一功能，提供更好的语法高亮效果。
+ =cmake-font-lock= 会在 =cmake-mode= 基础上添加一些额外的语法高亮规则，如高亮变量、宏等。因此，如果你需要更好的 CMake 语法高亮效果，可以考虑使用 cmake-font-lock。

#+begin_src emacs-lisp
(use-package cmake-mode
  :straight (:host github :repo "emacsmirror/cmake-mode" :files (:defaults "*"))
  :mode "CMakeLists\\.txt\\'"
  :mode "\\.cmake\\'")

(use-package cmake-font-lock
  :straight (:host github :repo "Lindydancer/cmake-font-lock" :files (:defaults "*"))
  :hook (cmake-mode . cmake-font-lock-activate))
#+end_src

+ Rust 是一种现代的编程语言，由 Mozilla 公司的 Graydon Hoare 在 2006 年创建。它在内存安全和并发方面具有出色的表现，并且具有高度的可靠性和性能。Rust 的设计目标是成为一种具有高效性和安全性的系统级编程语言。
+ Rust 自发布以来一直受到广泛关注和使用。它在 Stack Overflow 的开发者调查中被评为“最喜欢的编程语言”和“最希望学习的编程语言”多年，并且在 TIOBE 编程语言排行榜中也一直位居前列。
+ Rust 的高可靠性、高安全性和高性能等特点，以及其逐渐成熟的生态系统，使其成为一种备受推崇的编程语言之一。

#+begin_src emacs-lisp
(use-package rust-mode
  :straight t
  :commands
  rust-compile rust-compile-release
  rust-check rust-test
  rust-run rust-run-release rust-run-clippy
  rust-format-buffer rust-goto-format-problem
  rust-enable-format-on-save
  :init
  (+map-local! :keymaps '(rust-mode-map rust-ts-mode-map)
    "c" #'rust-compile
    "C" #'rust-compile-release
    "k" #'rust-check
    "t" #'rust-test
    "r" #'rust-run
    "R" #'rust-run-release
    "y" #'rust-run-clippy
    "f" #'rust-format-buffer
    "F" #'rust-goto-format-problem
    "S" #'rust-enable-format-on-save))
#+end_src

+ =dumb-jump= 用于在代码库中快速跳转到定义、声明或引用。
+ 它不依赖于任何索引或 tags 文件，而是使用简单的搜索算法（例如 grep）来查找匹配项。
+ =dumb-jump= 支持多种编程语言，并且易于配置。它可以根据需要与其他包集成，例如 projectile 或 helm。

#+begin_src emacs-lisp
(use-package dumb-jump
  :straight t
  :commands
  +dumb-jump-hydra/body
  :custom
  (dumb-jump-selector 'completing-read)
  (dumb-jump-prefer-searcher 'rg)
  :init
  (+map!
    "cj" '(+dumb-jump-hydra/body :wk "+dumb-jump-hydra"))
  ;; Use as xref backend
  (with-eval-after-load 'xref
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate 101))
  :config
  ;; Define Hydra keybinding (from the repo's examples)
  (defhydra +dumb-jump-hydra (:color blue :columns 3)
    "Dumb Jump."
    ("j" dumb-jump-go "Go")
    ("o" dumb-jump-go-other-window "Other window")
    ("e" dumb-jump-go-prefer-external "Go external")
    ("x" dumb-jump-go-prefer-external-other-window "Go external other window")
    ("i" dumb-jump-go-prompt "Prompt")
    ("l" dumb-jump-quick-look "Quick look")
    ("b" dumb-jump-back "Back")))
#+end_src

+ =hl-todo=  用于在代码中高亮显示注释中的特殊标记。
+ 它可以用来标记TODO，FIXME，BUG等，以便更容易地找到和处理它们。
+ 它还提供了一些有用的功能，例如列表所有标记，定位到下一个或前一个标记，删除标记等。

#+begin_src emacs-lisp
(use-package hl-todo
  :straight (:host github :repo "tarsius/hl-todo")
  :hook
  (prog-mode . hl-todo-mode)
  (org-mode . hl-todo-mode)
  :config
  (setq hl-todo-keyword-faces
        (append
         hl-todo-keyword-faces
         '(("BUG" . "#ee5555")
           ("PROJ" . "#447f44")
           ("IDEA" . "#0fa050")
           ("INFO" . "#0e9030")
           ("FIX" . "#Fe0030")
           ("UNUSED" . "#8b8989")
           ("TWEAK" . "#fe9030")
           ("PERF" . "#e09030")))))
#+end_src

+ =Rainbow mode= 为代表颜色的字符串着色

#+begin_src emacs-lisp
(use-package rainbow-mode
  :straight t
  :init
  (+map! :keymaps '(prog-mode-map conf-mode-map text-mode-map)
    "tR" #'rainbow-mode))
#+end_src

+ =lua-mode=

#+begin_src emacs-lisp
(use-package lua-mode
  :straight t
  :custom
  (lua-indent-level 2))
#+end_src

=csharp-mode=

#+begin_src emacs-lisp
(use-package csharp-ts-mode
  :straight `(:type ,(if (< emacs-major-version 29) 'git 'built-in))
  :mode "\\.cs\\'"
  :custom
  (csharp-ts-mode-indent-offset 2) ; customize variables
  (imenu-generic-expression
   '(("Variables" "^\\s-*[a-zA-Z0-9._ ]* \\([a-zA-Z0-9_]*\\)\\( = \\sw*\\|\\s-*\\);$" 1)
     ("Functions" "^\\s-*[^/]* \\([a-zA-Z0-9_]+\\)(.*)\\(\\s-*.*\n\\|\\ *\\)\\s-*{" 1)
     ("Classes" "^\\s-*\\(.*\\)class +\\([a-zA-Z0-9_]+\\)" 2)
     ("Namespaces" "^namespace +\\([a-z0-9_]*\\)" 1)))
  :init
  :config
  (+eglot-register '(csharp-mode csharp-ts-mode) "omnisharp"))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-prog)
;;; me-prog.el ends here
#+end_src

** me-project.el
=me-project.el= 项目管理

文件头

#+begin_src emacs-lisp
;;; me-project.el --- Projects stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

+ =project.el= 是Emacs 27及更高版本中默认启用的项目管理库。它为项目提供了一些基本功能，例如：查找项目中的文件、列出项目中的文件等等。您可以使用project.el来创建和管理项目。
#+begin_src emacs-lisp
(use-package project
  :straight (:type built-in)
  :after minemacs-loaded
  :demand t
  :custom
  (project-list-file (concat minemacs-local-dir "project-list.el"))
  (project-vc-extra-root-markers '(".projectile.el" ".project.el" ".project"))
  (project-ignores '("*.meta" "*.prefab" "*.dll" "*.png" "*.asset"))
  :init
  ;;(+map! "."  #'project-find-file)
  (+map! :infix "p" ;; project
    "P"  #'project-switch-project
    "c"  #'project-compile
    "d"  #'project-find-dir
    "f"  #'project-find-file
    "k"  #'project-kill-buffers
    "b"  #'project-switch-to-buffer
    "a"  #'+project-add-project
    "D"  #'+dir-locals-open-or-create
    "-"  #'project-dired
    ;; compile/test
    "c" #'project-compile
    ;; run
    "r"  '(nil :wk "run")
    "re" #'project-eshell
    "rg" #'+project-gdb
    "rs" #'project-shell
    "rc" #'project-shell-command
    "rC" #'project-async-shell-command
    ;; forget
    "F"  '(nil :wk "forget/cleanup")
    "Fz" '(project-forget-zombie-projects :wk "Zombie projects")
    "Fp" '(project-forget-project :wk "Project")
    "Fu" '(project-forget-projects-under :wk "Projects under...")
    ;; search/replace
    "s"  '(nil :wk "search/replace")
    "ss" #'project-search
    "sn" '(fileloop-continue :wk "Next match")
    "sr" #'project-query-replace-regexp
    "sf" #'project-find-regexp))
#+end_src

+ =project-find-file=  project-find-file是Emacs内置的函数，用于在当前项目中查找文件
+ =consult-project-extra=  consult-project-extra-find 则是 consult-project-extra 提供的功能，可以更加智能和高效地查找项目文件，例如可以使用快速搜索和过滤来定位文件，支持使用FZF和Ripgrep等工具进行快速匹配和搜索，还可以快速地跳转到项目的版本控制系统（如git）中。
+ 此外， consult-project-extra-find 还提供了其他一些高级功能，例如可以针对不同的文件类型使用不同的外部命令，或者使用不同的搜索模式来查找文件。

#+begin_src emacs-lisp
(use-package consult-project-extra
  :straight t
  :init
  (+map!
    "." #'consult-project-extra-find
    "pp" #'consult-project-extra-find-other-window))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-project)
;;; me-project.el ends here
#+end_src

** me-rss.el
=me-rss.el= rss客户端

#+begin_src emacs-lisp
;;; me-rss.el --- News and RSS -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

+ =elfeed= 是一个用于阅读 RSS 订阅源的 Emacs 扩展。您可以使用 elfeed 在 Emacs 中管理和阅读各种博客、新闻和其他类型的 RSS 订阅。

#+begin_src emacs-lisp
(defgroup minemacs-elfeed nil
  "MinEmacs elfeed tweaks."
  :group 'minemacs)

(use-package elfeed
  :straight t
  :init
  (+map! "of" #'elfeed)
  (+nmap! :keymaps 'elfeed-search-mode-map
    "d" #'+elfeed-youtube-dl)
  (+nmap! :keymaps 'elfeed-show-mode-map
    "D" #'+elfeed-download-image)
  (defcustom +elfeed-videos-dir "~/Videos/elfeed/"
    "Directory of downloaded videos."
    :group 'minemacs-elfeed)
  (defcustom +elfeed-images-dir "~/Pictures/elfeed/"
    "Directory of downloaded pictures."
    :group 'minemacs-elfeed)
  (defcustom +yt-dlp-command (executable-find "yt-dlp")
    "The \"yt-dlp\" command."
    :group 'minemacs-tools)
  :custom
  (elfeed-db-directory (concat minemacs-local-dir "elfeed/db/"))
  (elfeed-enclosure-default-dir (concat minemacs-local-dir "elfeed/enclosure/"))
  :config
  ;; Hide the annoying index file form recent files
  (+ignore-root elfeed-db-directory elfeed-enclosure-default-dir)

  (defun +elfeed-download-image ()
    "Download the image at point."
    (interactive)
    (let ((url (get-text-property (point) 'image-url)))
      (if (not url)
          (message "No image at point!")
        (url-copy-file
         url (expand-file-name (url-file-nondirectory url)
                               (+directory-ensure +elfeed-images-dir))))))

  (defun +yt-dl-it (url)
    "Downloads the URL with \"yt-dlp\" in an async shell."
    (let ((default-directory (+directory-ensure +elfeed-videos-dir)))
      (async-shell-command (format "%s '%s'" +yt-dlp-command url))))

  (defun +elfeed-youtube-dl (&optional use-generic-p)
    "Download Youtube videos."
    (interactive "P")
    (let ((entries (elfeed-search-selected)))
      (cl-loop for entry in entries
               do (elfeed-untag entry 'unread)
               when (elfeed-entry-link entry)
               do (+yt-dl-it it))
      (mapc #'elfeed-search-update-entry entries)
      (unless (use-region-p) (forward-line)))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-rss)
;;; me-rss.el ends here
#+end_src

** me-tools.el
=me-tools.el= 工具相关

文件头

#+begin_src emacs-lisp
;;; me-tools.el --- tools stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; Should be configured in per-project basis, good documentation at:
;; github.com/cjohansson/emacs-ssh-deploy#deployment-configuration-examples

;;; Code:
#+end_src


+ =SSH-Deploy= 用于将文件通过 SSH 协议部署到远程服务器。它提供了一套方便的命令和函数，使您能够轻松地将文件同步到远程服务器上，以便在开发过程中进行实时的部署和更新。

#+begin_src emacs-lisp
(use-package ssh-deploy
  :straight t
  :hook ((after-save . ssh-deploy-after-save)
         (find-file . ssh-deploy-find-file))
  :init
  (+map! "od" '(ssh-deploy-hydra/body :wk "ssh-deploy"))
  :config
  (ssh-deploy-hydra "C-c C-z"))
#+end_src

+ =TLDR= (Too Long; Didn't Read) 是一个命令行工具，提供了简洁和易于理解的命令行指南。它的目标是以简洁的方式呈现常用命令的用法和示例，以便用户能够快速查阅和理解命令的功能和用法。

#+begin_src emacs-lisp
(use-package tldr
  :straight t
  :init
  (+map! "ht" #'tldr)
  :custom
  (tldr-enabled-categories '("common" "linux" "osx")))
#+end_src

+ =vterm= 它提供了在 Emacs 中运行交互式终端会话的功能。vterm 基于 libvterm 库，支持终端的基本功能，包括命令行编辑、光标移动、颜色显示、文本选择等。
+ =multi-vterm= 它建立在 vterm 的基础上，提供了在 Emacs 中管理多个终端会话的能力。它使得同时打开和切换多个 vterm 窗口变得更加便捷和高效。
UNUSED: 使用 =i3wm= 不需要在emacs中使用终端

#+begin_src emacs-lisp :tangle no
(use-package vterm
  :straight t
  :init
  (+map!
    "ot" '(nil :wk "vterm")
    "otT" #'vterm)
  ;; Hide vterm install window
  (add-to-list
   'display-buffer-alist
   `(" \\*Install vterm\\*"
     (display-buffer-no-window)
     (allow-no-window . t)))
  (+register-build-function! vterm-module-compile)
  :custom
  (vterm-always-compile-module t)
  (vterm-max-scrollback 5000)
  (vterm-tramp-shells '(("docker" "/bin/bash")))
  :config
  (define-key vterm-mode-map [return] #'vterm-send-return))

(use-package multi-vterm
  :straight t
  :init
  (+map!
    "ott" #'multi-vterm
    "otd" #'multi-vterm-dedicated-toggle
    "otp" #'multi-vterm-project)
  ;; Show at buttom
  (add-to-list
   'display-buffer-alist
   `("\\*vterminal - .*\\*" ;; multi-vterm-project / dedicated
     (display-buffer-reuse-window display-buffer-in-direction)
     (direction . bottom)
     (dedicated . t)
     (reusable-frames . visible)
     (window-height . 0.3)))
  :custom
  (multi-vterm-dedicated-window-height-percent 30)
  :config
  (+nvmap!
    :keymaps 'vterm-mode-map
    ",c" #'multi-vterm
    ",n" #'multi-vterm-next
    ",p" #'multi-vterm-prev
    "<return>" #'evil-insert-resume))
#+end_src

+ =docker= 相关

#+begin_src emacs-lisp
(use-package docker
  :straight t
  :init
  (+map! "ok" #'docker))

(use-package docker-compose-mode
  :straight t)

(if (+emacs-features-p 'tree-sitter)
    ;; Emacs 29 comes with `dockerfile-ts-mode'
    (use-package dockerfile-ts-mode
      :straight (:type built-in)
      :mode "/Dockerfile\\'")
  (use-package dockerfile-mode
    :straight t))
#+end_src

+ =systemd= Major mode for editing systemd units.
#+begin_src emacs-lisp
(use-package systemd
  :straight t)
#+end_src

UNUSED: 暂时用不到
+ =pkgbuild-mode= 是一个用于编辑 PKGBUILD 文件的 Emacs 模式。PKGBUILD 是 Arch Linux 发行版中用于构建软件包的脚本文件，其中包含了软件包的构建、安装和配置信息。

#+begin_src emacs-lisp :tangle no
(use-package pkgbuild-mode
  :straight t
  :config
  (+map-local! :keymaps 'pkgbuild-mode-map
    "b" #'pkgbuild-makepkg
    "a" #'pkgbuild-tar
    "r" #'pkgbuild-increase-release-tag
    "u" #'pkgbuild-browse-url
    "m" #'pkgbuild-update-sums-line
    "s" #'pkgbuild-update-srcinfo
    "e" #'pkgbuild-etags))
#+end_src

+ =journalctl-mode= 是一个用于查看和编辑 systemd 日志的 Emacs 模式。它提供了在 Emacs 中浏览和搜索 systemd journal 的功能，并以可读的方式显示日志消息。

#+begin_src emacs-lisp
(use-package journalctl-mode
  :straight t
  :config
  (+map-local! :keymaps 'journalctl-mode-map
    "J" #'journalctl-next-chunk
    "K" #'journalctl-previous-chunk))
#+end_src

TODO: 自定义日志格式还是有点问题
=logview= 是一个 Emacs 包，用于在 Emacs 中浏览和过滤日志文件。它提供了一套交互式的界面和工具，使您可以方便地查看和分析日志数据。

#+begin_src emacs-lisp
(use-package logview
  :straight t
  :custom
  (logview-views-file (concat minemacs-local-dir "logview-views.el"))
  (logview-cache-filename (concat minemacs-cache-dir "logview-cache.el"))
  :config
  (setq logview-additional-level-mappings
        '(("SkynetFramework"
           (error       "[E]")
           (warning     "[W]")
           (information "[I]")
           (debug       "[D]")
           (trace       "[T]")
           (aliases "Skynet")))

        logview-additional-timestamp-formats
        '(("SkynetFramework"
           (java-pattern . "dd/MM/yy HH:mm:ss.SS")
           (datetime-options :any-decimal-separator t)
           (aliases "Skynet")))

        logview-additional-submodes
        '(("SkynetFramework"
           (format . "TIMESTAMP LEVEL MESSAGE")
           (levels . "RobotFramework")
           (timestamp "RobotFramework")
           (aliases "Skynet")))))
#+end_src

+ =TRAMP= (Transparent Remote Access, Multiple Protocols) 用于在 Emacs 中透明地访问和编辑远程文件。它允许您使用 Emacs 的编辑功能与远程主机交互，就像在本地文件上一样。

#+begin_src emacs-lisp
(use-package tramp
  :straight (:type built-in)
  :init
  ;; This is faster than the default "scp"
  (unless os/win
    (setq tramp-default-method "ssh"))
  :custom
  (tramp-default-remote-shell "/bin/bash"))
#+end_src

+ =bitwarden= 密码管理

#+begin_src emacs-lisp
(use-package bitwarden
  :straight (:host github :repo "seanfarley/emacs-bitwarden")
  :preface
  (defconst +bitwarden-available-p (executable-find "bw"))
  :when +bitwarden-available-p
  :custom
  (bitwarden-automatic-unlock
   (lambda ()
     (require 'auth-source)
     (if-let* ((matches (auth-source-search :host "bitwarden.com" :max 1))
               (entry (nth 0 matches))
               (email (plist-get entry :user))
               (pass (plist-get entry :secret)))
         (progn
           (setq bitwarden-user email)
           (if (functionp pass) (funcall pass) pass))
       ""))))
#+end_src

+ =screenshot= 图形界面下精美的代码截图工具 结合了上传到黑洞的工具

#+begin_src emacs-lisp
(defun g-screenshot-on-buffer-creation ()
  (setq display-fill-column-indicator-column nil)
  (setq line-spacing nil))

(use-package screenshot
  :straight (:type git :host github :repo "tecosaur/screenshot")
  :config
  (setq screenshot-line-numbers-p nil)
  (setq screenshot-min-width 120)
  (setq screenshot-max-width 300)
  (setq screenshot-truncate-lines-p nil)
  (setq screenshot-text-only-p nil)
  (setq screenshot-font-size 10)
  (setq screenshot-border-width 16)
  (setq screenshot-upload-fn "upload %s 2>/dev/null")
  ;;(setq screenshot-radius 0)
  ;; (setq screenshot-shadow-radius 0)
  ;; (setq screenshot-shadow-offset-horizontal 0)
  ;; (setq screenshot-shadow-offset-vertical 0)
  :hook
  ((screenshot-buffer-creation . g-screenshot-on-buffer-creation)))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-tools)
;;; me-tools.el ends here
#+end_src

** me-tty.el
=me-tty.el= emacs 终端

文件头

#+begin_src emacs-lisp
;;; me-tty.el --- Emacs from terminal -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

+ =xt-mouse= 是 Emacs 内置的一个功能，用于在终端环境中启用鼠标操作。=在终端中运行 Emacs 时，默认情况下是没有鼠标支持的，通过启用 xt-mouse，你可以在终端中使用鼠标进行一些操作，如点击、拖拽、滚动等。

#+begin_src emacs-lisp
(use-package xt-mouse
  :straight (:type built-in)
  :hook (tty-setup . xterm-mouse-mode))
#+end_src

+ =xclip= Emacs 在终端环境中使用 xclip 命令进行剪贴板操作。

#+begin_src emacs-lisp
(use-package xclip
  :straight t
  :hook (tty-setup . +xclip--enable-in-tty-h)
  :config
  (defun +xclip--enable-in-tty-h ()
    (with-demoted-errors "%s" (xclip-mode 1))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-tty)
;;; me-tty.el ends here
#+end_src

** me-ui.el
=me-ui.el= 界面相关

文件头

#+begin_src emacs-lisp
;;; me-ui.el --- UI stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

+ =svg-lib= 用于在 Emacs 中显示和操作 SVG（可缩放矢量图形）图标。它提供了一组函数和命令，使得在 Emacs 中使用 SVG 图标变得更加方便。

#+begin_src emacs-lisp
(use-package svg-lib
  :straight t
  :custom
  (svg-lib-icons-dir (concat minemacs-cache-dir "svg-lib/icons/")))
#+end_src

=visual-fill-column=

#+begin_src emacs-lisp
(use-package visual-fill-column
  :straight t
  :custom
  (visual-fill-column-width nil)
  (visual-fill-column-center-text t))
#+end_src

=mixed-pitch= 它提供了在 Emacs 缓冲区中使用不同字体宽度的能力，以实现更好的阅读体验。传统的等宽字体在编辑代码等文本时非常有用，但对于阅读长段落的文章或文档可能不够理想。mixed-pitch 允许你在 Emacs 缓冲区中使用变宽字体来提高可读性。
当启用 mixed-pitch 后，你可以为特定的文本模式或缓冲区设置一个变宽字体，该字体将用于显示文本内容。这样，你就可以享受到变宽字体的优点，例如更好的字母间距和更舒适的阅读体验，同时仍保留等宽字体在代码编辑中的优势。
mixed-pitch 提供了一些自定义选项，你可以根据自己的喜好进行调整。你可以设置默认的变宽字体，也可以为特定的模式或缓冲区设置自定义的变宽字体。此外，你还可以调整行间距、对齐方式等样式设置，以满足个人的偏好和需求。
总的来说，mixed-pitch 可以提供更好的阅读体验，尤其是在阅读长文本时。希望这个简介对你有帮助。如有其他问题，请随时提问。

#+begin_src emacs-lisp
(use-package mixed-pitch
  :straight t
  :init
  (+map! "tm" #'mixed-pitch-mode)
  :custom
  (mixed-pitch-variable-pitch-cursor 'box)
  :config
  (setq mixed-pitch-fixed-pitch-faces
        (delete-dups
         (append mixed-pitch-fixed-pitch-faces
                 '(org-date
                   org-footnote
                   org-drawer
                   org-special-keyword
                   org-property-value
                   org-column-title
                   org-column
                   org-cite
                   org-cite-key
                   org-ref-cite-face
                   org-tag
                   org-table
                   org-tag-group
                   org-formula
                   org-meta-line
                   org-document-info-keyword
                   org-block
                   org-block-begin-line
                   org-block-end-line
                   org-inline-src-block
                   org-src
                   org-verbatim
                   org-code
                   org-quote
                   org-verse
                   org-latex-and-related
                   org-macro
                   org-link
                   org-sexp-date
                   org-todo
                   org-done
                   font-lock-comment-face
                   font-lock-comment-delimiter-face)))))
#+end_src

+ =writing-mode= 书写模式同时开启mixed-pitch 更美观的阅读

#+begin_src emacs-lisp
(use-package me-writing-mode
  :init
  (+map! "tw" #'+writing-mode))
#+end_src

+ =page-break-lines= 用于在缓冲区中显示页面分隔符线，以模拟页面分页的效果。
+ 当你浏览或编辑包含多个页面内容的文档时，page-break-lines 可以在每个页面的末尾插入可见的分隔符线，以增强可视化效果。
+ 默认情况下，page-break-lines 使用一条虚线作为页面分隔符线，并根据窗口的宽度自动调整分隔符线的长度。你可以根据需要自定义分隔符线的样式，例如使用实线或自定义字符，以及调整线的颜色、宽度和间距等设置。
#+begin_src emacs-lisp
(use-package page-break-lines
  :straight t
  :hook ((prog-mode text-mode special-mode) . page-break-lines-mode))
#+end_src

=focus-mode= 用于提供专注模式（focus mode）的功能。它旨在帮助用户在写作或工作时集中注意力，减少干扰并提高专注度。

#+begin_src emacs-lisp
(use-package focus
  :straight t
  :init
  (+map! "tF" #'focus-mode))
#+end_src

=nerd-icons-ibuffer= 在ibuffer显示icons

#+begin_src emacs-lisp
(use-package nerd-icons-ibuffer
  :straight t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-ui)
;;; me-ui.el ends here
#+end_src

** me-undo.el
=me-undo.el= undo 和 redo

文件头

#+begin_src emacs-lisp
;;; me-undo.el --- Undo -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

+ =vundo= 是一个用于撤销和重做操作的插件，它扩展了 Vim 的撤销系统，提供了更强大的撤销和重做功能。它可以跟踪编辑会话的历史记录，包括文本更改、光标位置、窗口布局等，并允许您在编辑过程中回溯和重做这些操作。

#+begin_src emacs-lisp
;; Visual Undo
(use-package vundo
  :straight t
  :init
  (+map! "ou" #'vundo)
  :custom
  (vundo-compact-display t)
  (vundo-window-max-height 8)
  (vundo-glyph-alist vundo-unicode-symbols))
#+end_src

+ =undo-fu= 是一个用于增强 Vim 撤销系统的插件。它提供了更灵活和强大的撤销和重做功能，使您能够更好地管理和控制您的编辑历史记录。
+ =undo-fu-session= 是一个 Emacs 插件，用于管理撤销会话。它可以保存和恢复 Emacs 中的撤销历史，允许您在重新启动 Emacs 后继续撤销和重做操作。
#+begin_src emacs-lisp
(use-package undo-fu
  :straight t
  :after minemacs-loaded
  :demand t
  :config
  (with-eval-after-load 'evil
    (setq evil-undo-system 'undo-fu)
    (evil-set-undo-system 'undo-fu)))

(use-package undo-fu-session
  :straight t
  :after undo-fu
  :demand t
  :custom
  (undo-fu-session-compression (if (executable-find "zstd") 'zst 'gz))
  (undo-fu-session-directory (concat minemacs-local-dir "undo-fu-session/"))
  :config
  (global-undo-fu-session-mode 1))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-undo)
;;; me-undo.el ends here
#+end_src

** me-vc.el
=me-ve.el= 代码版本管理

文件头

#+begin_src emacs-lisp
;;; me-vc.el --- Git and version control -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

+ =Magit= 是一个用于 Git 版本控制的 Emacs 插件，它提供了一套强大的界面和工具，使得在 Emacs 中进行 Git 操作变得更加方便和高效。
+ 您可以在 Emacs 中执行 Git 命令、查看和比较提交、分支、标签等，进行分支合并、重置、回滚等操作，以及提交和推送代码等常见的 Git 操作。
+ =Magit= 还提供了一些额外的功能，如代码提交信息编辑、补丁管理、日志查看等。它与 Emacs 的其他功能和插件集成得很好，例如与代码编辑模式的集成、与项目管理工具的集成等，使得在开发过程中使用 Git 变得更加无缝和流畅。

#+begin_src emacs-lisp
(use-package magit
  :straight t
  :init
  (+map! :infix "g"
    "g" #'magit-status
    "C" #'magit-clone
    "b" #'magit-blame
    "l" #'magit-log
    "d" #'magit-diff-dwim
    "s" #'magit-stage
    "i" #'magit-init)
  :custom
  (magit-diff-refine-hunk t)
  (magit-revision-show-gravatars t)
  (magit-save-repository-buffers nil)
  ;; Show in new window
  (magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1))
#+end_src

=magit-todos= 是 Magit 的一个插件，它可以帮助您在 Git 存储库中查找和管理待办事项。

#+begin_src emacs-lisp
(use-package magit-todos
  :straight t
  :after magit
  :demand t
  :config
  (magit-todos-mode 1))
#+end_src

=magit-imerge= 是一个与 magit 集成的插件，用于进行 Git 中的交互式合并（Interactive Merging）。它提供了一个用户界面，让您可以更方便地进行合并操作
#+begin_src emacs-lisp
(use-package magit-imerge
  :straight t)
#+end_src

+ closql 是一个 Emacs 包，用于在 EmacSQL 数据库中存储和检索 EIEIO 对象（Emacs Lisp 中的对象系统）。它使用 SQLite 作为后端数据库。
+ EIEIO（Emacs Lisp Object System）是Emacs中的一种面向对象编程系统。它提供了一套类和对象的概念，允许开发者使用面向对象的编程风格来组织和管理代码。

#+begin_src emacs-lisp
(use-package closql
  :straight t)
#+end_src

=Forge= 和 =Magit= 都是 Emacs 中与 Git 和 GitHub 集成的包，但它们的功能和重点略有不同。
Magit 是一个强大的 Git 客户端，它提供了全面的 Git 操作支持，使您可以在 Emacs 中管理和操作 Git 存储库。Magit 提供了直观的界面，可以浏览和修改提交历史、分支、标签等，并支持提交、拉取、推送、合并等操作。它使得在 Emacs 中进行 Git 工作变得非常方便和高效。
Forge 则是建立在 Magit 之上的一个包，它提供了与 GitHub 的集成功能。Forge 允许您在 Emacs 中与 GitHub 存储库进行交互，包括查看和处理问题、处理拉取请求、浏览存储库文件等。Forge 扩展了 Magit 的功能，使您可以直接在 Emacs 中完成与 GitHub 相关的工作，而无需切换到浏览器或其他工具。

#+begin_src emacs-lisp
(use-package forge
  :straight t
  :after magit
  :demand t
  :preface
  ;; Keybindings will be overriten by `evil-collection'
  (setq forge-add-default-bindings nil)
  :init
  (+map! :infix "g"
    "f" '(nil :wk "forge")
    "ff" #'forge-dispatch
    "fc" #'forge-create-post
    "fe" #'forge-edit-post
    "ft" #'forge-edit-topic-title
    "fs" #'forge-edit-topic-state
    "fd" #'forge-edit-topic-draft)
  :custom
  (forge-database-connector (if (+emacs-features-p 'sqlite3) 'sqlite-builtin 'sqlite))
  (forge-database-file (concat minemacs-local-dir "forge/database.sqlite")))
#+end_src

+ =Emojify= 是一个 Emacs 包，用于在 Emacs 中显示和处理表情符号（Emojis）。它可以将文本中的表情符号替换为相应的图标，并且还提供了一些有用的功能来管理和插入表情符号。
+ =Emojify= 使用 Unicode 字符来表示表情符号，并提供了一个预定义的表情符号集合。当你编辑或查看包含表情符号的文本时，Emojify 可以自动将其替换为相应的图标，使文本更加生动和有趣。
+ =Emojify= 还提供了一些交互命令，使你可以快速搜索和插入表情符号。你可以使用命令来浏览可用的表情符号列表，并选择要插入的符号。
+ =Emojify= 包的使用可以增加在 Emacs 中处理文本时的乐趣和个性化，尤其在聊天、编写注释或编辑包含表情符号的文档时非常有用。

#+begin_src emacs-lisp
(use-package emojify ;; Needed by `code-review'
  :straight t
  :custom
  (emojify-emoji-set "emojione-v2.2.6")
  (emojify-emojis-dir (concat minemacs-cache-dir "emojify/emojis/"))
  (emojify-display-style 'image)
  (emojify-download-emojis-p t)
  :init
  (when (< emacs-major-version 29)
    (+map! "ie" '(emojify-insert-emoji :wk "Emoji"))))
#+end_src

+ =code-review= 包是一个用于在 Emacs 中进行代码审查的工具。它提供了一组功能和界面，使你能够在 Emacs 中查看、评论和处理代码审查请求。

#+begin_src emacs-lisp
(use-package code-review
  :straight (:host github :repo "phelrine/code-review" :branch "fix/closql-update")
  :after magit
  :demand t
  :custom
  (code-review-download-dir (concat minemacs-cache-dir "code-review/"))
  (code-review-db-database-file (concat minemacs-local-dir "code-review/database.sqlite"))
  (code-review-log-file (concat minemacs-local-dir "code-review/code-review-error.log"))
  (code-review-auth-login-marker 'forge) ; use the same credentials as forge in ~/.authinfo.gpg
  :init
  (with-eval-after-load 'magit
    (transient-append-suffix 'magit-merge "i"
      '("y" "Review pull-request" code-review-forge-pr-at-point)))
  (with-eval-after-load 'forge
    (transient-append-suffix 'forge-dispatch "c u"
      '("c r" "review pull-request" code-review-forge-pr-at-point))))
#+end_src

=diff-hl= 用于在代码编辑器中显示版本控制系统（如 Git）的差异信息。它会在代码的左侧边栏或行号处以不同的颜色或符号显示文件中的差异部分，让你更容易地识别出哪些行发生了更改、添加或删除。

#+begin_src emacs-lisp
(use-package diff-hl
  :straight t
  :hook (find-file . diff-hl-mode)
  :hook (dired-mode . diff-hl-dired-mode)
  :hook (vc-dir-mode . diff-hl-dir-mode)
  :hook (diff-hl-mode . diff-hl-flydiff-mode)
  :init
  (+map! "gs" #'diff-hl-stage-current-hunk)
  :custom
  (diff-hl-draw-borders nil)
  :config
  (add-hook 'magit-pre-refresh-hook #'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))
#+end_src

=git-timemachine= 是一个用于在 Emacs 中浏览 Git 仓库历史的包。它提供了一个类似于时间机器的界面，允许你逐步回溯和比较 Git 仓库中的不同版本。

#+begin_src emacs-lisp
(use-package git-timemachine
  :straight t
  :init
  (+map! "gt" #'git-timemachine-toggle)
  :custom
  (git-timemachine-show-minibuffer-details t))
#+end_src

这段代码使用了 Emacs 中的 =git-commit= 包，并配置了一些选项和钩子函数来强制执行 Git 提交规范。
+ 限制提交信息的摘要行长度不超过 50 个字符。
+ 在创建新的提交信息时可以直接进行编辑
+ 置局部变量 fill-column 的值为 72，将提交信息编辑缓冲区的行宽限制为 72 个字符。
+ 需要检查的 Git 提交风格约定，如过长的摘要行和非空的第二行。

#+begin_src emacs-lisp
;; Enforce git commit conventions.
;; See: chris.beams.io/posts/git-commit/
(use-package git-commit
  :after magit
  :demand t
  :custom
  (git-commit-summary-max-length 50)
  (git-commit-style-convention-checks '(overlong-summary-line non-empty-second-line))
  :config
  (add-hook
   'git-commit-mode-hook
   (defun +git-gommit--set-fill-column-h ()
     (setq-local fill-column 72)))
  (add-hook
   'git-commit-setup-hook
   ;; Enter evil-insert-state for new commits
   (defun +git-commit--enter-evil-insert-state-maybe-h ()
     (when (and (bound-and-true-p evil-mode)
                (not (evil-emacs-state-p))
                (bobp)
                (eolp))
       (evil-insert-state))))
  (global-git-commit-mode 1))
#+end_src


=git-modes= 提供了用于 Git 相关文件的模式和功能。
它包含以下几个模式：
+ git-commit-mode：用于编辑 Git 提交消息的模式 提供了一些快捷键和辅助功能来编写符合约定的提交消息。
+ git-rebase-mode：用于进行 Git 变基操作的模式 提供了一些快捷键和辅助功能来编辑和管理变基操作。
+ gitignore-mode：用于编辑 Git 忽略文件（例如.gitignore）的模式 提供了语法高亮和辅助功能来编辑和管理忽略规则。

#+begin_src emacs-lisp
(use-package git-modes
  :straight t
  :init
  :mode ("/.dockerignore\\'" . gitignore-mode))
#+end_src

=ediff=
+ ediff-split-window-function 设置为 split-window-horizontally，表示使用水平分割窗口来显示比较结果。
+ ediff-window-setup-function 设置为 ediff-setup-windows-plain，表示在同一个框架中设置所有窗口，而不是创建新的框架来显示比较结果。
接下来定义了一个变量 +ediff--saved-window-config，用于保存当前窗口配置。
在 ediff 启动之前，通过 ediff-before-setup-hook 钩子，将当前窗口配置保存到 +ediff--saved-window-config。
另外，还添加了两个钩子 ediff-quit-hook 和 ediff-suspend-hook，当退出或挂起 ediff 时，会执行函数 +ediff--restore-window-config-h，将保存的窗口配置恢复到之前的状态。
这样的配置使得 ediff 在水平分割窗口并在同一框架中显示比较结果，同时还可以在退出或挂起时恢复之前的窗口配置。

#+begin_src emacs-lisp
(use-package ediff
  :straight (:type built-in)
  :custom
  ;; Split horizontally
  (ediff-split-window-function #'split-window-horizontally)
  ;; Setup all windows in one frame
  (ediff-window-setup-function #'ediff-setup-windows-plain)
  :config
  (defvar +ediff--saved-window-config nil)

  ;; Save the current window configuration
  (add-hook
   'ediff-before-setup-hook
   (defun +ediff--save-window-config-h ()
     (setq +ediff--saved-window-config (current-window-configuration))))

  ;; Restore the saved window configuration on quit or suspend
  (dolist (hook '(ediff-quit-hook ediff-suspend-hook))
    (add-hook
     hook
     (defun +ediff--restore-window-config-h ()
       (when (window-configuration-p +ediff--saved-window-config)
         (set-window-configuration +ediff--saved-window-config)))
     101)))
#+end_src

=smerge-mode= 是 Emacs 中用于解决代码冲突的工具。它可以在 Git 或其他版本控制系统中发生代码冲突时使用。
当你在编辑一个文件时，如果发生代码冲突，Emacs 会自动进入 smerge-mode。在 smerge-mode 中，冲突的代码块会被高亮显示，并且你可以使用一系列命令来处理冲突，如合并代码块、接受当前版本或其他版本的修改等。

#+begin_src emacs-lisp
(use-package smerge-mode
  :straight t
  :init
  (+map! "gm" '(+smerge-hydra/body :wk "sMerge"))
  :config
  (defhydra +smerge-hydra (:hint nil
                                 :pre (if (not smerge-mode) (smerge-mode 1))
                                 ;; Disable `smerge-mode' when quitting hydra if
                                 ;; no merge conflicts remain.
                                 :post (smerge-auto-leave))
    "
                                                         [smerge]
  Movement   Keep           Diff              Other         │
  ╭─────────────────────────────────────────────────────────╯
  │  ^_g_^       [_b_] base       [_<_] upper/base    [_C_] Combine
  │  ^_C-k_^     [_u_] upper      [_=_] upper/lower   [_r_] resolve
  │  ^_k_ ↑^     [_l_] lower      [_>_] base/lower    [_R_] remove
  │  ^_j_ ↓^     [_a_] all        [_H_] hightlight    [_n_] next in project
  │  ^_C-j_^     [_RET_] current  [_E_] ediff
  │  ^_G_^                                                 [_q_] quit
  ╰─────────────────────────────────────────────────────╯
"
    ("g" (progn (goto-char (point-min)) (smerge-next)))
    ("G" (progn (goto-char (point-max)) (smerge-prev)))
    ("C-j" smerge-next)
    ("C-k" smerge-prev)
    ("j" next-line)
    ("k" previous-line)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("H" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("R" smerge-kill-current)
    ;; Often after calling `smerge-vc-next-conflict', the cursor will land at
    ;; the bottom of the window
    ("n" (progn (smerge-vc-next-conflict) (recenter-top-bottom (/ (window-height) 8))))
    ("q" nil :color blue)))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-vc)
;;; me-vc.el ends here
#+end_src

** me-window.el
=me-window.el= 窗口相关

文件尾

#+begin_src emacs-lisp
;;; me-window.el --- Windows and frames -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; Window configuration for special windows.
;; This section inspired by the article "Demystifying Emacs’s Window Manager" found here:
;; www.masteringemacs.org/article/demystifying-emacs-window-manager

;;; Code:
#+end_src

=window-adjust= 窗口平衡

#+begin_src emacs-lisp
(+deferred!
 (add-to-list
  'display-buffer-alist
  `(,(rx (seq "*" (or "Help" (seq "helpful" (zero-or-more not-newline))) "*"))
    (display-buffer-reuse-window display-buffer-pop-up-window)
    (inhibit-same-window . t)))

 ;; Show *Warnings* at bottom
 (add-to-list
  'display-buffer-alist
  `("*Warnings*"
    (display-buffer-reuse-window display-buffer-in-direction)
    (direction . bottom) ;; bottom (above below...)
    (dedicated . t) ;; Close when finished
    (reusable-frames . visible) ;;
    (window-height . 10)))

 ;; Show dictionary definition and completion buffer on the right side
 (add-to-list
  'display-buffer-alist
  `(,(rx (seq "*" (or "Dictionary" "lexic" "Completions") "*"))
    (display-buffer-in-side-window)
    (side . right)
    (window-width . 82)))

 (add-to-list
  'display-buffer-alist
  `(,(rx (seq "*" (or "eshell" "vterm" "terminal") "*"))
    ;; (display-buffer-reuse-window display-buffer-at-bottom)
    (display-buffer-reuse-window display-buffer-in-direction)
    (direction . bottom) ;; bottom (above below...)
    (dedicated . t) ;; Close when finished
    (reusable-frames . visible) ;;
    (window-height . 0.3)))

 (setq frame-title-format
       '(""
         (:eval
          (if (and
               (bound-and-true-p org-roam-directory)
               (string-prefix-p
                (expand-file-name org-roam-directory)
                (expand-file-name (or buffer-file-name ""))))
              (replace-regexp-in-string ".*/[0-9]*-?" "☰ "
               (subst-char-in-string ?_ ?\s buffer-file-name))
            "%b"))
         (:eval
          (let ((proj
                 (ignore-errors
                   (cond
                    ((featurep 'projectile)
                     (projectile-project-name))
                    (t
                     (or
                      (project-name (project-current))
                      (file-name-nondirectory
                       (string-trim-right (expand-file-name (vc-root-dir)) "/"))))))))
           (concat
            (if (buffer-modified-p) " ○" " ●")
            (when (and proj (not (string= proj "-")))
             (format " %s" proj)))))))

 ;; Adapted from: github.com/Phundrak/dotfiles/blob/master/org/config/emacs.org
 (with-eval-after-load 'hydra
   (defhydra +window-adjust-size (:hint nil :foreign-keys warn)
     "
^Zoom^                                ^Other
^^^^^^^-----------------------------------------
[_t_/_s_] shrink/enlarge vertically   [_q_] quit
[_c_/_r_] shrink/enlarge horizontally
"
     ("q" nil :exit t)
     ("c" shrink-window-horizontally)
     ("t" enlarge-window)
     ("s" shrink-window)
     ("r" enlarge-window-horizontally))

   (+map!
     :infix "w"
     "a" '(+window-adjust-size/body :wk "Adjust window size"))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-window)
;;; me-window.el ends here
#+end_src

* modules/extras/
:properties:
:path:     ~/.emacs.d/modules/extras/
:end:
=modules/extra= 一些扩展

** me-gdb.el

文件头

#+begin_src emacs-lisp
;;; me-gdb.el --- Extra tweaks for GDB, and opt-in emacs-gdb integration -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

+ =autoload funcitons=

#+begin_src emacs-lisp
(defun +gdb--set-layout (&optional c-buffer)
  ;; from stackoverflow.com/q/39762833/846686
  (set-window-dedicated-p (selected-window) nil) ;; unset dedicate state if needed
  (switch-to-buffer gud-comint-buffer)
  (delete-other-windows) ;; clean all

  (let* ((c-buffer (or c-buffer (window-buffer (selected-window)))) ;; save original buffer
         (w-source (selected-window)) ;; left top
         (w-gdb (split-window w-source nil 'right)) ;; right bottom
         (w-locals (split-window w-gdb nil 'above)) ;; right middle bottom
         (w-stack (split-window w-locals nil 'above)) ;; right middle top
         (w-breakpoints (split-window w-stack nil 'above)) ;; right top
         (w-io (split-window w-source (floor(* 0.9 (window-body-height))) 'below))) ;; left bottom
    (set-window-buffer w-io (gdb-get-buffer-create 'gdb-inferior-io))
    (set-window-dedicated-p w-io t)
    (set-window-buffer w-breakpoints (gdb-get-buffer-create 'gdb-breakpoints-buffer))
    (set-window-dedicated-p w-breakpoints t)
    (set-window-buffer w-locals (gdb-get-buffer-create 'gdb-locals-buffer))
    (set-window-dedicated-p w-locals t)
    (set-window-buffer w-stack (gdb-get-buffer-create 'gdb-stack-buffer))
    (set-window-dedicated-p w-stack t)

    (set-window-buffer w-gdb gud-comint-buffer)

    (select-window w-source)
    (set-window-buffer w-source c-buffer)))

;;;###autoload
(defun +gdb-set-layout ()
  "Enable custom window layout for gdb."
  (interactive)
  (require 'gdb-mi)

  (setq +gdb--many-windows-old gdb-many-windows
        gdb-many-windows nil)

  (advice-add
   'gdb :around
   (defun +gdb--set-window-layout-a (origfn &rest args)
     ;; Save current buffer
     (setq +gdb--old-win-config (current-window-configuration))
     (let ((c-buffer (window-buffer (selected-window))))
       (apply origfn args)
       (+gdb--set-layout c-buffer))))

  (advice-add
   'gdb-reset :after
   (defun +gdb--restore-window-layout-a (&rest _)
     (set-window-configuration +gdb--old-win-config))))

(defun +gdb-reset-layout ()
  "Enable custom window layout for gdb."
  (interactive)
  (setq gdb-many-windows +gdb--many-windows-old)
  (advice-remove 'gdb #'+gdb--set-window-layout-a)
  (advice-add 'gdb-reset #'+gdb--restore-window-layout-a))

;;;###autoload
(defun +emacs-gdb-enable ()
  "Load a faster \"gdb\" command from \"emacs-gdb\".
This will overwrite the built-in \"gdb-mi\" for this session."
  (interactive)
  (if (+emacs-features-p 'modules)
      (when (yes-or-no-p "Loading \"emacs-gdb\" will overwrite \"gdb-mi\" for this session, continue?")
        (use-package gdb-mi
          ;; I use my own fork in which I've merged some open PRs on the upstream.
          :straight '(:host github :repo "weirdNox/emacs-gdb"
                      :files (:defaults "*.c" "*.h" "Makefile")
                      :fork (:host github :repo "abougouffa/emacs-gdb"))
          :demand t
          :init
          (fmakunbound 'gdb)
          (fmakunbound 'gdb-enable-debug)
          :custom
          (gdb-window-setup-function #'gdb--setup-windows)
          (gdb-ignore-gdbinit nil)))
    (message "Cannot enable \"emacs-gdb\", Emacs was built without modules support!")))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; me-gdb.el ends here
#+end_src

** me-dap-utils.el

文件头

#+begin_src emacs-lisp
;;; me-dap-utils.el --- Utility functions for DAP mode -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

+ =autoload functions=

#+begin_src emacs-lisp
;;;###autoload
(defun +github-latest-release (user repo &optional fallback-release)
  "Get the latest release of USER/REPO. Strips the \"v\" at left.

Fallback to FALLBACK-RELEASE when it can't get the last one."
  (if-let ((latest
            (ignore-errors
              (with-temp-buffer
                (url-insert-file-contents
                 (format
                  "https://api.github.com/repos/%s/%s/releases/latest"
                  user repo))
                (json-parse-buffer :object-type 'plist)))))
      (string-trim-left
       (car (last (split-string (plist-get latest :html_url) "/")))
       "v")
    fallback-release))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; me-dap-utils.el ends here
#+end_src

** me-eglot-ltex.el

文件头

#+begin_src emacs-lisp
;;; me-eglot-ltex.el --- Extra functionality for Eglot+LTeX-LS -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; This file provides a hackish implementation of some of `ltex-ls' commands
;; which needs to be handled by the client.
;; See: valentjn.github.io/ltex/ltex-ls/server-usage.html#commands

;; This file implements these code actions:
;; * _ltex.addToDictionary
;; * _ltex.disableRules
;; * _ltex.hideFalsePositives

;; The custom actions are executed via an advice to `eglot-execute-command'. I
;; didn't find a direct way to register custom handler.

;; In theory, the disabled rules and custom dictionary can be saved to a word
;; list and then, they can be passed to ltex-ls as ":/path/to/dictionary.txt".
;; However, in practice, I didn't manage to get it to work with external files.
;; The workaround I use is to store them in a plist, serialize it, and load it
;; at startup. Files are stored under `eglot-ltex-user-rules-path'.

;; To use this with French for example, add something like this to the relevant
;; .dir-locals.el file:
;; ((org-mode . ((eglot-workspace-configuration . eglot-ltex-workspace-config-fn)
;;               (eglot-ltex-language . "fr"))))

;;; Code:
#+end_src

=me-eglot-ltex.el=

#+begin_src emacs-lisp
(defgroup minemacs-eglot-ltex nil
  "LTeX-LS related settings."
  :group 'minemacs)

(defvar-local eglot-ltex-language "auto")

(defcustom eglot-ltex-user-rules-path (concat minemacs-local-dir "eglot/ltex/")
  "Path to save user rules."
  :group 'minemacs-eglot-ltex
  :type 'directory)

;; Load serialized rules
(defvar eglot-ltex-dictionary
  (+deserialize-sym 'eglot-ltex-dictionary eglot-ltex-user-rules-path))

(defvar eglot-ltex-hidden-false-positives
  (+deserialize-sym 'eglot-ltex-hidden-false-positives eglot-ltex-user-rules-path))

(defvar eglot-ltex-disable-rules
  (+deserialize-sym 'eglot-ltex-disable-rules eglot-ltex-user-rules-path))

(defun eglot-ltex--process-client-commands-a (_srv cmd args)
  "Process LTeX-LS client commands."
  (cond
   ((string= cmd "_ltex.addToDictionary")
    (eglot-ltex--action-add-to-rules args :words 'eglot-ltex-dictionary 'store)
    (message "Word added to dictionary."))
   ((string= cmd "_ltex.hideFalsePositives")
    (eglot-ltex--action-add-to-rules args :falsePositives 'eglot-ltex-hidden-false-positives 'store)
    (message "Rule added to false positives."))
   ((string= cmd "_ltex.disableRules")
    (eglot-ltex--action-add-to-rules args :ruleIds 'eglot-ltex-disable-rules 'store)
    (message "Rule added to disable rules."))))

(defun eglot-ltex-workspace-config-fn (&optional _server)
  "A function to use as a value of `eglot-workspace-configuration'.
It generates the workspace configuration dynamically, taking into account
changed values of `eglot-ltex-language', `eglot-ltex-dictrionary', and so on."
  `(:ltex
    (:language ,eglot-ltex-language
     :dictionary ,eglot-ltex-dictionary
     :disabledRules ,eglot-ltex-disable-rules
     :hiddenFalsePositives ,eglot-ltex-hidden-false-positives
     :additionalRules (:languageModel "/usr/share/ngrams/"))))

(defun eglot-ltex--add-rule (lang rule rules-plist)
  "Add RULE of language LANG to the plist named RULES-PLIST (symbol)."
  (when (null (eval rules-plist))
    (set rules-plist (list lang [])))
  (plist-put (eval rules-plist) lang
             (vconcat (list rule) (plist-get (eval rules-plist) lang)))
  (when-let (out-file (+serialize-sym rules-plist eglot-ltex-user-rules-path))
    (+log! "[eglot-ltex] Rule for language %s saved to file \"%s\"" (symbol-name lang) out-file)))

(defun eglot-ltex--action-add-to-rules (action key rules-plist &optional store)
  "Execute action ACTION by getting KEY and storing it in the RULES-PLIST.
When STORE is non-nil, this will also store the new plist in the directory
`eglot-ltex-user-rules-path'."
  (let ((args-plist (plist-get (if (vectorp action) (elt action 0) action) key)))
    (dolist (lang (+plist-keys args-plist))
      (mapc (lambda (rule)
              (eglot-ltex--add-rule lang rule rules-plist)
              (when store
                (+serialize-sym rules-plist eglot-ltex-user-rules-path)))
            (plist-get args-plist lang)))))

(defun eglot-ltex-enable-handling-client-commands ()
  "Enable Eglot hack to handle code actions of LTeX-LS."
  (interactive)
  (advice-add 'eglot-execute-command :before #'eglot-ltex--process-client-commands-a))

(defun eglot-ltex-disable-handling-client-commands ()
  "Disable Eglot hack to handle code actions of LTeX-LS."
  (interactive)
  (advice-remove 'eglot-execute-command #'eglot-ltex--process-client-commands-a))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-eglot-ltex)
;;; me-eglot-ltex.el ends here
#+end_src

** me-elisp-extras.el

文件头

#+begin_src emacs-lisp
;;; me-elisp-extras.el --- Extra font locks and enhancements for Elisp -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=me-eslip-extras.el=

#+begin_src emacs-lisp
(defvar +emacs-lisp--face nil)

;; Extracted from: github.com/doomemacs/doomemacs/blob/master/modules/lang/emacs-lisp/autoload.el
(defun +emacs-lisp--highlight-vars-and-faces (end)
  "Match defined variables and functions.
Functions are differentiated into special forms, built-in functions and
library/userland functions"
  (catch 'matcher
    (while (re-search-forward "\\(?:\\sw\\|\\s_\\)+" end t)
      (let ((ppss (save-excursion (syntax-ppss))))
        (cond ((nth 3 ppss)  ; strings
               (search-forward "\"" end t))
              ((nth 4 ppss)  ; comments
               (forward-line +1))
              ((let ((symbol (intern-soft (match-string-no-properties 0))))
                 (and (cond ((null symbol) nil)
                            ((eq symbol t) nil)
                            ((keywordp symbol) nil)
                            ((special-variable-p symbol)
                             (setq +emacs-lisp--face 'font-lock-variable-name-face))
                            ((and (fboundp symbol)
                                  (eq (char-before (match-beginning 0)) ?\()
                                  (not (memq (char-before (1- (match-beginning 0)))
                                             (list ?\' ?\`))))
                             (let ((unaliased (indirect-function symbol)))
                               (unless (or (macrop unaliased)
                                           (special-form-p unaliased))
                                 (let (unadvised)
                                   (while (not (eq (setq unadvised (ad-get-orig-definition unaliased))
                                                   (setq unaliased (indirect-function unadvised)))))
                                   unaliased)
                                 (setq +emacs-lisp--face
                                       (if (subrp unaliased)
                                           'font-lock-constant-face
                                         'font-lock-function-name-face))))))
                      (throw 'matcher t)))))))
    nil))

;; Taken from: reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists
(defun +emacs-lisp--calculate-lisp-indent-a (&optional parse-start)
  "Add better indentation for quoted and backquoted lists."
  ;; This line because `calculate-lisp-indent-last-sexp` was defined with `defvar`
  ;; with it's value ommited, marking it special and only defining it locally. So
  ;; if you don't have this, you'll get a void variable error.
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp parse-start) (integerp parse-start))
             (goto-char parse-start))
            ((null parse-start) (beginning-of-defun))
            (t (setq state parse-start)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (unless retry
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s("))
                ;; First element of containing sexp is a list.
                ;; Indent under that list.

                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      ;; Containing sexp has nothing before this line
                      ;; except the first element. Indent under that element.
                      (= (point) calculate-lisp-indent-last-sexp)

                      ;; First sexp after `containing-sexp' is a keyword. This
                      ;; condition is more debatable. It's so that I can have
                      ;; unquoted plists in macros. It assumes that you won't
                      ;; make a function whose name is a keyword.
                      ;; (when-let (char-after (char-after (1+ containing-sexp)))
                      ;;   (char-equal char-after ?:))

                      ;; Check for quotes or backquotes around.
                      (let* ((positions (elt state 9))
                             (last (car (last positions)))
                             (rest (reverse (butlast positions)))
                             (any-quoted-p nil)
                             (point nil))
                        (or
                         (when-let (char (char-before last))
                           (or (char-equal char ?')
                               (char-equal char ?`)))
                         (progn
                           (while (and rest (not any-quoted-p))
                             (setq point (pop rest))
                             (setq any-quoted-p
                                   (or
                                    (when-let (char (char-before point))
                                      (or (char-equal char ?')
                                          (char-equal char ?`)))
                                    (save-excursion
                                      (goto-char (1+ point))
                                      (looking-at-p
                                       "\\(?:back\\)?quote[\t\n\f\s]+(")))))
                           any-quoted-p))))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))

(defun +elisp-indent-setup ()
  ;; Override the indenter to indent plists correctly.
  ;; See: reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/
  (advice-add 'calculate-lisp-indent :override #'+emacs-lisp--calculate-lisp-indent-a))

(defun +elisp-highlighting-setup ()
  (font-lock-add-keywords
   'emacs-lisp-mode
   '((+emacs-lisp--highlight-vars-and-faces . +emacs-lisp--face))))

;; HACK: Adapted from Doom. Quite a few functions here are called often, and so
;; are especially performance sensitive, so we compile these functions
;; on-demand.
(+compile-functions #'+emacs-lisp--highlight-vars-and-faces
                    #'+emacs-lisp--calculate-lisp-indent-a)
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-elisp-extras)
;;; me-elisp-extras.el ends here
#+end_src

** me-evil-mc-evil-escape.el

文件头

#+begin_src emacs-lisp
;;; me-evil-mc-evil-escape.el --- Hackish integration of `evil-mc' with `evil-escape' -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; HACK: Fix the integration with `evil-escape' when in insert state. By
;; default, when pressing "fd" in evil-mc insert state, the first letter "f"
;; gets inserted at all fake cursors. This hack fixes this behavior.
;; Taken from: github.com/gabesoft/evil-mc/issues/41#issuecomment-890887060

;;; Code:
#+end_src

=mc-evil-escape=

#+begin_src emacs-lisp
(+after-load! '(:all evil-escape evil-mc)
  (defun +evil-mc--evil-escape-move-back-fake-cursors ()
    (unless (bolp) (backward-char)))

  (advice-add
   'evil-escape-func :before
   (defun +evil-mc--evil-escape-fix-a ()
     (when (evil-mc-has-cursors-p)
       (evil-mc-pause-cursors)
       (run-with-idle-timer
        0 nil
        (lambda ()
          (evil-mc-resume-cursors)
          (let ((evil-mc-command '((:name . +evil-mc-evil-escape-move-back-fake-cursors))))
            (evil-mc-execute-for-all)))))))

  (add-to-list
   'evil-mc-custom-known-commands
   '(+evil-mc--evil-escape-move-back-fake-cursors
     (:default . evil-mc-execute-default-call))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-evil-mc-evil-escape)
;;; me-evil-mc-evil-escape.el ends here
#+end_src

** me-latex-fonts.el

文件头

#+begin_src emacs-lisp
;;; me-latex-fonts.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;;; From Doom Emacs

;;; Code:
#+end_src

=me-latex-fonts.el=

#+begin_src emacs-lisp
;; Fontification taken from https://tex.stackexchange.com/a/86119/81279.
(setq font-latex-match-reference-keywords
      '(;; BibLaTeX.
        ("printbibliography" "[{")
        ("addbibresource" "[{")
        ;; Standard commands.
        ("cite" "[{")
        ("citep" "[{")
        ("citet" "[{")
        ("Cite" "[{")
        ("parencite" "[{")
        ("Parencite" "[{")
        ("footcite" "[{")
        ("footcitetext" "[{")
        ;; Style-specific commands.
        ("textcite" "[{")
        ("Textcite" "[{")
        ("smartcite" "[{")
        ("Smartcite" "[{")
        ("cite*" "[{")
        ("parencite*" "[{")
        ("supercite" "[{")
        ;; Qualified citation lists.
        ("cites" "[{")
        ("Cites" "[{")
        ("parencites" "[{")
        ("Parencites" "[{")
        ("footcites" "[{")
        ("footcitetexts" "[{")
        ("smartcites" "[{")
        ("Smartcites" "[{")
        ("textcites" "[{")
        ("Textcites" "[{")
        ("supercites" "[{")
        ;; Style-independent commands.
        ("autocite" "[{")
        ("Autocite" "[{")
        ("autocite*" "[{")
        ("Autocite*" "[{")
        ("autocites" "[{")
        ("Autocites" "[{")
        ;; Text commands.
        ("citeauthor" "[{")
        ("Citeauthor" "[{")
        ("citetitle" "[{")
        ("citetitle*" "[{")
        ("citeyear" "[{")
        ("citedate" "[{")
        ("citeurl" "[{")
        ;; Special commands.
        ("fullcite" "[{")
        ;; Cleveref.
        ("cref" "{")
        ("Cref" "{")
        ("cpageref" "{")
        ("Cpageref" "{")
        ("cpagerefrange" "{")
        ("Cpagerefrange" "{")
        ("crefrange" "{")
        ("Crefrange" "{")
        ("labelcref" "{"))
      font-latex-match-textual-keywords
      '(;; BibLaTeX brackets.
        ("parentext" "{")
        ("brackettext" "{")
        ("hybridblockquote" "[{")
        ;; Auxiliary commands.
        ("textelp" "{")
        ("textelp*" "{")
        ("textins" "{")
        ("textins*" "{")
        ;; Subcaption.
        ("subcaption" "[{"))
      font-latex-match-variable-keywords
      '(;; Amsmath.
        ("numberwithin" "{")
        ;; Enumitem.
        ("setlist" "[{")
        ("setlist*" "[{")
        ("newlist" "{")
        ("renewlist" "{")
        ("setlistdepth" "{")
        ("restartlist" "{")
        ("crefname" "{")))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-latex-fonts)
;;; me-latex-fonts.el ends here
#+end_src

** me-org-export-async-init.el

文件头

#+begin_src emacs-lisp
;;; me-org-export-async-init.el --- An init file for exporting Org documents asynchronously -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; This file will be used as `user-init-file' when exporting Org documents
;; asynchronously. This will set the modules list to the minimal required to
;; export Org documents.

;; BUG: For some reason, exporting in background can fail with this error:
;; (error "Odd length text property list"), in such case, you can remove the Org
;; cache directory and retry again: rm -rf ~/.emacs.d/local/cache/org/ (see
;; github.com/org-roam/org-roam/issues/2155#issuecomment-1145388814)

;;; Code:
#+end_src

=me-org-export-async-init.el=

#+begin_src emacs-lisp
(message "Using MinEmacs' \"me-org-export-async-init.el\" as init file.")

;; This signals that we are running in a org-export-async context
(provide 'me-org-export-async-init)

;; Load only some essential modules
(setq minemacs-core-modules nil
      minemacs-modules
      '(me-org me-biblio me-latex me-project me-prog me-data me-lisp))

(load (concat user-emacs-directory "init.el") nil t)

(message "Loaded %d modules!" (+ (length minemacs-core-modules) (length minemacs-modules)))
#+end_src

文件尾

#+begin_src emacs-lisp
;;; me-org-export-async-init.el ends here
#+end_src

** me-org-extras.el

文件尾

#+begin_src emacs-lisp
;;; me-org-extras.el --- Extra tweaks Org mode -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=me-org-extras.el=

#+begin_src emacs-lisp
(defcustom +org-responsive-image-percentage 0.4
  "Maximum image width as a percentage of the window width."
  :group 'minemacs-org
  :type 'float)

(defcustom +org-responsive-image-width-limits '(400 . 700) ; '(min . max)
  "The minimum and maximum width of a displayed image."
  :group 'minemacs-org
  :type '(cons natnum natnum))

(defvar-local +org-export-to-pdf-main-file nil
  "The main (entry point) Org file for a multi-files document.")

(put '+org-export-to-pdf-main-file 'safe-local-variable 'stringp)

(defun +org-extras--responsive-image-h ()
  (when (derived-mode-p 'org-mode)
    (setq-local
     org-image-actual-width
     (list (max (car +org-responsive-image-width-limits)
                (min (cdr +org-responsive-image-width-limits)
                     (truncate (* (window-pixel-width)
                                  +org-responsive-image-percentage))))))))

(defun +org-extras--parse-latex-env (str)
  "Parse the LaTeX environment STR.
Return an AST with newlines counts in each level."
  (let (ast)
    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (while (re-search-forward
              (rx "\\"
                  (group (or "\\" "begin" "end" "nonumber"))
                  (zero-or-one "{" (group (zero-or-more not-newline)) "}"))
              nil t)
        (let ((cmd (match-string 1))
              (env (match-string 2)))
          (cond ((string= cmd "begin")
                 (push (list :env (intern env)) ast))
                ((string= cmd "\\")
                 (let ((curr (pop ast)))
                   (push (plist-put curr :newline (1+ (or (plist-get curr :newline) 0))) ast)))
                ((string= cmd "nonumber")
                 (let ((curr (pop ast)))
                   (push (plist-put curr :nonumber (1+ (or (plist-get curr :nonumber) 0))) ast)))
                ((string= cmd "end")
                 (let ((child (pop ast))
                       (parent (pop ast)))
                   (push (plist-put parent :childs (cons child (plist-get parent :childs))) ast)))))))
    (plist-get (car ast) :childs)))

;; Adapted from Scimax
(defun +org-extras-renumber-env (orig-func &rest args)
  "A function to inject numbers in LaTeX fragment previews."
  (let ((results '())
        (counter -1))
    (setq results
          (cl-loop for (begin . env) in
                   (org-element-map (org-element-parse-buffer) 'latex-environment
                     (lambda (env)
                       (cons
                        (org-element-property :begin env)
                        (org-element-property :value env))))
                   collect
                   (cond
                    ((and (string-match "\\\\begin{equation}" env)
                          (not (string-match "\\\\tag{" env)))
                     (cl-incf counter)
                     (cons begin counter))
                    ((string-match "\\\\begin{align}" env)
                     (cl-incf counter)
                     (let ((p (car (+org-extras--parse-latex-env env))))
                       ;; Parse the `env', count new lines in the align env as equations, unless
                       (cl-incf counter (- (or (plist-get p :newline) 0)
                                           (or (plist-get p :nonumber) 0))))
                     (cons begin counter))
                    (t
                     (cons begin nil)))))
    (when-let ((number (cdr (assoc (point) results))))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" number)
             (car args)))))
  (apply orig-func args))

(defun +org-extras-toggle-latex-equation-numbering (&optional enable)
  "Toggle whether LaTeX fragments are numbered."
  (interactive)
  (if (or enable (not (get '+org-extras-renumber-env 'enabled)))
      (progn
        (advice-add 'org-create-formula-image :around #'+org-extras-renumber-env)
        (put '+org-extras-renumber-env 'enabled t)
        (message "LaTeX numbering enabled."))
    (advice-remove 'org-create-formula-image #'+org-extras-renumber-env)
    (put '+org-extras-renumber-env 'enabled nil)
    (message "LaTeX numbering disabled.")))

(defun +org-extras-inject-latex-fragment (orig-func &rest args)
  "Advice function to inject latex code before and/or after the equation in a latex fragment.
  You can use this to set \\mathversion{bold} for example to make
  it bolder. The way it works is by defining
  :latex-fragment-pre-body and/or :latex-fragment-post-body in the
  variable `org-format-latex-options'. These strings will then be
  injected before and after the code for the fragment before it is
  made into an image."
  (setf (car args)
        (concat
         (or (plist-get org-format-latex-options :latex-fragment-pre-body) "")
         (car args)
         (or (plist-get org-format-latex-options :latex-fragment-post-body) "")))
  (apply orig-func args))

(defun +org-extras-inject-latex-fragments ()
  "Toggle whether you can insert latex in fragments."
  (interactive)
  (if (not (get '+org-extras-inject-latex-fragment 'enabled))
      (progn
        (advice-add 'org-create-formula-image :around #'+org-extras-inject-latex-fragment)
        (put '+org-extras-inject-latex-fragment 'enabled t)
        (message "Inject latex enabled"))
    (advice-remove 'org-create-formula-image #'+org-extras-inject-latex-fragment)
    (put '+org-extras-inject-latex-fragment 'enabled nil)
    (message "Inject latex disabled")))

;; Adapted from: github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-org.el
(defun +org-lower-case-keywords-and-properties ()
  "Lower case Org keywords and properties and block identifiers.
Example: \"#+TITLE\" -> \"#+title\"
         \"#+BEGIN_EXAMPLE\" -> \"#+begin_example\"
         \":PROPERTIES:\" -> \":properties:\"."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search nil)
          (count 0))
      (while (re-search-forward
              (rx (group-n 1
                    bol
                    (zero-or-more " ")
                    (or "#+" ":")
                    (one-or-more (any "A-Z"))
                    (zero-or-more (seq "_" (one-or-more alpha)))
                    (or (any " " ":" "=") eol)))
              nil :noerror)
        (setq count (1+ count))
        (replace-match (downcase (match-string-no-properties 1)) :fixedcase nil nil 1))
      (message "Lower-cased %d matches" count))))

(defun +org-extras-responsive-images-setup ()
  (add-hook 'window-configuration-change-hook
            #'+org-extras--responsive-image-h))

(defun +org-extras-equation-numbering-setup ()
  ;; Enable LaTeX equations renumbering
  (+shutup!
   (+org-extras-toggle-latex-equation-numbering :enable)))

(defun +org-extras-multifiles-document-setup ()
  (advice-add
   'org-latex-export-to-pdf :around
   (defun +org--latex-export-to-pdf-main-file-a (orig-fn &rest orig-args)
     (let* ((main-file (or (bound-and-true-p +org-export-to-pdf-main-file) "main.org"))
            (out-file
             (if (file-exists-p (expand-file-name main-file))
                 (with-current-buffer (find-file-noselect main-file)
                   (apply orig-fn orig-args))
               (apply orig-fn orig-args))))
       (if org-export-in-background
           (progn
             (message "Started exporting \"%s\" asynchronously."
                      (abbreviate-file-name
                       (file-name-nondirectory main-file)))
             (when-let ((org-export-process (get-process "org-export-process")))
               (set-process-sentinel
                org-export-process
                (lambda (process event)
                  (unless (process-live-p process)
                    (message "Org async export finised, see *Org Export Process* for more details."))))))
         (message "PDF exported to: %s."
                  (abbreviate-file-name
                   (file-name-nondirectory out-file))))))))

(defun +org-extras-latex-classes-setup ()
  (with-eval-after-load 'ox-latex
    (dolist
        (class
         '(("lettre"
            "\\documentclass{lettre}"
            ("\\section{%s}"       . "\\section*{%s}")
            ("\\subsection{%s}"    . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}"     . "\\paragraph*{%s}")
            ("\\subparagraph{%s}"  . "\\subparagraph*{%s}"))
           ("blank"
            "[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
            ("\\section{%s}"       . "\\section*{%s}")
            ("\\subsection{%s}"    . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}"     . "\\paragraph*{%s}")
            ("\\subparagraph{%s}"  . "\\subparagraph*{%s}"))
           ("IEEEtran"
            "\\documentclass{IEEEtran}"
            ("\\section{%s}"       . "\\section*{%s}")
            ("\\subsection{%s}"    . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}"     . "\\paragraph*{%s}")
            ("\\subparagraph{%s}"  . "\\subparagraph*{%s}"))
           ("ieeeconf"
            "\\documentclass{ieeeconf}"
            ("\\section{%s}"       . "\\section*{%s}")
            ("\\subsection{%s}"    . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}"     . "\\paragraph*{%s}")
            ("\\subparagraph{%s}"  . "\\subparagraph*{%s}"))
           ("sagej"
            "\\documentclass{sagej}"
            ("\\section{%s}"       . "\\section*{%s}")
            ("\\subsection{%s}"    . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}"     . "\\paragraph*{%s}")
            ("\\subparagraph{%s}"  . "\\subparagraph*{%s}"))
           ("thesis"
            "\\documentclass[11pt]{book}"
            ("\\chapter{%s}"       . "\\chapter*{%s}")
            ("\\section{%s}"       . "\\section*{%s}")
            ("\\subsection{%s}"    . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}"     . "\\paragraph*{%s}"))
           ("thesis-fr"
            "\\documentclass[french,12pt,a4paper]{book}"
            ("\\chapter{%s}"       . "\\chapter*{%s}")
            ("\\section{%s}"       . "\\section*{%s}")
            ("\\subsection{%s}"    . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}"     . "\\paragraph*{%s}"))))
      (add-to-list 'org-latex-classes class))))

(defun +org-extras-outline-path-setup ()
  (advice-add
   #'org-format-outline-path :around
   (defun +org--strip-properties-from-outline-a (fn &rest args)
     (let ((org-level-faces
            (cl-loop for face in org-level-faces
                     collect `(:foreground ,(face-foreground face nil t)
                               :weight regular))))
       (apply fn args)))))

(defun +org-extras-pretty-latex-fragments-setup ()
  (require 'org-src)
  (add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))

  ;; Can be dvipng, dvisvgm, imagemagick
  (setq org-preview-latex-default-process 'dvisvgm)

  (setq org-format-latex-options
        (plist-put org-format-latex-options :background "Transparent"))

  (unless (+emacs-features-p 'pgtk) ;; PGTK not need extra up-scaling
    (add-hook
     'org-mode-hook
     (defun +org--set-format-latex-scale ()
       (setq-local
        org-format-latex-options
        (plist-put
         org-format-latex-options
         :scale (/ (float (or (face-attribute 'default :height) 100)) 100.0)))))))

(defun +org-extras-lower-case-keywords-and-properties-setup ()
  (add-hook
   'before-save-hook
   (defun +org--lower-case-keywords-and-properties-h ()
     (when (derived-mode-p 'org-mode)
       (+org-lower-case-keywords-and-properties)))))

(defun +org-extras-setup ()
  (+org-extras-outline-path-setup)
  (+org-extras-latex-classes-setup)
  (+org-extras-pretty-latex-fragments-setup)
  (+org-extras-responsive-images-setup)
  (+org-extras-equation-numbering-setup)
  (+org-extras-multifiles-document-setup)
  (+org-extras-lower-case-keywords-and-properties-setup))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-org-extras)
;;; me-org-extras.el ends here
#+end_src

** me-realgud.el

文件头

#+begin_src emacs-lisp
;;; me-realgud.el --- Extra commands for RealGUD with better evil integration -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; Evil integraion has been adopted from Doom Emacs
;; github.com/doomemacs/doomemacs/blob/master/modules/tools/debugger/autoload/evil.el

;;; Code:
#+end_src

=autoload functions=

#+begin_src emacs-lisp
;;;###autoload(autoload '+realgud:start "../modules/extras/me-realgud" "Start the RealGUD debugger suitable for the current mode." t)
(evil-define-command +realgud:start (&optional path)
  "Start the RealGUD debugger suitable for the current mode."
  (interactive "<f>")
  (let ((default-directory
         (or (and (project-current) (project-root (project-current)))
             (and (fboundp 'projectile-project-root) (projectile-project-root))
             (vc-root-dir)
             default-directory)))
    (pcase major-mode
      ((or 'c-mode 'c++-mode 'c-ts-mode 'c++-ts-mode)
       (realgud:gdb (if path (concat "gdb " path))))
      ((or 'rust-mode 'rust-ts-mode)
       (lldb (if path (concat "lldb " path))))
      ((or 'js-mode 'js2-mode 'js3-mode 'typescript-mode 'js-ts-mode 'typescript-ts-mode)
       (realgud:trepanjs))
      ((or 'sh-mode 'bash-ts-mode)
       (pcase sh-shell
         ((or "bash" "sh")
          (realgud:bashdb (if path (concat "bashdb " path))))
         ("zsh"
          (realgud:zshdb (if path (concat "zshdb " path))))
         (_ (user-error "No shell debugger for %s" sh-shell))))
      (_ (user-error "No debugger for %s" major-mode)))))

;;;###autoload(autoload '+realgud:toggle-breakpoint "../modules/extras/me-realgud" "Toggle break point." t)
(evil-define-command +realgud:toggle-breakpoint (&optional bang)
  "Toggle break point."
  (interactive "<!>")
  (call-interactively (if bang #'realgud:cmd-clear #'realgud:cmd-break)))

;; Add some missing gdb/rr commands
(defun +realgud:cmd-run (arg)
  "Run."
  (interactive "p")
  (realgud-command "run"))

(defun +realgud:cmd-start (arg)
  "start => break main; run."
  (interactive "p")
  (realgud-command "start"))

(defun +realgud:cmd-reverse-next (arg)
  "Reverse next."
  (interactive "p")
  (realgud-command "reverse-next"))

(defun +realgud:cmd-reverse-step (arg)
  "Reverse step."
  (interactive "p")
  (realgud-command "reverse-step"))

(defun +realgud:cmd-reverse-continue (arg)
  "Reverse continue."
  (interactive "p")
  (realgud-command "reverse-continue"))

(defun +realgud:cmd-reverse-finish (arg)
  "Reverse finish."
  (interactive "p")
  (realgud-command "reverse-finish"))

;;;###autoload(autoload '+realgud-hydra/body "../modules/extras/me-realgud" "Hydra keys for RealGUD." t)
(defhydra +realgud-hydra (:color pink :hint nil :foreign-keys run)
  "
 Stepping  |  _n_: next      |  _i_: step    |  _o_: finish  |  _c_: continue  |  _R_: restart  |  _u_: until-here
 Revese    | _rn_: next      | _ri_: step    | _ro_: finish  | _rc_: continue  |
 Breakpts  | _ba_: break     | _bD_: delete  | _bt_: tbreak  | _bd_: disable   | _be_: enable   | _tr_: backtrace
 Eval      | _ee_: at-point  | _er_: region  | _eE_: eval    |
           |  _!_: shell     | _Qk_: kill    | _Qq_: quit    | _Sg_: gdb       | _Ss_: start    | _Sr_: run
"
  ("n"  realgud:cmd-next)
  ("i"  realgud:cmd-step)
  ("o"  realgud:cmd-finish)
  ("c"  realgud:cmd-continue)
  ("R"  realgud:cmd-restart)
  ("u"  realgud:cmd-until-here)
  ("rn" +realgud:cmd-reverse-next)
  ("ri" +realgud:cmd-reverse-step)
  ("ro" +realgud:cmd-reverse-finish)
  ("rc" +realgud:cmd-reverse-continue)
  ("ba" realgud:cmd-break)
  ("bt" realgud:cmd-tbreak)
  ("bD" realgud:cmd-delete)
  ("be" realgud:cmd-enable)
  ("bd" realgud:cmd-disable)
  ("ee" realgud:cmd-eval-at-point)
  ("er" realgud:cmd-eval-region)
  ("tr" realgud:cmd-backtrace)
  ("eE" realgud:cmd-eval)
  ("!"  realgud:cmd-shell)
  ("Qk" realgud:cmd-kill)
  ("Sg" realgud:gdb)
  ("Ss" +realgud:cmd-start)
  ("Sr" +realgud:cmd-run)
  ("q"  nil "quit" :color blue) ;; :exit
  ("Qq" realgud:cmd-quit :color blue)) ;; :exit
#+end_src

文件尾

#+begin_src emacs-lisp
;;; me-realgud.el ends here
#+end_src

** me-spell-fu.el

文件头

#+begin_src emacs-lisp
;;; me-spell-fu.el --- Better integraion of spell-fu -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=me-spell-fu.el=

#+begin_src emacs-lisp
;; Adapted from Doom Emacs
(defun +spell-fu--correct (replace poss word orig-pt start end)
  "Correct word with spell-fu."
  (cond ((eq replace 'ignore)
         (goto-char orig-pt)
         nil)
        ((eq replace 'save)
         (goto-char orig-pt)
         (ispell-send-string (concat "*" word "\n"))
         (ispell-send-string "#\n")
         (setq ispell-pdict-modified-p '(t)))
        ((or (eq replace 'buffer) (eq replace 'session))
         (ispell-send-string (concat "@" word "\n"))
         (add-to-list 'ispell-buffer-session-localwords word)
         (or ispell-buffer-local-name ; session localwords might conflict
             (setq ispell-buffer-local-name (buffer-name)))
         (if (null ispell-pdict-modified-p)
             (setq ispell-pdict-modified-p
                   (list ispell-pdict-modified-p)))
         (goto-char orig-pt)
         (if (eq replace 'buffer)
             (ispell-add-per-file-word-list word)))
        (replace
         (let ((new-word (if (atom replace)
                             replace
                           (car replace)))
               (orig-pt (+ (- (length word) (- end start))
                           orig-pt)))
           (unless (equal new-word (car poss))
             (delete-region start end)
             (goto-char start)
             (insert new-word))))
        ((goto-char orig-pt)
         nil)))

;; Adapted from Doom Emacs
;;;###autoload
(defun +spell-fu-correct ()
  "Correct spelling of word at point."
  (interactive)
  ;; spell-fu fails to initialize correctly if it can't find aspell or a similar
  ;; program. We want to signal the error, not tell the user that every word is
  ;; spelled correctly.
  (unless (or (and ispell-really-aspell ispell-program-name)
              (executable-find "aspell"))
    (user-error "Aspell is required for spell checking"))

  (ispell-set-spellchecker-params)
  (save-current-buffer
    (ispell-accept-buffer-local-defs))
  (if (not (featurep 'vertico))
      (call-interactively #'ispell-word)
    (cl-destructuring-bind (start . end)
        (or (bounds-of-thing-at-point 'word)
            (user-error "No word at point"))
      (let ((word (thing-at-point 'word t))
            (orig-pt (point))
            poss ispell-filter)
        (ispell-send-string "%\n")
        (ispell-send-string (concat "^" word "\n"))
        (while (progn (accept-process-output ispell-process)
                      (not (string= "" (car ispell-filter)))))
        ;; Remove leading empty element
        (setq ispell-filter (cdr ispell-filter))
        ;; ispell process should return something after word is sent. Tag word as
        ;; valid (i.e., skip) otherwise
        (unless ispell-filter
          (setq ispell-filter '(*)))
        (when (consp ispell-filter)
          (setq poss (ispell-parse-output (car ispell-filter))))
        (cond
         ((or (eq poss t) (stringp poss))
          ;; don't correct word
          (message "%s is correct" (funcall ispell-format-word-function word))
          t)
         ((null poss)
          ;; ispell error
          (error "Ispell: error in Ispell process"))
         (t
          ;; The word is incorrect, we have to propose a replacement.
          (setq res (completing-read (format "Corrections for %S: " word) (nth 2 poss)))
          (unless res (setq res (cons 'break word)))
          (cond
           ((stringp res)
            (+spell-fu--correct res poss word orig-pt start end))
           ((let ((cmd (car res))
                  (wrd (cdr res)))
              (unless (or (eq cmd 'skip)
                          (eq cmd 'break)
                          (eq cmd 'stop))
                (+spell-fu--correct cmd poss wrd orig-pt start end)
                (unless (string-equal wrd word)
                  (+spell-fu--correct wrd poss word orig-pt start end))))))
          (ispell-pdict-save t)))))))

(defun +spell-fu--add-dictionary (lang)
  "Add `LANG` to spell-fu multi-dict, with a personal dictionary."
  ;; Add the dictionary
  (spell-fu-dictionary-add (spell-fu-get-ispell-dictionary lang))
  (let ((personal-dict-file (expand-file-name (format "personal-aspell.%s.pws" lang) spell-fu-directory)))
    ;; Create an empty personal dictionary if it doesn't exists
    (unless (file-exists-p personal-dict-file) (write-region "" nil personal-dict-file))
    ;; Add the personal dictionary
    (spell-fu-dictionary-add (spell-fu-get-personal-dictionary (format "%s-personal" lang) personal-dict-file))))

;;;###autoload
(defmacro +spell-fu-register-dictionaries (&rest langs)
  "Register dictionaries for `LANGS` to spell-fu's multi-dict."
  (let* ((fn-name (intern (format "+spell-fu--multi-langs-%s-h" (string-join langs "-"))))
         (closure `(defun ,fn-name ())))
    (dolist (lang langs)
      (add-to-list 'closure `(+spell-fu--add-dictionary ,lang) t))
    (append '(add-hook (quote spell-fu-mode-hook)) (list closure))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-spell-fu)
;;; me-spell-fu.el ends here
#+end_src

** me-writing-mode.el

文件头

#+begin_src emacs-lisp
;;; me-write-mode.el --- Simple writing-centered mode -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=me-writing-mode.el=

#+begin_src emacs-lisp
(require 'visual-fill-column)
(require 'mixed-pitch nil t)

(defcustom +writing-mode-enable-hook nil
  "Execute hooks on enable."
  :group 'minemacs-ui
  :type 'hook)

(defcustom +writing-mode-disable-hook nil
  "Execute hooks on disable."
  :group 'minemacs-ui
  :type 'hook)

(defcustom +writing-text-scale 2.0
  "The text-scaling level for `+writing-mode'."
  :group 'minemacs-ui
  :type 'float)

(defcustom +writing-text-width nil
  "Like `visual-fill-column-width'."
  :group 'minemacs-ui
  :type '(choice
          (const :tag "Use `fill-column'" :value nil)
          (integer :tag "Specify width" :value 70)))

(defcustom +writing-mixed-pitch-enable t
  "Enable `mixed-pitch-mode' with `+writing-mode' for some modes defined in `+writing-mixed-pitch-modes'."
  :group 'minemacs-ui
  :type 'boolean)

(defcustom +writing-mixed-pitch-modes
  '(rst-mode markdown-mode org-mode)
  "Enable `mixed-pitch-mode' with `+writing-mode' for these modes."
  :group 'minemacs-ui
  :type '(repeat symbol))

(defvar-local +writing--line-nums-active-p nil)
(defvar-local +writing--org-format-latex-scale nil)

(defun +writing--scale-up-org-latex ()
  (setq-local
   +writing--org-format-latex-scale
   (plist-get org-format-latex-options :scale)
   org-format-latex-options
   (plist-put
    org-format-latex-options
    :scale
    (* ;; The scale from current font
     (/ (float (or (face-attribute 'default :height) 100)) 100.0)
     ;; Proportional upscaling
     (/ +writing-text-scale (if (+emacs-features-p 'pgtk) 1.8 1.4))))))

(defun +writing--scale-down-org-latex ()
  (setq-local
   org-format-latex-options
   (plist-put org-format-latex-options
              :scale (or +writing--org-format-latex-scale 1.0))))

;;;###autoload
(define-minor-mode +writing-mode
  "A mode for writing without distraction."
  :init-value nil :lighter "Zen" :global nil
  (let ((mixed-pitch-mode-p (seq-filter #'derived-mode-p +writing-mixed-pitch-modes)))
    (if +writing-mode
        ;; Enable
        (progn
          (setq-local visual-fill-column-center-text t
                      visual-fill-column-width +writing-text-width)
          (when (and mixed-pitch-mode-p (bound-and-true-p display-line-numbers-mode))
            (setq-local +writing--line-nums-active-p display-line-numbers-type)
            (display-line-numbers-mode -1))
          (+writing--scale-up-org-latex)
          (run-hooks +writing-mode-enable-hook))
      ;; Disable
      (kill-local-variable 'visual-fill-column-center-text)
      (kill-local-variable 'visual-fill-column-width)
      (+writing--scale-down-org-latex)
      (when (and +writing--line-nums-active-p mixed-pitch-mode-p)
        (display-line-numbers-mode +writing--line-nums-active-p)))

    (visual-fill-column-mode (if +writing-mode 1 -1))

    (when (fboundp 'mixed-pitch-mode)
      (mixed-pitch-mode (if (and +writing-mode mixed-pitch-mode-p +writing-mixed-pitch-enable) 1 -1)))

    (when (/= +writing-text-scale 0.0)
      (text-scale-set (if +writing-mode +writing-text-scale 0.0))
      (visual-fill-column-adjust))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-writing-mode)
;;; me-writing-mode.el ends here
#+end_src

** me-mu4e-gmail.el

文件头

#+begin_src emacs-lisp
;;; me-mu4e-gmail.el --- Better integration of mu4e with Gmail accounts -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; Adapted form Doom Emacs with several improvements

;;; Code:
#+end_src

=me-mu4e-gmail.el=

#+begin_src emacs-lisp
(defcustom +mu4e-gmail-accounts nil
  "Gmail accounts that do not contain \"gmail\" in address and maildir.
An alist of Gmail addresses of the format \((\"username@domain.com\" . \"account-maildir\"))
to which Gmail integrations (behind the `+gmail' flag of the `mu4e' module) should be applied.
See `+mu4e-msg-gmail-p' and `mu4e-sent-messages-behavior'."
  :group 'minemacs-mu4e
  :type '(repeat (cons string string)))

(defun +mu4e-msg-gmail-p (msg)
  (let ((root-maildir
         (replace-regexp-in-string
          "/.*" "" (substring (mu4e-message-field msg :maildir) 1))))
    (or (member (concat "/" root-maildir) (mapcar #'cdr +mu4e-gmail-accounts))
        (string-match-p "gmail" root-maildir)
        (string-match-p "google" root-maildir))))

(defun +mu4e-sent-from-gmail-p (&optional msg)
  "Return the \"from\" address if it is in the registred Gmail accounts.
If MSG is provided, use it, else, extract the \"from\" field
from the envelope of the current message."
  (let ((from (or (plist-get (car (plist-get msg :from)) :email)
                  (message-sendmail-envelope-from))))
    (when (member from (mapcar #'car +mu4e-gmail-accounts))
      from)))

;; In this workflow, Gmail emails won't be moved at all. Only their flags/labels
;; are changed. Se we redefine the trash and refile marks not to do any moving.
;; However, the real magic happens in `+mu4e-gmail--fix-flags-h'. Gmail will
;; handle the rest.
(defun +mu4e--mark-seen (docid _msg target)
  (mu4e--server-move docid (mu4e--mark-check-target target) "+S-u-N"))

(defun +mu4e-gmail-setup ()
  ;; Don't save message to Sent Messages, Gmail/IMAP takes care of this
  (setq mu4e-sent-messages-behavior
        (lambda ()
          (if (or (+mu4e-sent-from-gmail-p)
                  (string-match-p
                   "@gmail.com\\'" (message-sendmail-envelope-from)))
              'delete 'sent))
        mu4e-marks (delq (assq 'delete mu4e-marks) mu4e-marks))

  (setf (alist-get 'delete mu4e-marks)
        (list
         :char '("D" . "✘")
         :prompt "Delete"
         :show-target (lambda (_target) "delete")
         :action
         (lambda (docid msg target)
           (if (+mu4e-msg-gmail-p msg)
               (progn
                 (message "Unsupported delete operation for Gmail. Trashing instead.")
                 (+mu4e--mark-seen docid msg target))
             (mu4e--server-remove docid))))
        (alist-get 'trash mu4e-marks)
        (list
         :char '("d" . "▼")
         :prompt "dtrash"
         :dyn-target (lambda (_target msg) (mu4e-get-trash-folder msg))
         :action
         (lambda (docid msg target)
           (if (+mu4e-msg-gmail-p msg)
               (+mu4e--mark-seen docid msg target)
             (mu4e--server-move docid (mu4e--mark-check-target target) "+T-N"))))
        ;; Refile will be my "archive" function.
        (alist-get 'refile mu4e-marks)
        (list
         :char '("r" . "▼")
         :prompt "rrefile"
         :dyn-target (lambda (_target msg) (mu4e-get-refile-folder msg))
         :action
         (lambda (docid msg target)
           (if (+mu4e-msg-gmail-p msg)
               (+mu4e--mark-seen docid msg target)
             (mu4e--server-move docid (mu4e--mark-check-target target) "-N")))))

  ;; This hook correctly modifies gmail flags on emails when they are marked.
  ;; Without it, refiling (archiving), trashing/deleting, and flagging
  ;; (starring) email won't properly result in the corresponding gmail action,
  ;; since the marks are ineffectual otherwise.
  ;; NOTE: For these tricks to work properly, you need to:
  ;; 1. Go to your Gmail settings;
  ;; 2. In the "Forwarding and POP/IMAP" tab, go to "IMAP access" and make sure
  ;;    you've selected:
  ;;    - Under: "When I mark a message in IMAP as deleted:"
  ;;       -> Choose: "Auto-Expunge off - Wait for the client to update the server."
  ;;    - Under: "When a message is marked as deleted and expunged from the last visible IMAP folder:"
  ;;       -> Choose: "Move the message to the Trash"
  (add-hook
   'mu4e-mark-execute-pre-hook
   (defun +mu4e-gmail--fix-flags-h (mark msg)
     (when (+mu4e-msg-gmail-p msg)
       (pcase mark
         ((or 'trash 'delete) (mu4e-action-retag-message msg "-\\Inbox,+\\Trash,-\\Draft,-\\Spam"))
         ('refile (mu4e-action-retag-message msg "-\\Inbox,-\\Spam"))
         ('flag (mu4e-action-retag-message msg "+\\Starred"))
         ('unflag (mu4e-action-retag-message msg "-\\Starred")))))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-mu4e-gmail)
;;; me-mu4e-gmail.el ends here
#+end_src

** me-mu4e-ui.el

文件头

#+begin_src emacs-lisp
;;; me-mu4e-ui.el --- Better UI for mu4e -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;;; Most of this has been inspired by Doom Emacs

;;; Code:
#+end_src

=me-mu4e-ui.el=

#+begin_src emacs-lisp
(defvar +mu4e-main-bullet "⦿"
  "Prefix to use instead of \"  *\" in the mu4e main view.
This is enacted by `+mu4e--main-action-str-prettier-a' and
`+mu4e--main-keyval-str-prettier-a'.")

(defvar +mu4e-header-colorized-faces
  '(nerd-icons-green
    nerd-icons-lblue
    nerd-icons-purple-alt
    nerd-icons-blue-alt
    nerd-icons-purple
    nerd-icons-yellow
    nerd-icons-maroon
    nerd-icons-dorange)
  "Faces to use when coloring folders and account stripes.")

(defun +mu4e-colorize-str (str &optional unique herring)
  "Apply a face from `+mu4e-header-colorized-faces' to STR.
If HERRING is set, it will be used to determine the face instead of STR.
Will try to make unique when non-nil UNIQUE,
a quoted symbol for a alist of current strings and faces provided."
  (let ((herring (or herring str)))
    (put-text-property
     0 (length str) 'face
     (list
      (if (null unique)
          (+mu4e--str-color-face herring str)
        (let ((unique-alist (eval unique)))
          (unless (assoc herring unique-alist)
            (if (> (length unique-alist) (length +mu4e-header-colorized-faces))
                (push (cons herring (+mu4e--str-color-face herring)) unique-alist)
              (let ((offset 0) color color?)
                (while (not color)
                  (setq color? (+mu4e--str-color-face herring offset))
                  (if (not (rassoc color? unique-alist))
                      (setq color color?)
                    (setq offset (1+ offset))
                    (when (> offset (length +mu4e-header-colorized-faces))
                      (message "Warning: +mu4e-colorize-str was called with non-unique-alist UNIQUE-alist alist.")
                      (setq color (+mu4e--str-color-face herring)))))
                (push (cons herring color) unique-alist)))
            (set unique unique-alist))
          (cdr (assoc herring unique-alist))))
      'default)
     str)
    str))

(defun +mu4e--str-color-face (str &optional offset)
  "Select a face from `+mu4e-header-colorized-faces' based on STR and any
integer OFFSET."
  (let* ((str-sum (apply #'+ (mapcar (lambda (c) (% c 3)) str)))
         (color (nth (% (+ str-sum (or offset 0))
                        (length +mu4e-header-colorized-faces))
                     +mu4e-header-colorized-faces)))
    color))

(defun +mu4e--main-action-prettier-a (title cmd &optional bindstr alt)
  (let* ((bindstr (or bindstr (mu4e-key-description cmd) (and alt (string alt))
                      (mu4e-error "No binding for %s" cmd)))
         (bindstr (if (and alt (> (length bindstr) 1)) alt bindstr))
         (title ;; remove first letter afrer [] if it equal last of binding
          (mu4e-string-replace
           (concat "[@]" (substring bindstr -1)) "[@]" title))
         (title ;; Special cases: replace "jump" with "Jump", "enter" -> "Enter"
          (cond ((string= "j" bindstr)
                 (setq bindstr "J")
                 (replace-regexp-in-string "jump" "Jump" title))
                ((string= "s" bindstr)
                 (replace-regexp-in-string "enter" "Enter" title))
                (t title)))
         (title ;; insert binding in [@]
          (mu4e-string-replace
           "[@]" (format "[%s]" (propertize bindstr 'face 'mu4e-highlight-face))
           title))
         (title ;; Prettify the title
          (replace-regexp-in-string
           "\\[\\(..?\\)\\]"
           (lambda(m)
             (format "%s"
                     (propertize (match-string 1 m) 'face '(mode-line-emphasis bold))))
           (replace-regexp-in-string "\t\\*" (format "\t%s" +mu4e-main-bullet) title)))
         (map (make-sparse-keymap)))
    (define-key map [mouse-2] cmd)
    (define-key map (kbd "RET") cmd)
    ;; Add highlighting on mouse hover
    (put-text-property 0 (length title) 'keymap map title)
    (put-text-property (string-match "[A-Za-z].+$" title)
                       (- (length title) 1) 'mouse-face 'highlight title)
    (propertize title 'keymap map)))

(defun +mu4e--main-keyval-str-prettier-a (str)
  "Replace '*' with `+mu4e-main-bullet' in STR."
  (replace-regexp-in-string "\t\\*" (format "\t%s" +mu4e-main-bullet) str))

(defun +mu4e--get-string-width (str)
  "Return the width in pixels of a string in the current
window's default font. If the font is mono-spaced, this
will also be the width of all other printable characters."
  (let ((window (selected-window))
        (remapping face-remapping-alist))
    (with-temp-buffer
      (make-local-variable 'face-remapping-alist)
      (setq face-remapping-alist remapping)
      (set-window-buffer window (current-buffer))
      (insert str)
      (car (window-text-pixel-size)))))

(cl-defun +normalized-icon (name &key set color height v-adjust)
  "Convert icon declaration to nerd icon with width normalized to space-width."
  (let* ((set (or set "fa"))
         (icon-set (intern (format "nerd-icons-%sicon" set)))
         (v-adjust (or v-adjust 0.02))
         (height (or height 0.8))
         (name (format "nf-%s-%s" set name))
         (icon (if color
                   (apply icon-set `(,name :face ,(intern (format "nerd-icons-%s" color)) :height ,height :v-adjust ,v-adjust))
                 (apply icon-set `(,name :height ,height :v-adjust ,v-adjust))))
         (icon-width (+mu4e--get-string-width icon))
         (space-width (+mu4e--get-string-width " "))
         (space-factor (- 2.0 (/ (float icon-width) space-width))))
    (concat (propertize " " 'display `(space . (:width ,space-factor))) icon)))

(defun +mu4e--ui-setup ()
  ;; Add a column to display what email account the email belongs to,
  ;; and an account color stripe column
  (defvar +mu4e-header--maildir-colors nil)
  (setq
   mu4e-header-info-custom
   '((:account
      . (:name "Account"
         :shortname "Account"
         :help "Which account/maildir this email belongs to"
         :function
         (lambda (msg)
           (let ((maildir (replace-regexp-in-string
                           "\\`/?\\([^/]+\\)/.*\\'" "\\1"
                           (mu4e-message-field msg :maildir))))
            (+mu4e-colorize-str
             (replace-regexp-in-string
              "^gmail"
              (propertize "g" 'face 'bold-italic)
              maildir)
             '+mu4e-header--maildir-colors
             maildir)))))
     (:subject-truncated
      . (:name "Subject"
         :shortname "Subject"
         :help "Subject of the message"
         :sortable t
         :function
         (lambda (msg)
           (let ((prefix (mu4e~headers-thread-prefix (mu4e-message-field msg :meta))))
            (concat
             prefix
             (truncate-string-to-width
              ;; Some times, a newline/carriage return char slips in the
              ;; subject and drives mu4e crazy! Let's fix it and truncate
              ;; the string at 100 characters.
              (replace-regexp-in-string
               "[\n\r]" ""
               (mu4e-message-field msg :subject))
              (- 100 (length prefix)) nil nil t))))))
     (:account-stripe
      . (:name "Account"
         :shortname "▐"
         :help "Which account/maildir this email belongs to, as a colorized stripe"
         :function
         (lambda (msg)
           (let ((account
                  (replace-regexp-in-string
                   "\\`/?\\([^/]+\\)/.*\\'" "\\1"
                   (mu4e-message-field msg :maildir))))
            (propertize
             (+mu4e-colorize-str "▌" '+mu4e-header--maildir-colors account)
             'help-echo account)))))
     (:recipnum
      . (:name "Number of recipients"
         :shortname " ⭷"
         :help "Number of recipients for this message"
         :function
         (lambda (msg)
           (propertize (format "%2d"
                        (+ (length (mu4e-message-field msg :to))
                         (length (mu4e-message-field msg :cc))))
            'face 'mu4e-footer-face)))))
   mu4e-headers-date-format "%d/%m/%y"
   mu4e-headers-time-format "%H:%M"
   mu4e-use-fancy-chars t
   mu4e-headers-attach-mark    (cons "a" (+normalized-icon 'attachment :set 'md))
   mu4e-headers-calendar-mark  (cons "c" (+normalized-icon 'calendar :set 'md))
   mu4e-headers-draft-mark     (cons "D" (+normalized-icon 'edit))
   mu4e-headers-encrypted-mark (cons "x" (+normalized-icon 'lock))
   mu4e-headers-flagged-mark   (cons "F" (+normalized-icon 'flag :set 'md))
   mu4e-headers-list-mark      (cons "l" (+normalized-icon 'list_ul))
   mu4e-headers-new-mark       (cons "N" (+normalized-icon 'download :set 'oct :color 'dred))
   mu4e-headers-passed-mark    (cons "P" (+normalized-icon 'mail_forward))
   mu4e-headers-personal-mark  (cons "p" (+normalized-icon 'person :set 'oct))
   mu4e-headers-replied-mark   (cons "R" (+normalized-icon 'mail_reply))
   mu4e-headers-seen-mark      (cons "S" "")
   mu4e-headers-signed-mark    (cons "s" (+normalized-icon 'verified :set 'oct :color 'dpurple))
   mu4e-headers-trashed-mark   (cons "T" (+normalized-icon 'trash_can_outline :set 'md))
   mu4e-headers-unread-mark    (cons "u" (+normalized-icon 'unread :set 'oct :color 'dred))
   mu4e-headers-thread-child-prefix         '("├>" . "├▶")
   mu4e-headers-thread-connection-prefix    '("│ " . "│ ")
   mu4e-headers-thread-first-child-prefix   '("├>" . "├▶")
   mu4e-headers-thread-last-child-prefix    '("└>" . "╰▶")
   mu4e-headers-thread-orphan-prefix        '("┬>" . "┬▶")
   mu4e-headers-thread-single-orphan-prefix '("─>" . "─▶")
   mu4e-headers-fields '((:account-stripe . 2)
                         (:flags . 6) ;; 3 flags
                         (:human-date . 8)
                         (:from-or-to . 25)
                         (:subject-truncated)))

  (advice-add #'mu4e--key-val :filter-return #'+mu4e--main-keyval-str-prettier-a)
  (advice-add #'mu4e--main-action :override #'+mu4e--main-action-prettier-a))

(defun +mu4e-ui-setup ()
  (if (display-graphic-p)
      (+mu4e--ui-setup)
    (+hook-once! server-after-make-frame-hook
      (when (display-graphic-p)
        (+mu4e--ui-setup)))))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-mu4e-ui)
;;; me-mu4e-ui.el ends here
#+end_src

** me-mu4e-extras.el

文件头

#+begin_src emacs-lisp
;;; me-mu4e-extras.el --- Extra tweaks and utilities for mu4e -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src

=me-mu4e-extras.el=

#+begin_src emacs-lisp
(defcustom +mu4e-account-aliases nil
  "Per-account alias list."
  :group 'minemacs-mu4e
  :type '(repeat string))

(defcustom +mu4e-auto-bcc-address nil
  "BCC address."
  :group 'minemacs-mu4e
  :type 'string)

;; Some of these functions are adapted from Doom Emacs

(defun +mu4e-view-select-attachment ()
  "Use completing-read to select a single attachment.
Acts like a singular `mu4e-view-save-attachments', without the saving."
  (if-let ((parts (delq nil (mapcar
                             (lambda (part)
                               (when (assoc "attachment" (cdr part))
                                 part))
                             (mu4e~view-gather-mime-parts))))
           (files (+mu4e-part-selectors parts)))
      (cdr (assoc (completing-read "Select attachment: " (mapcar #'car files)) files))
    (user-error (mu4e-format "No attached files found"))))

(defun +mu4e-view-open-attachment ()
  "Select an attachment, and open it."
  (interactive)
  (mu4e~view-open-file
   (mu4e~view-mime-part-to-temp-file (cdr (+mu4e-view-select-attachment)))))

(defun +mu4e-view-select-mime-part-action ()
  "Select a MIME part, and perform an action on it."
  (interactive)
  (let ((labeledparts (+mu4e-part-selectors (mu4e~view-gather-mime-parts))))
    (if labeledparts
        (mu4e-view-mime-part-action
         (cadr (assoc (completing-read "Select part: " (mapcar #'car labeledparts))
                      labeledparts)))
      (user-error (mu4e-format "No parts found")))))

(defun +mu4e-part-selectors (parts)
  "Generate selection strings for PARTS."
  (if parts
      (let (partinfo labeledparts maxfnamelen fnamefmt maxsizelen sizefmt)
        (dolist (part parts)
          (push (list :index (car part)
                      :mimetype (if (and (string= "text/plain" (caaddr part))
                                         (alist-get 'charset (cdaddr part)))
                                    (format "%s (%s)"
                                            (caaddr part)
                                            (alist-get 'charset (cdaddr part)))
                                  (caaddr part))
                      :type (car (nth 5 part))
                      :filename (cdr (assoc 'filename (assoc "attachment" (cdr part))))
                      :size (file-size-human-readable (with-current-buffer (cadr part) (buffer-size)))
                      :part part)
                partinfo))
        (setq maxfnamelen (apply #'max 7 (mapcar (lambda (i) (length (plist-get i :filename))) partinfo))
              fnamefmt (format " %%-%ds  " maxfnamelen)
              maxsizelen (apply #'max (mapcar (lambda (i) (length (plist-get i :size))) partinfo))
              sizefmt (format "%%-%ds " maxsizelen))
        (dolist (pinfo partinfo)
          (push (cons
                 (concat
                  (propertize (format "%-2s " (plist-get pinfo :index)) 'face '(bold font-lock-type-face))
                  (cond ((featurep 'nerd-icons)
                         (nerd-icons-icon-for-file (or (plist-get pinfo :filename) "")))
                        ((featurep 'all-the-icons)
                         (all-the-icons-icon-for-file (or (plist-get pinfo :filename) ""))))
                  (format fnamefmt (or (plist-get pinfo :filename)
                                       (propertize (plist-get pinfo :type) 'face '(italic font-lock-doc-face))))
                  (format sizefmt (propertize (plist-get pinfo :size) 'face 'font-lock-builtin-face))
                  (propertize (plist-get pinfo :mimetype) 'face 'font-lock-constant-face))
                 (plist-get pinfo :part))
                labeledparts))
        labeledparts)))

(defun +mu4e-view-save-all-attachments (&optional msg)
  "Save all MIME parts from current mu4e gnus view buffer."
  ;; Copied from mu4e-view-save-attachments
  (interactive "P")
  (if (and (eq major-mode 'mu4e-view-mode)
           (derived-mode-p 'gnus-article-mode))
      (let* ((msg (or msg (mu4e-message-at-point)))
             (id (+clean-file-name (mu4e-message-field msg :subject) :downcase))
             (attachdir (expand-file-name id mu4e-attachment-dir))
             (parts (mu4e~view-gather-mime-parts))
             (handles '())
             (files '())
             dir)
        (mkdir attachdir t)
        (dolist (part parts)
          (let ((fname (or (cdr (assoc 'filename (assoc "attachment" (cdr part))))
                           (seq-find #'stringp
                                     (mapcar (lambda (item) (cdr (assoc 'name item)))
                                             (seq-filter 'listp (cdr part)))))))
            (when fname
              (push `(,fname . ,(cdr part)) handles)
              (push fname files))))
        (if files
            (progn
              (setq dir
                    (if current-prefix-arg (read-directory-name "Save to directory: ")
                      attachdir))
              (cl-loop for (f . h) in handles
                       when (member f files)
                       do (mm-save-part-to-file h
                                                (+file-name-incremental
                                                 (expand-file-name f dir)))))
          (mu4e-message "No attached files found")))
    (mu4e-error "Not in `mu4e-view-mode' nor in `gnus-article-mode'.")))

(defun +mu4e-register-account (label maildir letvars &optional default-p)
  (let ((context
         (make-mu4e-context
          :name label
          :enter-func
          (lambda () (mu4e-message "Switched to %s" label))
          :leave-func
          (lambda ()
            (setq +mu4e-account-aliases nil)
            (mu4e-clear-caches))
          :match-func
          (lambda (msg)
            (when msg
              (string-match-p (concat "[/]?" maildir) (mu4e-message-field msg :maildir))))
          :vars letvars)))
    (add-to-list 'mu4e-contexts context (not default-p))
    context))

(defun +org-msg-make-signature (closing-phrase firstname lastname &rest lines)
  (concat
   "\n\n" closing-phrase "\n\n"
   "#+begin_signature"
   "\n"
   "-- *" (capitalize firstname) " " (upcase lastname) "*" "\\\\\n"
   (string-join lines "\\\\\n")
   "\n"
   "#+end_signature"))

;; I always synchronize Spams with `mbsync' and index them with `mu'. However, I
;; don't like to see them all the time, I would rather jump to the spam folder
;; from time to time to check if a mail has been falsely classified as spam.
;; This function sets the `mu4e-bookmarks' to ignore the mails located in the
;; Spam or Junk folders.
(defun +mu4e-extras-ignore-spams-query (query)
  (let ((spam-filter "NOT maildir:/.*\\(spam\\|junk\\).*/"))
    (if (string-match-p spam-filter query)
        query
      (format "(%s) AND (%s)" query spam-filter))))

(defun +mu4e-extras-ignore-spams-in-bookmarks-setup ()
  (dolist (bookmark mu4e-bookmarks)
    (plist-put bookmark :query (+mu4e-extras-ignore-spams-query (plist-get bookmark :query)))))

;; I like to always BCC myself
(defun +mu4e--auto-bcc-h ()
  "Add BCC address from `+mu4e-auto-bcc-address'."
  (when +mu4e-auto-bcc-address
    (save-excursion (message-add-header (format "BCC: %s\n" +mu4e-auto-bcc-address)))))

(defun +mu4e--set-from-address-h ()
  "If the user defines multiple `+mu4e-account-aliases' for email aliases
within a context, set `user-mail-address' to an alias found in the 'To' or
'From' headers of the parent message if present, or prompt the user for a
preferred alias"
  (when-let ((addresses (if (or mu4e-contexts +mu4e-account-aliases)
                            (cons user-mail-address ;; the main address
                                  +mu4e-account-aliases) ;; the aliases
                          (mu4e-personal-addresses))))
    (setq user-mail-address
          (if mu4e-compose-parent-message
              (let ((to (mapcar (lambda (a) (plist-get a :email))
                                (mu4e-message-field mu4e-compose-parent-message :to)))
                    (from (mapcar (lambda (a) (plist-get a :email))
                                  (mu4e-message-field mu4e-compose-parent-message :from))))
                (or (car (seq-intersection to addresses))
                    (car (seq-intersection from addresses))
                    (completing-read "From: " addresses)))
            (if (length= addresses 1)
                (car addresses)
              (completing-read "From: " addresses))))))

;; Detect empty subjects, and give users an opotunity to fill something in
(defun +mu4e--check-for-subject-h ()
  "Check that a subject is present, and prompt for a subject if not."
  (save-excursion
    (goto-char (point-min))
    (search-forward "--text follows this line--")
    (re-search-backward "^Subject:") ; this should be present no matter what
    (let ((subject (string-trim (substring (thing-at-point 'line) 8))))
      (when (string-empty-p subject)
        (end-of-line)
        (insert (read-string "Subject (optional): "))
        (message "Sending...")))))

(defun +mu4e-save-message-at-point (&optional msg)
  "Copy message at point to somewhere else as <date>_<subject>.eml."
  (interactive)
  (let* ((msg (or msg (mu4e-message-at-point)))
         (target (format "%s_%s.eml"
                         (format-time-string "%F" (mu4e-message-field msg :date))
                         (+clean-file-name (or (mu4e-message-field msg :subject) "No subject") :downcase))))
    (copy-file
     (mu4e-message-field msg :path)
     (format "%s/%s" (or (when current-prefix-arg (read-directory-name "Copy message to: "))
                         mu4e-attachment-dir) target) 1)))

;; Based on: mu4e-action-view-in-browser
(defun +mu4e-view-save-mail-as-pdf (&optional msg skip-headers)
  "Save current MSG as PDF.
If SKIP-HEADERS is set, do not show include message headers."
  (interactive)
  (when-let ((msg (or msg (mu4e-message-at-point))))
    (with-temp-buffer
      (insert-file-contents-literally
       (mu4e-message-readable-path msg) nil nil nil t)
      (run-hooks 'gnus-article-decode-hook)
      (let ((header (unless skip-headers
                      (cl-loop for field in '("from" "to" "cc" "date" "subject")
                               when (message-fetch-field field)
                               concat (format "%s: %s\n" (capitalize field) it))))
            (parts (mm-dissect-buffer t t)))
        ;; If singlepart, enforce a list.
        (when (and (bufferp (car parts))
                   (stringp (car (mm-handle-type parts))))
          (setq parts (list parts)))
        ;; Process the list
        ;; First, `+save-as-pdf' is set as browse-url function,
        ;; and the appropriate file output file name is bound to `+save-as-pdf-filename'
        (let ((browse-url-browser-function #'+save-as-pdf)
              (+save-as-pdf-filename
               (expand-file-name
                (format "%s_%s.pdf"
                        (format-time-string
                         "%F" (mu4e-message-field msg :date))
                        (+clean-file-name
                         (or (mu4e-message-field msg :subject) "No subject") t))
                mu4e-attachment-dir)))
          ;; `gnus-article-browse-html-parts' will try to display the text/html part
          ;; of the message, but as `+save-as-pdf' is used as browse-url function,
          ;; it will be called with the proper argumets.
          (unless (gnus-article-browse-html-parts parts header)
            ;; If the mail doesn't contain a text/html part, we save the plain-text message
            ;; and then we explicitly use `+save-as-pdf' to save it.
            (let ((outfile (make-temp-file "plaintext-mail-" nil ".txt")))
              (with-temp-file outfile
                (insert (mu4e-view-message-text msg)))
              (+save-as-pdf outfile t))))
        (mm-destroy-parts parts)))))

;;;###autoload
(defun +mu4e-extras-setup ()
  (add-hook 'mu4e-compose-mode-hook '+mu4e--auto-bcc-h)
  (add-hook 'mu4e-compose-pre-hook '+mu4e--set-from-address-h)
  (add-hook 'message-send-hook #'+mu4e--check-for-subject-h)

  ;; Register actions
  (add-to-list 'mu4e-view-actions '("pdf" . +mu4e-view-save-mail-as-pdf))
  (add-to-list 'mu4e-view-actions '("all attachements save" . +mu4e-view-save-all-attachments))
  (add-to-list 'mu4e-view-actions '("Save message" . +mu4e-save-message-at-point)))
#+end_src

文件尾

#+begin_src emacs-lisp
(provide 'me-mu4e-extras)
;;; me-mu4e-extras.el ends here
#+end_src

* skel/
:properties:
:path:     ~/.emacs.d/skel/
:end:
=skel= 目录下是框架的骨架 可以放入自定义的部分
** config.el

#+begin_src emacs-lisp
;;; config.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:

;; Personal info
(setq user-full-name "donney.luck"
      user-mail-address (concat "donney.luck" "@" "gmail" "." "com"))

;; Set the default GPG key ID, see "gpg --list-secret-keys"
;; (setq-default epa-file-encrypt-to '("XXXX"))

(setq
 ;; Set a theme for MinEmacs, supported themes include these from `doom-themes'
 ;; or built-in themes
 minemacs-theme 'doom-xcode ; `doom-one' is a dark theme, `doom-one-light' is the light one
 ;; Set Emacs fonts, some good choices include:
 ;; - Cascadia Code
 ;; - Fira Code, FiraCode Nerd Font
 ;; - Iosevka, Iosevka Fixed Curly Slab
 ;; - IBM Plex Mono
 ;; - JetBrains Mono
 minemacs-fonts
 '(:font-family "Iosevka Fixed Curly Slab"
   ;;'(:font-family "Sarasa Gothic SC"
   :font-size 12
   ;;   :unicode-font-family "Sarasa Gothic SC"
   ;;   :unicode-font-size 12
   :variable-pitch-font-family "IBM Plex Serif"
   :variable-pitch-font-size 12))

(+deferred!
 ;; Auto enable Eglot in supported modes using `+eglot-auto-enable' (from the
 ;; `me-prog' module). You can use `+lsp-auto-enable' instead to automatically
 ;; enable LSP mode in supported modes (from the `me-lsp' module)r
 (+eglot-auto-enable))

;; If you installed Emacs from source, you can add the source code
;; directory to enable jumping to symbols defined in Emacs' C code.
;; (setq source-directory "~/Sources/emacs-git/")

;; I use Brave, and never use Chrome, so I replace chrome program with "brave"
(setq browse-url-chrome-program (or (executable-find "brave") (executable-find "chromium")))

;; Module: `me-natural-langs' -- Package: `spell-fu'
(with-eval-after-load 'spell-fu
  ;; We can use MinEmacs' helper macro `+spell-fu-register-dictionaries'
  ;; to enable multi-language spell checking.
  (+spell-fu-register-dictionaries "en" "cn"))

;; Module: `me-rss' -- Package: `elfeed'
(with-eval-after-load 'elfeed
  ;; Add news feeds for `elfeed'
  (setq elfeed-feeds
        '("https://itsfoss.com/feed"
          "https://lwn.net/headlines/rss"
          "https://linuxhandbook.com/feed"
          "https://www.omgubuntu.co.uk/feed"
          "https://this-week-in-rust.org/rss.xml"
          "https://planet.emacslife.com/atom.xml")))

;; Module: `me-email' -- Package: `mu4e'
(with-eval-after-load 'mu4e
  ;; Load personal aliases, a file containing aliases, for example:
  ;; alias gmail "Firstname Lastname <some.user.name@gmail.com>"
  ;; alias work  "Firstname Lastname <some.user.name@work.com>"

  ;; (setq mail-personal-alias-file (concat minemacs-config-dir "private/mail-aliases.mailrc"))

  (setq +mu4e-auto-bcc-address "always.bcc@this.email" ;; Add an email address always included as BCC
        +mu4e-gmail-accounts '(("account1@gmail.com" . "/gmail")
                               ("account@somesite.org" . "/gmail")))

  ;; Register email accounts with mu4e
  ;; Use MinEmacs' `+mu4e-register-account' helper function to register multiple accounts
  (+mu4e-register-account
   "Google mail" ;; Account name
   "gmail" ;; Maildir
   `((user-mail-address     . "account1@gmail.com")
     (mu4e-sent-folder      . "/gmail/Sent Mail")
     (mu4e-drafts-folder    . "/gmail/Drafts")
     (mu4e-trash-folder     . "/gmail/Trash")
     ;; These settings aren't mandatory if a `msmtp' config is used.
     (smtpmail-smtp-server  . "smtp.googlemail.com")
     (smtpmail-smtp-service . 587)
     ;; Define account aliases
     (+mu4e-account-aliases . ("account1-alias@somesite.org"
                               "account1-alias@othersite.org"))
     ;; Org-msg greeting and signature
     (org-msg-greeting-fmt  . "Hi%s,")
     ;; Generate signature
     (org-msg-signature     . ,(+org-msg-make-signature
                                "Regards," ;; Closing phrase
                                "Firstname" ;; First name
                                "Lastname" ;; Last name
                                "/R&D Engineer at Some company/")))))

;; Module: `me-org' -- Package: `org'
(with-eval-after-load 'org
  ;; Set Org-mode director
  (setq org-directory "~/Org/" ; let's put files here
        org-default-notes-file (concat org-directory "inbox.org"))
  ;; Customize Org stuff
  (setq org-todo-keywords
        '((sequence "IDEA(i)" "TODO(t)" "NEXT(n)" "PROJ(p)" "STRT(s)" "WAIT(w)" "HOLD(h)" "|" "DONE(d)" "KILL(k)")
          (sequence "[ ](T)" "[✔](R)" "|" "[✘](W)")
          (sequence "OKAY(O)" "YES(Y)" "NO(N)" "|")))
  (setq org-export-with-section-numbers nil)
  (setq org-export-headline-levels 5)

  ;; Your Org files to include in the agenda
  (setq org-agenda-files
        (mapcar
         (lambda (f) (concat org-directory f))
         '("inbox.org"
           "agenda.org"
           "projects.org"))))

;; Module: `me-notes' -- Package: `org-roam'
(with-eval-after-load 'org-roam
  (setq org-roam-directory (concat org-directory "slip-box/")
        org-roam-db-location (concat org-roam-directory "org-roam.db"))

  ;; Register capture template (via Org-Protocol)
  ;; Add this as bookmarklet in your browser
  ;; javascript:location.href='org-protocol://roam-ref?template=r&ref=%27+encodeURIComponent(location.href)+%27&title=%27+encodeURIComponent(document.title)+%27&body=%27+encodeURIComponent(window.getSelection())
  (setq org-roam-capture-ref-templates
        '(("r" "ref" plain "%?"
           :if-new (file+head "web/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+created: %U\n\n${body}\n")
           :unnarrowed t))))

;; Module: `me-media' -- Package: `empv'
(with-eval-after-load 'empv
  ;; Set the radio channels, you can get streams from radio-browser.info
  (setq empv-radio-channels
        '(("El-Bahdja FM" . "http://webradio.tda.dz:8001/ElBahdja_64K.mp3")
          ("El-Chaabia" . "https://radio-dzair.net/proxy/chaabia?mp=/stream")
          ("Quran Radio" . "http://stream.radiojar.com/0tpy1h0kxtzuv")
          ("Algeria International" . "https://webradio.tda.dz/Internationale_64K.mp3")
          ("JOW Radio" . "https://str0.creacast.com/jowradio")
          ("Europe1" . "http://ais-live.cloud-services.paris:8000/europe1.mp3")
          ("France Iter" . "http://direct.franceinter.fr/live/franceinter-hifi.aac")
          ("France Info" . "http://direct.franceinfo.fr/live/franceinfo-hifi.aac")
          ("France Culture" . "http://icecast.radiofrance.fr/franceculture-hifi.aac")
          ("France Musique" . "http://icecast.radiofrance.fr/francemusique-hifi.aac")
          ("FIP" . "http://icecast.radiofrance.fr/fip-hifi.aac")
          ("Beur FM" . "http://broadcast.infomaniak.ch/beurfm-high.aac")
          ("Skyrock" . "http://icecast.skyrock.net/s/natio_mp3_128k"))
        ;; See: docs.invidious.io/instances/
        empv-invidious-instance "https://invidious.projectsegfau.lt/api/v1"))

;; Module: `me-ros' -- Package: `ros'
(with-eval-after-load 'ros
  (setq ros-workspaces
        (list
         (ros-dump-workspace
          :tramp-prefix "/docker:ros@ros-machine:"
          :workspace "~/ros_ws"
          :extends '("/opt/ros/noetic/"))
         (ros-dump-workspace
          :tramp-prefix "/docker:ros@ros-machine:"
          :workspace "~/ros2_ws"
          :extends '("/opt/ros/foxy/")))))

(use-package csharp-mode
  :straight t
  :mode "\\.cs\\'"
  :custom
  (csharp-ts-mode-indent-offset 2) ; customize variables
  (imenu-generic-expression
   '(("Variables" "^\\s-*[a-zA-Z0-9._ ]* \\([a-zA-Z0-9_]*\\)\\( = \\sw*\\|\\s-*\\);$" 1)
     ("Functions" "^\\s-*[^/]* \\([a-zA-Z0-9_]+\\)(.*)\\(\\s-*.*\n\\|\\ *\\)\\s-*{" 1)
     ("Classes" "^\\s-*\\(.*\\)class +\\([a-zA-Z0-9_]+\\)" 2)
     ("Namespaces" "^namespace +\\([a-z0-9_]*\\)" 1)))
  :init
  :config)


(defun g-screenshot-on-buffer-creation ()
  (setq display-fill-column-indicator-column nil)
  (setq line-spacing nil))

;;(setq-default major-mode 'org-mode)

(with-eval-after-load 'org
  (setq org-export-in-background nil))

(setq project-ignores '("*.meta" "*.prefab" "*.dll" "*.png" "*.asset"))

;; 获取当前主题的背景色
(defun get-theme-background-color ()
  (cdr (assoc 'background-color (frame-parameters))))

(defun set-org-block-end-line-color ()
  "Set org-src-block face background color to current theme's background color."
  (interactive)
  (let ((background-color (get-theme-background-color))) ; 获取当前主题的背景色
    (set-face-attribute 'org-block-end-line nil :background background-color))) ; 设置 org-src-block face 的背景色属性

(advice-add 'consult-theme :after (lambda (&rest args) (set-org-block-end-line-color)))
#+end_src

** modules.el

#+begin_src emacs-lisp
;;; modules.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:

;; This file can be used to override `minemacs-modules'
;; and `minemacs-core-modules'

;; Ordered list of enabled core modules
(setq minemacs-core-modules
      '(me-splash        ; Simple splash screen
        me-keybindings   ; Keybinding (general, which-key, hydra, ...)
        me-evil          ; Emacs as Vim (evil, evil-collection, evil-escape, evil-snipe, evil-numbers, ...)
        me-core-ui       ; Core UI (doom-themes, modus-themes, doom-modeline, ...)
        me-completion))  ; Completion (vertico, marginalia, corfu, cape, consult, embark, ...)

;; List of enabled modules
(setq minemacs-modules
      '(me-ui            ; User interface (focus, writeroom-mode, mixed-pitch, ...)
        me-editor        ; Editing (tempel, smartparens, unicode-fonts, ligature, ...)
        me-daemon        ; Emacs daemon tweaks
        me-undo          ; Better undoing (undo-fu, undo-fu-session, vundo, ...)
        me-multi-cursors ; Multi-cursors editing (iedit, evil-mc, evil-iedit-state, ...)
        me-vc            ; Version control (magit, forge, core-review, diff-hl, ...)
        me-project       ; Project management (project, consult-project-extra, ...)
        me-prog          ; Programming stuff (tree-sitter, eglot, eldoc, eldoc-box, apheleia, editorconfig, ...)
        me-checkers      ; Static checkers (flymake, flymake-easy, ...)
        me-debug         ; Debugging tools (gdb-mi, realgud, disaster, ...)
        ;; me-lsp        ; LSP and DAP (lsp-mode, dap-mode, consult-lsp, lsp-pyright, ccls, ...)
        me-lisp          ; Lisps development (parinfer-rust, sly, macrostep, geiser, elisp, helpful, eros, ...)
        ;; me-embedded   ; Embedded systems (arduino, openocd, bitbake, vhdl-mode, ...)
        ;; me-robot      ; Robotics stuff (ros, robot-mode, ...)
        me-data          ; Data file formats (csv, yaml, toml, json, plantuml-mode, ...)
        ;; me-math       ; Mathematics (maxima, ess, ein, julia-mode, octave, ...)
        ;; me-modeling   ; Modeling tools (scad-mode, ...)
        me-org           ; Org-mode for life (org, org-contrib, org-modern, org-appear, ...)
        me-extra         ; Extra features (better-jumper, crux, ...)
        me-notes         ; Notes & Zettelkasten (org-roam, consult-org-roam, ...)
        ;; me-eaf           ; EAF apps (browser, jupyter, file-sender, ...)
        ;; me-email      ; Email (mu4e, mu4e-alert, org-msg, ...)
        ;; me-rss        ; News feed (elfeed, ...)
        ;; me-lifestyle  ; *Very* opinionated lifestyle packages (awqat, ...)
        me-docs          ; Documents (pdf-tools, nov, ...)
        me-latex         ; LaTeX (auctex, auctex-latexmk, reftex, bibtex, ...)
        ;; me-biblio     ; Bibliography & citations (org-cite, citar, zotxt, ...)
        me-natural-langs ; Natural language stuff (spell-fu, go-translate, eglot-ltex, ...)
        me-files         ; Files and directories (dirvish, treemacs, vlf, ...)
        me-tools         ; System tools (tramp, vterm, tldr, ssh-deploy, docker, ...)
        me-tty           ; Emacs from terminal (xt-mouse, xclip, ...)
        me-fun           ; Games and funny packages (xkcd, speed-type, ...)
        me-media         ; Multimedia (empv, emms, ...)
        ;; me-workspaces ; Workspace separation (tabspaces, tab-bar, ...). NOTE: This is a WIP
        ;; me-binary        ; Display binary files in hex or decompile them (hexl, ...) ...

        ;; You can use the obsolete configurations by adding the `obsolete/me-*' modules to `minemacs-modules'
        ;; (setq minemacs-modules
        ;;       (append
        ;;        minemacs-modules
        ;;        '(obsolete/me-yasnippet   ; Yasnippet (yasnippet, cape-yasnippet, yasnippet-snippets, ...)
        ;;          obsolete/me-writeroom   ; Replacement for `+writing-mode' (writeroom-mode, ...)
        ;;          obsolete/me-projectile  ; Project management (projectile, consult-projectile, treemacs-projectile, ...)
        ;;          obsolete/me-flycheck))) ; Static checkers (flycheck, ...)       me-window))      ; Frame & window tweaks
#+end_src

** early-config.el

#+begin_src emacs-lisp
;;; early-config.el -*- coding: utf-8-unix; lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:

;; This file will be loaded at the end of `early-init.el', it can be used to set
;; some early initialization stuff, or to set some MinEmacs variables, specially
;; these used in macros.

;;; Code:

;; Set log level to `info' rather than `error'
(unless minemacs-verbose
  (setq minemacs-msg-level 2))

;; Disable `dashboard'
;; (setq +dashboard-disable t)


;; Enable full screen at startup
;; (if-let ((fullscreen (assq 'fullscreen default-frame-alist)))
;;     (setcdr fullscreen 'fullboth)
;;   (push '(fullscreen . fullboth) default-frame-alist))

;; Force loading lazy packages immediately, not in idle time
;; (setq minemacs-not-lazy t)

;; Setup a `debug-on-message' to catch a wired message!
;; (setq debug-on-message "Package cl is deprecated")
#+end_src

* Makefile
:properties:
:header-args: :tangle Makefile
:end:
用于清理 更新 重新编译整个包

#+begin_src makefile
EMACS_DIR=.
EMACS=emacs
EMACS_BATCH=emacs --batch --script init.el

all:
@echo "Cleaning options are: clean, clean_all, prune, loaddefs."
@echo "Straight options are: pull, rebuild, check."

clean:
rm -rf $(EMACS_DIR)/eln-cache $(EMACS_DIR)/local/eln-cache $(EMACS_DIR)/local/cache $(EMACS_DIR)/local/straight/build-*

clean_pcache:
rm -rf $(EMACS_DIR)/local/cache/pcache

clean_all: clean
cp $(EMACS_DIR)/local/straight/versions/default.el /tmp/straight-versions-default.el
rm -rf $(EMACS_DIR)/local/straight/
mkdir -p $(EMACS_DIR)/local/straight/versions/
cp /tmp/straight-versions-default.el $(EMACS_DIR)/local/straight/versions/default.el

prune: clean
cp $(EMACS_DIR)/local/straight/versions/default.el /tmp/straight-versions-default.el
rm -rf $(EMACS_DIR)/local
mkdir -p $(EMACS_DIR)/local/straight/versions/
cp /tmp/straight-versions-default.el $(EMACS_DIR)/local/straight/versions/default.el

loaddefs:
rm $(EMACS_DIR)/core/me-loaddefs.el

pull:
$(EMACS_BATCH) --eval='(straight-pull-all)'

rebuild:
$(EMACS_BATCH) --eval='(straight-rebuild-all)'

check:
$(EMACS_BATCH) --eval='(straight-check-all)'

update:
$(EMACS_BATCH) --eval='(minemacs-update)'
#+end_src

