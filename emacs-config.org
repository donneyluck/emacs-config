#+title: Emacs 配置文件
#+author: donney.luck
#+date: 2023/04/15 14:23:50
#+startup: overview
#+property: header-args:emacs-lisp :comments no :mkdirp yes
* early-init.el
:properties:
:header-args: :tangle early-init.el
:end:
=early-init.el= 在Emacs刚启动，还未加载主要配置文件时的配置文件。
#+begin_src emacs-lisp
;;; early-init.el --- MinEmacs early initialization tweaks -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:

(setq
 ;; Do not make installed packages available when Emacs starts
 package-enable-at-startup nil
 ;; HACK: Increase the garbage collection (GC) threshold for faster startup.
 ;; This will be overwritten when `gcmh-mode' (a.k.a. the Garbage Collector
 ;; Magic Hack) gets loaded in the `me-gc' module (see "init.el").
 gc-cons-threshold most-positive-fixnum
 ;; Do not wast time checking the modification time of each file
 load-prefer-newer noninteractive
 ;; Remove some unneeded UI elements
 default-frame-alist '((tool-bar-lines . 0)
                       (menu-bar-lines . 0)
                       (vertical-scroll-bars)
                       (mouse-color . "blue")
                       (left-fringe . 8)
                       (right-fringe . 13)
                       (fullscreen . maximized))
 ;; Explicitly set modes disabled in `default-frame-alist' to nil
 tool-bar-mode nil
 menu-bar-mode nil
 scroll-bar-mode nil)

;; NOTE: In Emacs29+, frames can have a transparent background via the
;; `alpha-background' parameter. For a better experience, this value should be
;; set early before any frame gets created (i.e. in "early-init.el"). MinEmacs
;; uses the "$MINEMACS_ALPHA" environment variable that can be set to an integer
;; value in the [1-100] range (the alpha percentage). When this variable is not
;; set, Emacs will load the default GUI (without background alpha), and when it
;; is set but the value is not valid, MinEmacs will fallback to the default
;; alpha of 93%.
(when (>= emacs-major-version 29)
  (when-let* ((alpha (getenv "MINEMACS_ALPHA"))
              (alpha (string-to-number alpha)))
    (push (cons 'alpha-background (if (or (zerop alpha) (> alpha 100)) 93 alpha))
          default-frame-alist)))

;; HACK: In `lsp-mode' (see the `me-lsp' module), the user can define the
;; "$LSP_USE_PLISTS=true" to improve `lsp-mode' performances. We set this
;; environment variable here so we don't need to add it to the system's
;; environment variables.
(setenv "LSP_USE_PLISTS" "true")

;; Load MinEmacs variables from the `me-vars' core module.
(load (expand-file-name "core/me-vars.el" (file-name-directory (file-truename load-file-name))) nil t)

;; Load the user early configuration file from "$MINEMACSDIR/early-config.el"
;; if it exists.
(let ((early-config-path (concat minemacs-config-dir "early-config.el")))
  (when (file-exists-p early-config-path)
    (load early-config-path nil (not minemacs-verbose))))

;;; early-init.el ends here
#+end_src
* init.el
:properties:
:header-args: :tangle init.el
:end:
=init.el= 是Emacs的主要配置文件。
** init.el =HEAD=
#+begin_src emacs-lisp
;; init.el --- MinEmacs core initialization file -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
** init.el 版本检测
#+begin_src emacs-lisp
;; Check if Emacs version is supported. You can define the
;; $MINEMACS_IGNORE_VERSION_CHECK environment variable to ignore this check.
;; This can be useful if you are stuck with an old Emacs version and you've
;; incrementally implemented the new Emacs routines MinEmacs needs in your
;; "init-tweaks.el".
(let ((min-ver "28.0"))
  (when (and (version< emacs-version min-ver) (not (getenv "MINEMACS_IGNORE_VERSION_CHECK")))
    (error "Emacs v%s is not supported, MinEmacs requires v%s or higher" emacs-version min-ver)))
#+end_src
** init.el 提高启动速度
#+begin_src emacs-lisp
;; PERF: Setting `file-name-handler-alist' to nil should boost startup time.
;; reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start
;; Store the current value so we can reset it after Emacs startup.
(put 'file-name-handler-alist 'original-value (default-toplevel-value 'file-name-handler-alist))
;; Make sure the new value survives any current let-binding.
(set-default-toplevel-value 'file-name-handler-alist nil)
;; After Emacs startup, we restore `file-name-handler-alist' while conserving
;; the potential edits made during startup.
(add-hook
 'emacs-startup-hook
 (defun +mineamcs--restore-file-name-handler-alist-h ()
   (setq file-name-handler-alist
         (delete-dups
          (append file-name-handler-alist
                  (get 'file-name-handler-alist 'original-value)))))
 101)
#+end_src
** init.el 载入定义的vars
#+begin_src emacs-lisp
;; HACK: At this point, MinEmacs variables defined in `me-vars' should be
;; already loaded (in "early-init.el"). However, we double-check here and load
;; them if necessary in case Emacs has been loaded directly from "init.el"
;; without passing by "early-init.el". This can happen when we are running in a
;; `me-org-export-async-init' context, or if we use some bootstrapping mechanism
;; like Chemacs2.
(unless (featurep 'me-vars)
  (load (expand-file-name "core/me-vars.el" (file-name-directory (file-truename load-file-name))) nil t))

(defun +load (&rest filename-parts)
  "Load a file, the FILENAME-PARTS are concatenated to form the file name."
  (let ((filename (mapconcat #'identity filename-parts nil)))
    (if (file-exists-p filename)
        (load filename nil (not minemacs-verbose))
      (user-error "[MinEmacs:Error] Cannot load \"%s\", the file doesn't exists." filename))))

;; HACK: Most core and third-party packages depends on the
;; `user-emacs-directory' variable to store some cache information and generated
;; configuration files. However, this will mess with MinEmacs' directory (which
;; defaults to `user-emacs-directory'). To keep the "~/.emacs.d/" directory
;; clean, we overwrite the `user-emacs-directory' with `minemacs-local-dir' so
;; all generated files gets stored in "~/.emacs.d/local/".
;; BUG: It is important to set this here and not in `me-vars' nor in
;; "early-init.el", otherwise, it won't work with Chemacs2-based installations.
(setq user-emacs-directory minemacs-local-dir)
#+end_src
** init.el 向后兼容一些函数(>=emacs29)
#+begin_src emacs-lisp
;; HACK: Load Emacs 29 back ports for earlier Emacs versions. Note that I do
;; only back port a very small number of the functions/variables that I use at
;; early stage from Emacs29+ to be compatible with Emacs 28.2. For any Emacs
;; version less than 29, MinEmacs will enable the `me-compat' module and load it
;; just after `me-bootstrap'. This module loads the `compat' package which
;; provide several forward compatibility functions, it is loaded at an early
;; stage to provide its functionality to the rest of the modules so we can use
;; some new features when configuring them.
(when (< emacs-major-version 29)
  (+load minemacs-modules-dir "me-backports-29.el"))
#+end_src
** init.el =debug-on-error=
#+begin_src emacs-lisp
(setq
 ;; Enable debugging on error when Emacs is launched with the "--debug-init"
 ;; option or when the environment variable "$MINEMACS_DEBUG" is defined (see
 ;; `me-vars').
 debug-on-error minemacs-debug
 ;; Decrese the warning type to `:error', unless we are running in verbose mode
 warning-minimum-level (if minemacs-verbose :warning :error)
 warning-minimum-log-level warning-minimum-level
 ;; Make byte compilation less noisy
 byte-compile-warnings minemacs-verbose
 byte-compile-verbose minemacs-verbose)

#+end_src
** init.el =native-compile=
#+begin_src emacs-lisp
;; Native compilation settings
(when (featurep 'native-compile)
  (setq
   ;; Silence compiler warnings as they can be pretty disruptive, unless we are
   ;; running in `minemacs-verbose' mode.
   native-comp-async-report-warnings-errors (when minemacs-verbose 'silent)
   native-comp-verbose (if minemacs-verbose 1 0) ; do not be too verbose
   native-comp-debug (if minemacs-debug 1 0)
   ;; Make native compilation happens asynchronously.
   native-comp-jit-compilation t)

  ;; Set the right directory to store the native compilation cache to avoid
  ;; messing with "~/.emacs.d/".
  (startup-redirect-eln-cache (concat minemacs-cache-dir "eln/")))

#+end_src
** init.el =loaddefs-generate=
#+begin_src emacs-lisp
;; Add some of MinEmacs' directories to `load-path'.
(setq load-path (append (list minemacs-core-dir minemacs-elisp-dir minemacs-extras-dir) load-path))

(defun minemacs-generate-loaddefs ()
  "Generate MinEmacs' loaddefs file."
  (interactive)
  (when (file-exists-p minemacs-loaddefs-file)
    (delete-file minemacs-loaddefs-file))

  (loaddefs-generate
   (list minemacs-core-dir minemacs-elisp-dir minemacs-extras-dir)
   minemacs-loaddefs-file))

;; Some of MinEmacs commands and libraries are defined to be auto-loaded. In
;; particular, these in the `minemacs-core-dir', `minemacs-elisp-dir', and
;; `minemacs-extras-dir' directories. The generated loaddefs file will be stored
;; in `minemacs-loaddefs-file'. We first regenerate the loaddefs file if it
;; doesn't exist.
(unless (file-exists-p minemacs-loaddefs-file)
  (minemacs-generate-loaddefs))

;; Then we load the loaddefs file
(+load minemacs-loaddefs-file)

#+end_src
** NO init.el load init-tweak.el
** init.el load environment vars
#+begin_src emacs-lisp
;; HACK: When Emacs is launched from the terminal (in GNU/Linux), it inherits
;; the terminal's environment variables, which can be useful specially for
;; running commands under a custom "$PATH" directory. But when Emacs is launched
;; from the desktop manager (KDE, Gnome, etc.), it can omit the terminal's
;; environment variables. The way I solve this is by launching Emacs from
;; terminal, which gives Emacs the full environment variables of the invoking
;; terminal. Then I call the `+env-save' command, which reads the environment
;; variables defined in `+env-save-vars' and stores them in
;; "~/.emacs.d/local/system-env.el". This file is then loaded in the future
;; Emacs sessions (launched either from terminal or from GUI) by calling the
;; `+env-load' command.
(+env-load) ; Load environment variables when available.
#+end_src
** init.el load =packages= and =user =customization=
#+begin_src emacs-lisp
;; NOTE: This is MinEmacs' synchronization point. To get a fast Emacs startup,
;; MinEmacs tries to defer loading most of its packages until this hook is
;; executed. This is managed by the `minemacs-loaded' and `minemacs-lazy'
;; pseudo-modules. After loading Emacs, the `emacs-startup-hook' gets executed,
;; we use this hook to profile the startup time, load the fonts and the theme,
;; and setup the *scratch* buffer content. Lastly we require the
;; `minemacs-loaded' synchronization module, which runs internally the
;; `minemacs-after-startup-hook' hooks and provide `minemacs-loaded' so the
;; packages loaded with `:after minemacs-loaded' can be loaded. The
;; `minemacs-loaded' will require `minemacs-lazy' when Emacs goes idle, this
;; pseudo-module provides `minemacs-lazy' so the packages loaded with `:after
;; minemacs-lazy' can be loaded then it incrementally run the hooks in
;; `minemacs-lazy-hook' when Emacs goes idle.
(defun +minemacs--loaded-h ()
  (+log! "=============== Loaded Emacs ===============")
  (+info! "Loaded Emacs in %s." (emacs-init-time))

  ;; When running in an async Org export context, there is no need to set
  ;; the fonts, load the theme or play with the scratch buffer.
  (unless (featurep 'me-org-export-async-init)
    (+log! "Applying `minemacs-fonts'.")
    ;; Load fonts, values are read from `minemacs-fonts' if set in config.el,
    ;; otherwise, they are read from the default `minemacs-default-fonts'.
    (+set-fonts)

    ;; Initially MinEmacs loads the `doom-one-light' theme, and when
    ;; `minemacs-theme' is set in user configuration, it is loaded here.
    (+load-theme)

    (+log! "Filling scratch buffer content.")
    (+fill-scratch-buffer)

    ;; In `me-defaults', the `initial-major-mode' is set to `fundamental-mode'
    ;; to enhance startup time. However, I like to use the scratch buffer to
    ;; evaluate Elisp code, so we switch to Elisp mode in the scratch buffer
    ;; when Emacs is idle for 10 seconds.
    (+eval-when-idle-for! 10.0
      (setq initial-major-mode 'emacs-lisp-mode)
      (with-current-buffer (get-scratch-buffer-create)
        (emacs-lisp-mode))))

  ;; Require the virtual package to triggre loading packages depending on it
  (require 'minemacs-loaded))

;; Add it to the very begining of `emacs-startup-hook'
(add-hook 'emacs-startup-hook #'+minemacs--loaded-h -101)

;; ========= Load MinEmacs packages and user customization =========
;; When running in an async Org export context, the used modules are set in
;; modules/extras/me-org-export-async-init.el, so we must not overrite them with
;; the user's enabled modules.
(if (featurep 'me-org-export-async-init)
    (progn (message "Loading \"init.el\" in an org-export-async context.")
           (setq minemacs-not-lazy t)
           (require 'minemacs-loaded))
  ;; Load the default list of enabled modules (`minemacs-modules' and `minemacs-core-modules')
  (+load minemacs-core-dir "me-modules.el")

  ;; The modules.el file can override minemacs-modules and minemacs-core-modules
  (let ((user-conf-modules (concat minemacs-config-dir "modules.el")))
    (when (file-exists-p user-conf-modules)
      (+load user-conf-modules))))

;; Load fonts early (they are read from the default `minemacs-default-fonts').
(+set-fonts)

;; NOTE: Ensure the `me-gc' module is in the core modules list. This module
;; enables the `gcmh-mode' package (a.k.a. the Garbage Collector Magic Hack).
;; This GCMH minimizes GC interference with the activity by using a high GC
;; threshold during normal use, then when Emacs is idling, GC is triggered and a
;; low threshold is set. In MinEmacs, we set the threshold (`gc-cons-threshold'
;; variable) to an unlimited size in "early-init.el", this helps improving the
;; startup time, but needs to be set down to a more reasonable value after Emacs
;; gets loaded. The use of `gcmh-mode' ensures reverting this value so we don't
;; need to do it manually.
;; NOTE: Ensure the `me-defaults', `me-splash', `me-bootstrap' and `me-compat'
;; modules are in the right order. The `me-compat' should be loaded just after
;; `me-bootstrap' once `straight' and `use-package' are set up. This enables us
;; to use some of the new Emacs 29 functions even on earlier Emacs versions,
;; this can be useful when configuring the module's packages and adding new
;; functionality.
(setq minemacs-core-modules
      (delete-dups
       (append
        '(me-defaults)
        (when (memq 'me-splash minemacs-core-modules) '(me-splash))
        '(me-bootstrap)
        (when (< emacs-major-version 29) '(me-compat))
        '(me-builtin me-gc)
        minemacs-core-modules)))

;; Load MinEmacs modules
(dolist (module-file (append
                      (mapcar (apply-partially #'format "%s%s.el" minemacs-core-dir) minemacs-core-modules)
                      (mapcar (apply-partially #'format "%s%s.el" minemacs-modules-dir) minemacs-modules)))
  (+load module-file))

;; Write user custom variables to separate file instead of "init.el"
(setq custom-file (concat minemacs-config-dir "custom-vars.el"))

;; Load the custom variables file if it exists
(when (file-exists-p custom-file)
  (+load custom-file))

;; Load user configuration from "$MINEMACSDIR/config.el" when available
(let ((user-config (concat minemacs-config-dir "config.el")))
  (when (file-exists-p user-config)
    (+load user-config)))

(+lazy-when! (featurep 'native-compile)
  (+info! "Trying to clean outdated native compile cache")
  ;; Delete outdated natively compiled files when Emacs become idle
  (+shutup! (native-compile-prune-cache)))

(+log! "Loaded init.el")

#+end_src
** init.el =TAIL=
#+begin_src emacs-lisp
;;; init.el ends here
#+end_src
* core/
=core= 目录下是框架的核心配置
** me-backports-29.el
:properties:
:header-args: :tangle core/me-backports-29.el
:end:
=me-backports-29.el= 一些emacs29的函数
*** me-backports-29.el =HEAD=
#+begin_src emacs-lisp
;;; me-backports-29.el --- Some Emacs 29 functionalities ported back to Emacs 28 -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-backports-29.el emacs29函数
#+begin_src emacs-lisp
;; MinEmacs is distributed under the MIT license. However, this file is mostly a
;; copy-and-paste from Emacs 29 with some adaptations, hence, it is licensed
;; with original Emacs GNU GPL-3.0 license.

(when (>= emacs-major-version 29)
  (user-error "This file should only be called from an Emacs 28.x"))

(require 'wid-edit) ;; Needed by `setopt--set'

;; This macro is provided by `compat'. However, it is used in some core
;; functions which might get called before `me-bootstrap' and `me-compat'.
(defmacro with-memoization (place &rest code)
  "Return the value of CODE and stash it in PLACE.
If PLACE's value is non-nil, then don't bother evaluating CODE
and return the value found in PLACE instead."
  (declare (indent 1) (debug (gv-place body)))
  (gv-letplace (getter setter) place
    `(or
      ,getter
      ,(macroexp-let2 nil val (macroexp-progn code)
        `(progn
           ,(funcall setter val)
           ,val)))))

;; Functions not provided by `compat'
(defun startup-redirect-eln-cache (cache-directory)
  "Redirect the user's eln-cache directory to CACHE-DIRECTORY.
CACHE-DIRECTORY must be a single directory, a string.
This function destructively changes `native-comp-eln-load-path'
so that its first element is CACHE-DIRECTORY.  If CACHE-DIRECTORY
is not an absolute file name, it is interpreted relative
to `user-emacs-directory'.
For best results, call this function in your early-init file,
so that the rest of initialization and package loading uses
the updated value."
  ;; Remove the original eln-cache.
  (setq native-comp-eln-load-path (cdr native-comp-eln-load-path))
  ;; Add the new eln-cache.
  (push (expand-file-name (file-name-as-directory cache-directory)
                          user-emacs-directory)
        native-comp-eln-load-path))

(defun scratch-buffer ()
  "Switch to the *scratch* buffer.
If the buffer doesn't exist, create it first."
  (interactive)
  (pop-to-buffer-same-window (get-scratch-buffer-create)))

(defun native-compile-prune-cache ()
  "Remove .eln files that aren't applicable to the current Emacs invocation."
  (interactive)
  (unless (featurep 'native-compile)
    (user-error "This Emacs isn't built with native-compile support"))
  ;; The last item in native-comp-eln-load-path is assumed to be a system
  ;; directory, so don't try to delete anything there (bug#59658).
  (dolist (dir (butlast native-comp-eln-load-path))
    ;; If a directory is non absolute it is assumed to be relative to
    ;; `invocation-directory'.
    (setq dir (expand-file-name dir invocation-directory))
    (when (file-exists-p dir)
      (dolist (subdir (seq-filter
                       (lambda (f) (not (string-match (rx "/." (? ".") eos) f)))
                       (directory-files dir t)))
        (when (and (file-directory-p subdir)
                   (file-writable-p subdir)
                   (not (equal (file-name-nondirectory
                                (directory-file-name subdir))
                               comp-native-version-dir)))
          (message "Deleting `%s'..." subdir)
          ;; We're being overly cautious here -- there shouldn't be
          ;; anything but .eln files in these directories.
          (dolist (eln (directory-files subdir t "\\.eln\\(\\.tmp\\)?\\'"))
            (when (file-writable-p eln)
              (delete-file eln)))
          (when (directory-empty-p subdir)
            (delete-directory subdir))))))
  (message "Cache cleared"))

(defmacro setopt (&rest pairs)
  "Set VARIABLE/VALUE pairs, and return the final VALUE.
This is like `setq', but is meant for user options instead of
plain variables.  This means that `setopt' will execute any
`custom-set' form associated with VARIABLE."
  (declare (debug setq))
  (unless (zerop (mod (length pairs) 2))
    (error "PAIRS must have an even number of variable/value members"))
  (let ((expr nil))
    (while pairs
      (unless (symbolp (car pairs))
        (error "Attempting to set a non-symbol: %s" (car pairs)))
      (push `(setopt--set ',(car pairs) ,(cadr pairs))
            expr)
      (setq pairs (cddr pairs)))
    (macroexp-progn (nreverse expr))))

(defun setopt--set (variable value)
  (custom-load-symbol variable)
  ;; Check that the type is correct.
  (when-let ((type (get variable 'custom-type)))
    (unless (widget-apply (widget-convert type) :match value)
      (warn "Value `%S' does not match type %s" value type)))
  (put variable 'custom-check-value (list value))
  (funcall (or (get variable 'custom-set) #'set-default) variable value))

;; Variable aliases
(when (featurep 'native-compile)
  (defvaralias 'native-comp-jit-compilation 'native-comp-deferred-compilation)
  (defvaralias 'native-comp-jit-compilation-deny-list 'native-comp-deferred-compilation-deny-list))

(defvar messages-buffer-name "*Messages*")

;; Function aliases
(defalias 'string-split #'split-string)
(defalias 'loaddefs-generate #'make-directory-autoloads)
#+end_src
*** me-backports-29.el =TAIL=
#+begin_src emacs-lisp
(provide me-backports-29)
;;; me-backports-29.el ends here
#+end_src
** me-bootstrap.el
:properties:
:header-args: :tangle core/me-bootstrap.el
:end:
=me-bootstrap.el= 设置包下载器和包安装器
*** me-bootstrap.el =HEAD=
#+begin_src emacs-lisp
;; me-bootstrap.el --- Bootstrap packages (straight & use-package) -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-bootstrap.el 安装 =straight= 包下载器
#+begin_src emacs-lisp
(setq
 ;; Base directory
 straight-base-dir minemacs-local-dir
 ;; Add Emacs version and the Git hash to the build directory to avoid problems
 straight-build-dir (format "build-%s%s" emacs-version
                            (if emacs-repository-version
                                (format "-%s" (substring emacs-repository-version 0 8))
                              ""))
 ;; Use the "develop" branch on straight.el's repo.
 straight-repository-branch (if (>= emacs-major-version 29) "develop" "master")
 ;; Do not slow startup by checking for package modifs, check only on demand
 straight-check-for-modifications '(check-on-save find-when-checking))

;; Bootstraping straight.el
;; See: github.com/radian-software/straight.el#bootstrapping-straightel
(defvar bootstrap-version)
(let ((bootstrap-file (concat straight-base-dir "straight/repos/straight.el/bootstrap.el"))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src
*** me-bootstarp.el 安装 =use-package= 包管理器
#+begin_src emacs-lisp
;; Configure `use-package'
(unless (require 'use-package nil t)
  (straight-use-package 'use-package))

;; Add the `:pin-ref' extension to `use-package'
(require 'me-use-package-pin-ref)

(setq
 ;; Set `use-package' to verbose when MinEmacs is started in verbose mode
 use-package-verbose minemacs-verbose
 ;; Defer loading packages by default, use `:demand' to force loading a package
 use-package-always-defer t)
#+end_src
*** me-bootstarp.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-bootstrap)
;;; me-bootstrap.el ends here
#+end_src
** me-buildin.el
:properties:
:header-args: :tangle core/me-buildin.el
:end:
=me-buildin.el= 管理一些内置包
*** me-buildin.el =HEAD=
#+begin_src emacs-lisp
;;; me-builtin.el --- Customization of some of Emacs' builtin libraries -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-buildin.el buildin libraries
#+begin_src emacs-lisp
(use-package transient
  :straight (:type built-in)
  :config
  ;; Map ESC and q to quit transient
  (define-key transient-map [escape]  #'transient-quit-one)
  (define-key transient-map (kbd "q") #'transient-quit-one))

(use-package map
  :straight (:type built-in))

(use-package let-alist
  :straight (:type built-in))
#+end_src
*** me-buildin.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-buildin)
;;; me-buildin ends here
#+end_src
** me-compat.el
:properties:
:header-args: :tangle core/me-compat.el
:end:
=me-compat.el= 向前兼容的能力
*** me-compat.el =HEAD=
#+begin_src emacs-lisp
;;; me-compat.el --- Emacs forward compatibility layer -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-compat.el package [[https://github.com/emacs-compat/compat][compat]]
#+begin_src emacs-lisp
(use-package compat
  :straight t
  :demand t)
#+end_src
*** me-compat.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-compat)
;;; me-compat ends here
#+end_src
** me-completion.el
:properties:
:header-args: :tangle core/me-completion.el
:end:
=me-completion.el= 补全相关包
*** me-completion.el =HEAD=
#+begin_src emacs-lisp
;;; completion.el --- Completion packages -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-completion.el pacakge [[https://github.com/minad/cape/][cape]]  完成后端
#+begin_src emacs-lisp
(use-package cape
  :straight t
  :after minemacs-loaded
  :demand t
  :config
  (dolist (fn '(cape-file cape-ispell cape-symbol cape-keyword))
    (add-to-list 'completion-at-point-functions fn)))
#+end_src
*** me-completion.el package [[https://github.com/minad/corfu][corfu]] 完成前端
#+begin_src emacs-lisp
(use-package corfu
  :straight t
  :hook (minemacs-after-startup . global-corfu-mode)
  :init
  (add-to-list
   'load-path
   (format "%sstraight/%s/corfu/extensions" straight-base-dir straight-build-dir))
  :custom
  (corfu-auto t) ; Enable auto completion
  (corfu-cycle t) ; Allows cycling through candidates
  (corfu-min-width 25)
  (corfu-auto-delay 0.2)
  (corfu-exclude-modes '(org-mode markdown-mode))
  :config
  (with-eval-after-load 'evil
    (define-key corfu-map (kbd "C-j") #'corfu-next)
    (define-key corfu-map (kbd "C-k") #'corfu-previous))

  (defun +corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (setq-local corfu-auto nil) ; Enable/disable auto completion
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'+corfu-enable-in-minibuffer))
#+end_src
*** me-completion.el package [[https://elpa.gnu.org/packages/corfu.html][corfu extensions]]
#+begin_src emacs-lisp
 (use-package corfu-popupinfo
   :hook (corfu-mode . corfu-popupinfo-mode)
   :custom
   (corfu-popupinfo-delay 0.1)
   (corfu-popupinfo-max-height 15)
   :config
   (define-key corfu-map (kbd "M-p") #'corfu-popupinfo-scroll-down)
   (define-key corfu-map (kbd "M-n") #'corfu-popupinfo-scroll-up)
   (define-key corfu-map (kbd "M-d") #'corfu-popupinfo-toggle))

 (use-package corfu-history
   :hook (corfu-mode . corfu-history-mode)
   :config
   (unless (bound-and-true-p savehist-mode)
     (savehist-mode 1))
   (add-to-list 'savehist-additional-variables 'corfu-history))

 (use-package corfu-terminal
   :straight t
   :hook (corfu-mode . corfu-terminal-mode))
#+end_src
*** me-completion.el package [[https://github.com/jdtsmith/kind-icon][kind-icon]] 图标和完成前缀
#+begin_src emacs-lisp
(use-package kind-icon
   :straight t
   :after corfu
   :demand t
   :custom
   (kind-icon-default-style '(:padding 0
                              :stroke 0
                              :margin 0
                              :radius 0
                              :height 0.8
                              :scale 1.05)) ; Fix the scaling/height
   (kind-icon-use-icons (+emacs-features-p 'rsvg)) ; Use icons only in Emacs built with SVG support
   (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face          background
   (kind-icon-blend-background nil) ; Use midpoint color between foreground and background colors       ("blended")?
   :config
   (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src
*** me-completion.el package [[https://github.com/minad/consult][consult]] 搜索和导航
#+begin_src emacs-lisp
(use-package consult
  :straight t
  :hook (embark-collect-mode . consult-preview-at-point-mode)
  :custom
  ;; Use `consult-xref' for `xref-find-references'
  (xref-show-xrefs-function #'consult-xref)
  ;; Better formatting for `view-register'
  (register-preview-function #'consult-register-format)
  :init
  (define-key minibuffer-local-map (kbd "C-r") #'consult-history)
  (define-key minibuffer-local-map (kbd "S-C-v") #'consult-yank-pop)
  (global-set-key (kbd "C-s") #'consult-line)
  (+map!
    ;; buffer
    "bl"  #'consult-line
    "bb"  #'consult-buffer
    "bB"  #'consult-buffer-other-window
    "bF"  #'consult-buffer-other-frame
    "bmM" #'consult-bookmark
    "bi"  #'consult-imenu
    "bO"  #'consult-outline
    ;; file
    "fr"  #'consult-recent-file
    ;; git/vc
    "gG"  #'consult-git-grep
    ;; search
    "ss"  #'consult-ripgrep
    "sg"  #'consult-grep
    "sf"  #'consult-find
    "sM"  #'consult-man
    "st"  #'consult-locate
    "sh"  #'consult-history
    "sa"  #'consult-org-agenda
    ;; project
    "pl"  #'consult-line-multi
    "pi"  #'consult-imenu-multi
    ;; code
    "cm"  #'consult-flymake
    "cE"  #'consult-compile-error
    ;; unclassified
    "xc"  #'consult-complex-command
    ;; insert
    "iy"  #'consult-yank-from-kill-ring
    "ir"  '(nil :wk "register")
    "irr" #'consult-register
    "irl" #'consult-register-load
    "irs" #'consult-register-store
    ;; help
    "hu"  #'consult-theme
    "hI"  #'consult-info)
  (+map-local! :keymaps 'org-mode-map
    "h"   #'consult-org-heading)
  :config
  (setq-default completion-in-region-function #'consult-completion-in-region)

  ;; TWEAK: Fill the `initial' query of `consult' commands from
  ;; `thing-at-point'.
  ;; NOTE: Some `consult' commands have slightly different signature, the
  ;; `initial' argument can come first in some cases (like `consult-line') or
  ;; second in some other cases (like `condult-grep'). These two advices are
  ;; added to such family of commands so it is filled in the right place.
  (dolist (cmd '(consult-line ; `initial' comes first in these commands
                 consult-man))
    (advice-add
     cmd :around
     (defun +consult--dwim-first-arg-a (orig-fn &optional initial opt)
       (apply orig-fn
              (append
               (if (and (called-interactively-p) (not (minibufferp)))
                   (list (or initial (+region-or-thing-at-point)))
                 (list initial))
               (when opt (list opt)))))))

  (dolist (cmd '(consult-ripgrep ; `initial' comes second in these commands
                 consult-line-multi
                 consult-grep
                 consult-find))
    (advice-add
     cmd :around
     (defun +consult--dwim-second-arg-a (orig-fn &optional dir initial)
       (apply orig-fn
              (append
               (list dir)
               (if (and (called-interactively-p) (not (minibufferp)))
                   (list (or initial (+region-or-thing-at-point)))
                 (list initial))))))))
#+end_src
*** me-completion.el package [[https://github.com/oantolin/embark][embark]] TODO:
#+begin_src emacs-lisp
(use-package embark
  :straight t
  :init
  (global-set-key [remap describe-bindings] #'embark-bindings)
  (setq prefix-help-command #'embark-prefix-help-command)
  (+map! "." #'embark-act))

(use-package embark-consult
  :straight t
  :after embark consult
  :demand t)
#+end_src
*** me-completion.el package [[https://github.com/minad/marginalia][marginalia]] 旁注
#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :hook (minemacs-after-startup . marginalia-mode))

(use-package all-the-icons-completion
  :straight t
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup))
#+end_src
*** me-completion.el package [[https://github.com/oantolin/orderless][orderless]] 正则匹配
#+begin_src emacs-lisp
(use-package orderless
  :straight t
  :after minemacs-loaded
  :demand t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
*** me-completion.el package [[https://github.com/minad/vertico][vertico]] 完成UI
#+begin_src emacs-lisp
(use-package vertico
  :straight t
  :hook (minemacs-after-startup . vertico-mode)
  :custom
  (vertico-cycle t)
  (vertico-resize nil)
  (vertico-count 12)
  :init
  (add-to-list
   'load-path (concat
               straight-base-dir
               (format "straight/%s/vertico/extensions" straight-build-dir)))
  ;; In the minibuffer, "C-k" is be mapped to act like "<up>". However, in
  ;; Emacs, "C-k" have a special meaning of `kill-line'. So lets map "C-S-k"
  ;; to serve the original "C-k".
  (define-key minibuffer-local-map (kbd "C-S-k") #'kill-line)
  :config
  (with-eval-after-load 'evil
    (define-key vertico-map (kbd "C-j") #'vertico-next)
    (define-key vertico-map (kbd "C-k") #'vertico-previous)))

(use-package vertico-directory
  :after vertico
  :demand t
  :config
  (define-key vertico-map "\r" #'vertico-directory-enter)
  (define-key vertico-map "\d" #'vertico-directory-delete-char)
  (define-key vertico-map "\M-\d" #'vertico-directory-delete-word)
  (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)

  (with-eval-after-load 'evil
    (define-key vertico-map (kbd "M-h") #'vertico-directory-up)))

(use-package vertico-repeat
  :hook (minibuffer-setup . vertico-repeat-save)
  :init
  (keymap-global-set "M-R" #'vertico-repeat))
#+end_src
*** me-completion.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-completion)
;;; me-completion ends here
#+end_src
** me-core-ui.el
:properties:
:header-args: :tangle core/me-core-ui.el
:end:
=me-core-ui.el= 界面相关包
*** me-core-ui.el =HEAD=
#+begin_src emacs-lisp
;;; me-core-ui.el --- MinEmacs -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-core-ui.el 调整行号大小
#+begin_src emacs-lisp
 (defun +theme--tweaks-h (&optional _)
   "Use smaller font (75% of the default) for line numbers in graphic mode."
   (when (display-graphic-p)
     (set-face-attribute
      'line-number nil
      :background (face-attribute 'default :background)
      :height (truncate (* 0.75 (face-attribute 'default :height)))
      :weight 'semi-light)
     (set-face-attribute
      'line-number-current-line nil
      :height (truncate (* 0.75 (face-attribute 'default :height)))
      :weight 'bold)))

 ;; Apply tweaks
 (add-hook 'after-init-hook #'+theme--tweaks-h)
 (add-hook 'enable-theme-functions #'+theme--tweaks-h)

 ;; Save enabled theme
 (add-hook
  'enable-theme-functions
  (defun +theme--save-enabled-theme-h (theme)
    "Save the enabled theme to `minemacs-theme'.
 Useful for keeping track of the enabled theme."
    (setq minemacs-theme theme)))
#+end_src
*** me-core-ui.el 主题相关
#+begin_src emacs-lisp
;; Disable previously enabled custom themes before enabling a new one.
(advice-add
 'load-theme :before
 (defun +theme--disable-previous-themes-a (&rest _)
   "Disable previously enabled themes before enabling the new one."
   (mapc #'disable-theme custom-enabled-themes)))

(use-package modus-themes
  :straight (:host github :repo "protesilaos/modus-themes")
  :config
  ;; In all of the following, WEIGHT is a symbol such as `semibold',
  ;; `light', `bold', or anything mentioned in `modus-themes-weights'.
  (setq modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-mixed-fonts nil
        modus-themes-variable-pitch-ui nil
        modus-themes-custom-auto-reload t

        ;; Options for `modus-themes-prompts' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `italic', `WEIGHT'
        modus-themes-prompts '(semi-bold)

        ;; The `modus-themes-completions' is an alist that reads two
        ;; keys: `matches', `selection'.  Each accepts a nil value (or
        ;; empty list) or a list of properties that can include any of
        ;; the following (for WEIGHT read further below):
        ;; `matches'   :: `underline', `italic', `WEIGHT'
        ;; `selection' :: `underline', `italic', `WEIGHT'
        modus-themes-completions
        '((matches   . (extrabold))
          (selection . (semibold text-also)))

        modus-themes-org-blocks 'gray-background ; {nil,'gray-background,'tinted-background}

        ;; The `modus-themes-headings' is an alist: read the manual's
        ;; node about it or its doc string.  Basically, it supports
        ;; per-level configurations for the optional use of
        ;; `variable-pitch' typography, a height value as a multiple of
        ;; the base font size (e.g. 1.5), and a `WEIGHT'.
        modus-themes-headings
        '((1                . (1.4))
          (2                . (1.3))
          (3                . (1.2))
          (agenda-date      . (1.2))
          (agenda-structure . (light 1.5))
          (t                . (1.1)))

        modus-themes-common-palette-overrides
        `(;; Customize the mode-line colors
          (bg-mode-line-active bg-blue-intense)
          (fg-mode-line-active fg-main)

          ;; From the section "Make the mode line borderless"
          (border-mode-line-active unspecified)
          (border-mode-line-inactive unspecified)

          ;; From the section "Make matching parenthesis more or less intense"
          (bg-paren-match bg-blue-intense)
          (underline-paren-match unspecified)

          ;; Links
          (underline-link border)
          (underline-link-visited border)
          (underline-link-symbolic border)

          ;; Comments are yellow, strings are green
          (comment yellow-cooler)
          (string green-warmer)

          ;; And expand the preset here. Note that the ,@ works because we use
          ;; the backtick for this list, instead of a straight quote.
          ,@modus-themes-preset-overrides-faint))

  ;; Load the theme of your choice.
  (load-theme 'modus-operandi-tinted t))

(use-package all-the-icons
  :straight t
  :config
  ;; Show .m files as matlab/octave files
  (setcdr (assoc "m" all-the-icons-extension-icon-alist)
          (cdr (assoc "matlab" all-the-icons-extension-icon-alist))))

(use-package doom-themes
  :straight t)

(use-package apropospriate-theme
  :straight t)
#+end_src
*** me-core-ui.el [[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]]
#+begin_src emacs-lisp
(use-package dashboard
  :straight t
  :after evil evil-collection
  :demand t
  :init
  (+map! "oD" #'dashboard-open)
  :custom
  (dashboard-set-heading-icons t)
  (dashboard-set-file-icons t)
  (dashboard-center-content t)
  (dashboard-banner-ascii "MinEmacs")
  (dashboard-banner-logo-title "Welcome to MinEmacs!")
  (dashboard-items '((recents . 5) (projects . 5) (bookmarks . 5)))
  (dashboard-image-banner-max-width 600)
  (dashboard-projects-backend 'project-el)
  (dashboard-startup-banner (concat minemacs-assets-dir "images/minemacs.png"))
  :config
  ;; Ensure setting the keybindings before openning the dashboard
  (evil-collection-dashboard-setup)

  ;; Avoid openning the dashboard when Emacs starts with an open file.
  (when (zerop (length (seq-filter #'identity (mapcar #'buffer-file-name (buffer-list)))))
    (dashboard-open)))
#+end_src
*** me-core-ui.el doom-modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :straight t
  :hook (minemacs-after-startup . doom-modeline-mode)
  :custom
  (doom-modeline-height 35)
  (doom-modeline-bar-width 8)
  (doom-modeline-time-icon nil)
  (doom-modeline-buffer-encoding 'nondefault)
  (doom-modeline-unicode-fallback t)
  :config
  ;; HACK: Add some padding to the right
  (doom-modeline-def-modeline 'main
    '(bar workspace-name window-number modals matches follow buffer-info
      remote-host buffer-position word-count parrot selection-info)
    '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus
      github debug repl lsp minor-modes input-method indent-info buffer-encoding
      major-mode process vcs checker time "  ")))
#+end_src
*** me-core-ui.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-core-ui)
;;; me-core-ui ends here
#+end_src
** me-defaults.el
:properties:
:header-args: :tangle core/me-defaults.el
:end:
*** me-defaults.el =HEAD=
#+begin_src emacs-lisp
;;; me-defaults.el --- MinEmacs defaults for Emacs -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-defaults.el gun广告关闭
#+begin_src emacs-lisp
 ;; Inhibit startup message in echo area the brutal way!
 ;; The `inhibit-startup-echo-area-message' variable is very restrictive, there
 ;; is only one unique way of setting it right!
 ;; See: reddit.com/r/emacs/comments/6e9o4o/comment/di8q1t5
 (fset 'display-startup-echo-area-message #'ignore)
#+end_src
*** me-defaults.el 编码UTF-8
#+begin_src emacs-lisp
;;; Why use anything but UTF-8?
(prefer-coding-system 'utf-8)
(set-charset-priority 'unicode)
(set-default-coding-systems 'utf-8)
(set-locale-environment "en_US.UTF-8")
;; Use UTF-16-LE in Windows, see: rufflewind.com/2014-07-20/pasting-unicode-in-emacs-on-windows
(set-selection-coding-system (if os/win 'utf-16-le 'utf-8))
;; 配置所有的编码为UTF-8，参考：
;; https://thraxys.wordpress.com/2016/01/13/utf-8-in-emacs-everywhere-forever/
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment 'utf-8)
(set-clipboard-coding-system 'utf-8)
(set-file-name-coding-system 'utf-8)
(set-buffer-file-coding-system 'utf-8)
(modify-coding-system-alist 'process "*" 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src
*** me-defaults.el 一些默认参数的设置
#+begin_src emacs-lisp
(setq
 ;; ====== Default directories for builtin packages ======
 backup-directory-alist (list (cons "." (+directory-ensure minemacs-local-dir "backup/")))
 auto-save-list-file-prefix (+directory-ensure minemacs-local-dir "auto-save/")
 abbrev-file-name (concat minemacs-local-dir "abbrev.el")
 project-list-file (concat minemacs-local-dir "project-list.el")
 tramp-backup-directory-alist backup-directory-alist
 tramp-auto-save-directory (concat minemacs-local-dir "tramp/auto-save/")
 tramp-persistency-file-name (concat minemacs-local-dir "tramp/persistency.el")
 url-configuration-directory (+directory-ensure minemacs-local-dir "url/")
 url-cookie-file (concat minemacs-local-dir "url/cookie.el")
 url-history-file (concat minemacs-local-dir "url/history.el")
 url-cache-directory (+directory-ensure minemacs-cache-dir "url/")
 save-place-file (concat minemacs-local-dir "save-place.el")
 savehist-file (concat minemacs-local-dir "savehist.el")
 org-id-locations-file (concat minemacs-cache-dir "org/id-locations.el")
 org-persist-directory (+directory-ensure minemacs-cache-dir "org/persist/")
 org-publish-timestamp-directory (+directory-ensure minemacs-cache-dir "org/publish/timestamps/")
 org-preview-latex-image-directory (+directory-ensure minemacs-cache-dir "org/preview/latex-image/")
 recentf-save-file (concat minemacs-local-dir "recentf-save.el")
 shared-game-score-directory (+directory-ensure minemacs-local-dir "shared-game-score/")
 type-break-file-name (concat minemacs-local-dir "type-break.el")
 bookmark-default-file (concat minemacs-local-dir "bookmark.el")
 ede-project-placeholder-cache-file (concat minemacs-local-dir "ede-projects.el")
 kkc-init-file-name (concat minemacs-local-dir "kkc-init-file.el")
 erc-dcc-get-default-directory (+directory-ensure minemacs-local-dir "erc/dcc/")
 erc-log-channels-directory (+directory-ensure minemacs-local-dir "erc/log-channels/")
 eshell-directory-name (+directory-ensure minemacs-local-dir "eshell/")
 eshell-history-file-name (concat minemacs-local-dir "eshell/history.el")
 eshell-last-dir-ring-file-name (concat minemacs-local-dir "eshell/last-dir-ring.el")
 eshell-aliases-file (concat minemacs-local-dir "eshell/aliases")
 eshell-rc-script (concat minemacs-local-dir "eshell/rc")
 eshell-login-script (concat minemacs-local-dir "eshell/login")
 calc-settings-file (concat minemacs-local-dir "calc-settings.el")
 auto-insert-directory (+directory-ensure minemacs-local-dir "auto-insert/")
 image-dired-dir (+directory-ensure minemacs-local-dir "image-dired/")
 image-dired-tags-db-file (concat minemacs-local-dir "image-dired/tags-db.el")
 image-dired-temp-rotate-image-file (concat minemacs-cache-dir "image-dired/temp-rotate-image")
 eudc-options-file (concat minemacs-local-dir "eudc-options.el")
 eww-bookmarks-directory (+directory-ensure minemacs-local-dir "eww/bookmarks/")
 shadow-info-file (concat minemacs-local-dir "shadow/info.el")
 shadow-todo-file (concat minemacs-local-dir "shadow/todo.el")
 semanticdb-default-system-save-directory (concat minemacs-local-dir "semantic/")
 desktop-dirname (+directory-ensure minemacs-local-dir "desktop/")
 desktop-path (list desktop-dirname)
 custom-theme-directory (concat minemacs-config-dir "themes/")

 ;; ====== Default behavior ======
 ;; Inhibit startup message
 inhibit-startup-message t
 ;; Do not ring
 ring-bell-function #'ignore
 ;; Set to non-nil to flash!
 visible-bell nil
 ;; Increase the large file threshold to 50 MiB
 large-file-warning-threshold (* 50 1024 1024)
 ;; Initial scratch message (will be overridden if "fortune" is installed)
 initial-scratch-message ";; MinEmacs -- start here!"
 ;; Set initial buffer to fundamental-mode for faster load
 initial-major-mode 'fundamental-mode
 ;; Always prompt in minibuffer (no GUI)
 use-dialog-box nil
 ;; Use y or n instead of yes or no
 use-short-answers t
 ;; Confirm before quitting
 confirm-kill-emacs #'y-or-n-p
 ;; Filter duplicate entries in kill ring
 kill-do-not-save-duplicates t
 ;; Save existing clipboard text into the kill ring before replacing it.
 save-interprogram-paste-before-kill t
 ;; Save files only in sub-directories of current project
 save-some-buffers-default-predicate #'save-some-buffers-root
 ;; Use single space between sentences
 sentence-end-double-space nil
 ;; Move stuff to trash
 delete-by-moving-to-trash t
 ;; Select help window for faster quit!
 help-window-select t
 ;; More info on completions
 completions-deTAILed t
 ;; Do not ask obvious questions, follow symlinks
 vc-follow-symlinks t
 ;; Display the true file name for symlinks
 find-file-visit-truename t
 ;; Use completion in the minibuffer instead of definitions buffer
 xref-show-definitions-function #'xref-show-definitions-completing-read
 ;; Enable recursive calls to minibuffer
 enable-recursive-minibuffers t
 ;; Kill the shell buffer after exit
 shell-kill-buffer-on-exit t

 ;; ====== Passwords and encryption ======
 ;; Enable password caching
 password-cache t
 ;; One minute, default is 16
 password-cache-expiry 60
 ;; Default auth-sources to GPG
 auth-sources '("~/.authinfo.gpg")
 ;; Enable caching, do not keep asking about GPG key
 auth-source-do-cache t
 ;; All day, default is 2h (7200)
 auth-source-cache-expiry 86400

 ;; ====== Performances ======
 ;; Don’t compact font caches during GC
 inhibit-compacting-font-caches t
 ;; Increase single chunk bytes to read from subprocess (default 4096)
 read-process-output-max (if os/linux
                             (condition-case nil
                                 ;; Android may raise permission-denied error
                                 (with-temp-buffer
                                   (insert-file-contents
                                    "/proc/sys/fs/pipe-max-size")
                                   (string-to-number (buffer-string)))
                               ;; If an error occured, fallback to the default value
                               (error read-process-output-max))
                           (* 1024 1024))

 ;; ====== Aesthetics and UI ======
 ;; Do force frame size to be a multiple of char size
 frame-resize-pixelwise t
 ;; Stretch cursor to the glyph width
 x-stretch-cursor t
 ;; Show trailing whitespaces
 show-trailing-whitespace t
 ;; Resize window combinations proportionally
 window-combination-resize t
 ;; Enable time in the mode-line
 display-time-string-forms '((propertize (concat 24-hours ":" minutes)))
 ;; Relative line numbering
 display-line-numbers-type 'relative
 ;; No ugly button for widgets
 widget-image-enable nil
 ;; Show unprettified symbol under cursor (when in `prettify-symbols-mode')
 prettify-symbols-unprettify-at-point t
 ;; Make tooltips last a bit longer (default 10s)
 tooltip-hide-delay 20
 ;; Use small frames to display tooltips instead of the default OS tooltips
 use-system-tooltips nil

 ;; ====== Undo ======
 ;; 10MB (default is 160kB)
 undo-limit 10000000
 ;; 50MB (default is 240kB)
 undo-strong-limit 50000000
 ;; 150MB (default is 24MB)
 undo-outer-limit 150000000

 ;; ====== Editing ======
 ;; Hitting TAB behavior
 tab-always-indent nil
 ;; Default behavior for `whitespace-cleanup'
 whitespace-action '(cleanup auto-cleanup)
 ;; End files with newline
 require-final-newline t
 ;; Enable Drag-and-Drop of regions
 mouse-drag-and-drop-region t
 ;; Enable Drag-and-Drop of regions from Emacs to external programs
 mouse-drag-and-drop-region-cross-program t

 ;; ====== Backups ======
 ;; Disable lockfiles
 create-lockfiles nil
 ;; Enable making backup files
 make-backup-files t
 ;; Number each backup file
 version-control t
 ;; Copy instead of renaming current file
 backup-by-copying t
 ;; Clean up after itself
 delete-old-versions t
 ;; Keep up to 5 old versions of each file
 kept-old-versions 5
 ;; Keep up to 5 new versions of each file
 kept-new-versions 5
 ;; Keep up to 5 versions when cleaning a directory
 dired-kept-versions 5

 ;; ====== Scrolling ======
 ;; Do not adjust window-vscroll to view tall lines. Fixes some lag issues see:
 ;; emacs.stackexchange.com/a/28746
 auto-window-vscroll nil
 ;; Fast scrolling
 fast-but-imprecise-scrolling t
 ;; Keep the point in the same position while scrolling
 scroll-preserve-screen-position t
 ;; Do not move cursor to the center when scrolling
 scroll-conservatively 101
 ;; Scroll at a margin of one line
 scroll-margin 1
 ;; Better scrolling on Emacs29+, specially on a touchpad
 pixel-scroll-precision-use-momentum t

 ;; ====== Recent files ======
 ;; Increase the maximum number of saved items
 recentf-max-saved-items 100
 ;; Ignore case when searching recentf files
 recentf-case-fold-search t
 ;; Exclude some files from being remembered by recentf
 recentf-exclude
 `(,(rx (* any)
     (or
      "elfeed-db"
      "eln-cache"
      "/cache/"
      ".maildir/"
      ".cache/")
     (* any)
     (? (or "html" "pdf" "tex" "epub")))
   ,(rx "/"
     (or "rsync" "ssh" "tmp" "yadm" "sudoedit" "sudo")
     (* any)))

 ;; ====== Timestamps ======
 ;; Do enable time-stamps
 time-stamp-active t
 ;; Check the first 12 buffer lines for Time-stamp: <>
 time-stamp-line-limit 12
 ;; Timestamp format
 time-stamp-format "%04Y-%02m-%02d %02H:%02M:%02S"

 ;; ====== Auto-Saving, sessions ======
 ;; Enable auto-save (use `recover-file' or `recover-session' to recover)
 auto-save-default t
 ;; Include big deletions
 auto-save-include-big-deletions t
 ;; Set file naming transform
 auto-save-file-name-transforms (list
                                 ;; Prefix tramp autosaves with "tramp-"
                                 (list
                                  "\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'"
                                  (concat auto-save-list-file-prefix "tramp-\\2") t)
                                 ;; Local autosaves
                                 (list ".*" auto-save-list-file-prefix t))
 ;; File name to use when saving desktop
 desktop-base-file-name "emacs-session.el"
 ;; File name to use as a lock
 desktop-base-lock-name (concat desktop-base-file-name ".lock")
 ;; Load only 5 buffers immediately, the remaining buffers will be loaded lazily
 desktop-restore-eager 5
 ;; Avoid writing contents unchanged between auto-saves
 desktop-file-checksum t

 ;; ====== Compilation ======
 ;; Scroll compilation buffer
 compilation-scroll-output t ; 'first-error can be a good option
 ;; Always kill current compilation process before starting a new one
 compilation-always-kill t
 ;; Skip visited messages on compilation motion commands
 compilation-skip-visited t
 ;; Keep it readable
 compilation-window-height 12

 ;; ====== Misc ======
 ;; Set `webjump' sites to manily search engins
 webjump-sites
 '(("Emacs Wiki"    . [simple-query "www.emacswiki.org" "www.emacswiki.org/cgi-bin/wiki/" ""])
   ("DuckDuckGo"    . [simple-query "duckduckgo.com" "duckduckgo.com/?q=" ""])
   ("Qwant"         . [simple-query "www.qwant.com" "www.qwant.com/?q=" ""])
   ("Ecosia"        . [simple-query "www.ecosia.org" "www.ecosia.org/search?q=" ""])
   ("Brave"         . [simple-query "search.brave.com" "search.brave.com/search?q=" ""])
   ("Bing"          . [simple-query "www.bing.com" "www.bing.com/search?q=" ""])
   ("Yahoo"         . [simple-query "www.yahoo.com" "search.yahoo.com/search?p=" ""])
   ("Google"        . [simple-query "www.google.com" "www.google.com/search?q=" ""])
   ("Google Maps"   . [simple-query "www.google.com" "www.google.com/maps?q=" ""])
   ("Google Images" . [simple-query "www.google.com" "www.google.com/images?q=" ""])
   ("Google Groups" . [simple-query "groups.google.com" "groups.google.com/groups?q=" ""])
   ("StackOverflow" . [simple-query "stackoverflow.com" "stackoverflow.com/search?q=" ""])
   ("GitHub Repo"   . [simple-query "github.com" "github.com/search?type=repositories&q=" ""])
   ("GitHub Code"   . [simple-query "github.com" "github.com/search?type=code&q=" ""])
   ("WolframAlpha"  . [simple-query "wolframalpha.com" "wolframalpha.com/input/?i=" ""])
   ("MDN"           . [simple-query "developer.mozilla.org" "developer.mozilla.org/search?q=" ""])
   ("Youtube"       . [simple-query "www.youtube.com" "www.youtube.com/results?search_query=" ""])
   ("Reddit"        . [simple-query "www.reddit.com" "www.reddit.com/search/?q=" ""])
   ("Wikipedia"     . [simple-query "wikipedia.org" "wikipedia.org/wiki/" ""])))

(setq-default
 ;; ====== Buffer-local variables ======
 ;; Display long lines
 truncate-lines nil
 ;; Default fill column width
 fill-column 80
 ;; Never mix, use only spaces
 indent-tabs-mode nil
 ;; Width for line numbers
 display-line-numbers-width 4
 ;; Small tab is enough!
 tab-width 2
 ;; Save buffer status
 desktop-save-buffer t)

;; ====== Misc hooks and advices ======
;; Advice `emacs-session-filename' to ensure creating "session.ID" files in
;; a sub-directory
(with-eval-after-load 'x-win
  (advice-add
   #'emacs-session-filename :filter-return
   (defun +emacs-session-filename--in-subdir-a (session-filename)
     "Put the SESSION-FILENAME in the \"x-win/\" sub-directory."
     (concat (+directory-ensure minemacs-local-dir "x-win/")
             (file-name-nondirectory session-filename)))))

;; Kill `term' buffer on exit (reproduce a similar behavior to `shell's
;; `shell-kill-buffer-on-exit').
(advice-add
 'term-sentinel :around
 (defun +term--kill-after-exit-a (orig-fn proc msg)
   (if (memq (process-status proc) '(signal exit))
       (let ((buffer (process-buffer proc)))
         (apply orig-fn (list proc msg))
         (kill-buffer buffer))
     (apply orig-fn (list proc msg)))))

;; Kill the minibuffer when switching by mouse to another window.
;; Adapted from: trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
(add-hook
 'mouse-leave-buffer-hook
 (defun +minibuffer--kill-on-mouse-h ()
   "Kill the minibuffer when switching to window with mouse."
   (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
     (abort-recursive-edit))))

;; ====== Tweaks on file save ======
;; Update time stamp (if available) before saving a file.
(add-hook 'before-save-hook 'time-stamp)

(defcustom +whitespace-auto-cleanup-modes
  '(prog-mode conf-mode org-mode markdown-mode
    latex-mode tex-mode bibtex-mode)
  "Enable auto white space cleanup before saving for these derived modes."
  :group 'minemacs-edit
  :type '(repeat symbol))

;; Auto-remove trailing white spaces before saving for modes defined in
;; `+whitespace-auto-cleanup-modes'.
(add-hook
 'before-save-hook
 (defun +save--whitespace-cleanup-h ()
   (when (cl-some #'derived-mode-p +whitespace-auto-cleanup-modes)
     (whitespace-cleanup))))

;; Guess the major mode after saving a file in `fundamental-mode' (adapted
;; from Doom Emacs).
(add-hook
 'after-save-hook
 (defun +save--guess-file-mode-h ()
   "Guess major mode when saving a file in `fundamental-mode'.
Likely, something has changed since the buffer was opened. e.g. A shebang line
or file path may exist now."
   (when (eq major-mode 'fundamental-mode)
     (let ((buffer (or (buffer-base-buffer) (current-buffer))))
       (and (buffer-file-name buffer)
            (eq buffer (window-buffer (selected-window))) ;; Only visible buffers
            (set-auto-mode))))))

;; ====== Modes enabled locally, mainly for `prog-mode', `conf-mode' and `text-mode' ======
;; Show line numbers
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'conf-mode-hook #'display-line-numbers-mode)
(add-hook 'text-mode-hook #'display-line-numbers-mode)

;; Highlight the current line
(add-hook 'prog-mode-hook #'hl-line-mode)
(add-hook 'conf-mode-hook #'hl-line-mode)
(add-hook 'text-mode-hook #'hl-line-mode)

;; Hide/show code blocks, a.k.a. code folding
(add-hook 'prog-mode-hook #'hs-minor-mode)
(add-hook 'conf-mode-hook #'hs-minor-mode)

;; Wrap long lines
(add-hook 'prog-mode-hook #'visual-line-mode)
(add-hook 'conf-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'visual-line-mode)

;; When MinEmacs is running in an asynchronous Org export context, there is no
;; need to enable these modes. So we load them only if we haven't been launched
;; through the `me-org-export-async-init' file.
;; All modes and tweaks are enabled after MinEmacs is gets loaded
(+deferred-unless! (featurep 'me-org-export-async-init)
  ;; Navigate windows using Shift+Direction
  (windmove-default-keybindings)

  ;; ====== Modes enabled globally ======
  ;; Show the battery status (if available) in the mode-line
  (+shutup!
   (let ((battery-str (battery)))
     (unless (or (equal "Battery status not available" battery-str)
                 (string-match-p "unknown" battery-str)
                 (string-match-p "N/A" battery-str))
       (display-battery-mode 1))))

  ;; Fallback the new `fido-vertical-mode' Emacs28+ builtin completion mode if
  ;; the `me-completion' (which contains `vertico-mode' configuration) core
  ;; module is not enabled.
  (unless (memq 'me-completion minemacs-core-modules)
    (fido-vertical-mode 1))

  ;; Window layout undo/redo (`winner-undo' / `winner-redo')
  (winner-mode 1)

  ;; Scroll pixel by pixel, in Emacs29+ there is a more pricise mode way to scroll
  (if (>= emacs-major-version 29)
      (pixel-scroll-precision-mode 1)
    (pixel-scroll-mode 1))

  ;; Display time in mode-line
  (display-time-mode 1)

  ;; Replace selection after start typing
  (delete-selection-mode 1)

  ;; Enable `recentf-mode' to remember recent files
  (+shutup! (recentf-mode 1))

  ;; Show recursion depth in minibuffer (see `enable-recursive-minibuffers')
  (minibuffer-depth-indicate-mode 1)

  ;; Save place in files
  (save-place-mode 1)

  ;; Enable saving minibuffer history
  (savehist-mode 1)

  ;; Auto load files changed on disk
  (global-auto-revert-mode 1)

  ;; Show line number in mode-line
  (line-number-mode 1)

  ;; Show column numbers (a.k.a. cursor position) in the mode-line
  (column-number-mode 1)

  ;; Better handling for files with so long lines
  (global-so-long-mode 1)

  ;; Save Emacs state from one session to another
  (desktop-save-mode 1)

  ;; Global SubWord mode
  (global-subword-mode 1))
#+end_src
*** me-defaults.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-defaults)
;;; me-defaults ends here
#+end_src
** me-evil.el
:properties:
:header-args: :tangle core/me-evil.el
:end:
=me-evil.el= Emacs as Vim
*** me-evil.el =HEAD=
#+begin_src emacs-lisp
;;; me-evil.el --- Emacs as Vim! -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-evil.el pacakge =evil=
#+begin_src emacs-lisp
(use-package evil
  :straight t
  :hook (minemacs-after-startup . evil-mode)
  :preface
  (setq evil-want-keybinding nil)
  :custom
  (evil-want-C-i-jump nil)
  (evil-want-fine-undo t)
  (evil-want-Y-yank-to-eol t)
  (evil-split-window-below t)
  (evil-vsplit-window-right t)
  (evil-kill-on-visual-paste nil)
  (evil-respect-visual-line-mode t)
  (evil-ex-interactive-search-highlight 'selected-window)
  :config
  (+map!
    ;; buffer
    "bN" '(evil-buffer-new :wk "New buffer")
    ;; window
    "ww" '(evil-window-next :wk "Next")
    "wW" '(evil-window-prev :wk "Previous")
    "ws" '(evil-window-split :wk "Split")
    "wv" '(evil-window-vsplit :wk "Vertical split")
    "wr" '(evil-window-rotate-downwards :wk "Rotate downwards")
    "wR" '(evil-window-rotate-upwards :wk "Rotate upwards")
    "w+" '(evil-window-increase-width :wk "Increase width")
    "w-" '(evil-window-decrease-width :wk "Decrease width"))

  ;; Use `evil-search' instead of `isearch'
  (evil-select-search-module 'evil-search-module 'evil-search)

  ;; Ask for a buffer when splitting windows
  (with-eval-after-load 'consult
    (dolist (fn '(evil-window-split evil-window-vsplit))
      (advice-add
       fn :after
       (defun +evil--cunsult-buffer-after-window-split-a (&rest _)
         (consult-buffer))))))
#+end_src
*** me-evil.el pacakge =evil-collection=
#+begin_src emacs-lisp
(use-package evil-collection
  :straight t
  :after evil minemacs-loaded
  :demand t
  :config
  (evil-collection-init
   (seq-filter
    (lambda (mode)
      (not (memq mode '(evil-mc ; Default bindings for `evil-mc' are messy
                        mu4e ; TEMP: until `evil-collection-mu4e' gets fixed, see github.com/emacs-evil/evil-collection/issues/695
                        elisp-mode)))) ; I don't like "gz" for `ielm', I like "gr" though
    evil-collection-mode-list))

  ;; Use "gr" to find references for elisp mode
  (with-eval-after-load 'elisp-mode
    (when evil-collection-want-find-usages-bindings
      (evil-collection-define-key 'normal 'emacs-lisp-mode-map
        "gr" 'xref-find-references)))

  ;; TEMP: Fix `mu4e' evil integraion
  (with-eval-after-load 'mu4e
    (require 'loadhist) ; to use `feature-file'

    ;; To avoid calling `evil-collection-mu4e--main-action-str'
    (defvar evil-collection-mu4e-new-region-basic nil)

    (require 'evil-collection-mu4e
             (concat (file-name-directory (feature-file 'evil-collection))
                     "modes/mu4e/evil-collection-mu4e.el"))

    (evil-collection-mu4e-set-state)
    (evil-collection-mu4e-set-bindings)

    ;; Fix some missed up bindings
    (defalias 'mu4e~view-quit-buffer #'mu4e-view-quit)

    (add-hook 'org-mode-hook #'evil-collection-mu4e-org-set-HEAD-to-normal-mode)
    (add-hook 'mu4e-compose-pre-hook #'evil-collection-mu4e-org-set-HEAD-to-insert-mode)))
#+end_src
*** me-evil.el pacakge =evil-snipe=
#+begin_src emacs-lisp
(use-package evil-snipe
  :straight t
  :hook (minemacs-after-startup . evil-snipe-mode)
  :hook (minemacs-after-startup . evil-snipe-override-mode)
  :custom
  (evil-snipe-scope 'buffer)
  (evil-snipe-smart-case t)
  (evil-snipe-auto-scroll t))
#+end_src
*** me-evil.el package =evil-numbers=
#+begin_src emacs-lisp
 (use-package evil-numbers
   :straight t
   :init
   (+nmap!
     "g+" #'evil-numbers/inc-at-pt
     "g=" #'evil-numbers/inc-at-pt
     "g-" #'evil-numbers/dec-at-pt)
   (+vmap!
     "g+" #'evil-numbers/inc-at-pt-incremental
     "g=" #'evil-numbers/inc-at-pt-incremental
     "g-" #'evil-numbers/dec-at-pt-incremental))
#+end_src
*** me-evil.el package =evil-nerd-commenter=
#+begin_src emacs-lisp
 (use-package evil-nerd-commenter
   :straight t
   :commands evilnc-comment-operator
   :init
   (+nvmap! "gc" #'evilnc-comment-operator))
#+end_src
*** me-evil.el pacakge =evil-escape=
#+begin_src emacs-lisp
 (use-package evil-escape
   :straight t
   :hook (evil-mode . evil-escape-mode)
   :custom
   ;; The default "fd" interfere with the "f" (bound to `evil-snipe-f') binding.
   (evil-escape-key-sequence "kj")
   (evil-escape-unordered-key-sequence t)) ; "kj" or "jk"
#+end_src
*** me-evil.el pacakge =evil-surround=
#+begin_src emacs-lisp
(use-package evil-surround
  :straight t
  :demand t
  :config
  (global-evil-surround-mode 1))
#+end_src
*** me-evil.el =TAIL=
#+begin_src emacs-lisp
(provide me-evil)
;;; me-evil ends here
#+end_src
** me-gc.el
:properties:
:header-args: :tangle core/me-gc.el
:end:
=me-gc.el=  garbage collection 垃圾回收
*** me-gc.el =HEAD=
#+begin_src emacs-lisp
;;; me-gc.el --- garbage collection -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-gc.el package gcmh
#+begin_src emacs-lisp
 (use-package gcmh
   :straight t
   :hook (minemacs-lazy . gcmh-mode)
   :custom
   ;; Set the delay to 20s instead of the default 15. I tried using `auto', but
   ;; with the default 20 of `gcmh-auto-idle-delay-factor', it triggers GC each
   ;; 1s on my machine. Setting the factor to a higher value should solve the
   ;; issue on my machine, but I don't think it is right to assume it will work
   ;; the same way on other machines. So we switch back to a fixed delay of 20s.
   (gcmh-idle-delay 20)
   ;; The default `gcmh's 1GB is probably too high. We set it to 256MB on 64bit
   ;; systems, or 16MB on 32bit ones.
   (gcmh-high-cons-threshold
    (* 1024 1024 (if (string-suffix-p "64" (symbol-name sys/arch)) 256 16))))
#+end_src
*** me-gc.el =TAIL=
#+begin_src emacs-lisp
(provide me-gc)
;;; me-gc ends here
#+end_src
** me-keybindings.el
:properties:
:header-args: :tangle core/me-keybindings.el
:end:
=me-keybindings.el= 按键相关包
*** me-keybindings.el =HEAD=
#+begin_src emacs-lisp
;;; me-keybindings.el --- Default keybindings -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-keybindings.el package =which-key=
#+begin_src emacs-lisp
 (use-package which-key
   :straight t
   :hook (minemacs-after-startup . which-key-mode)
   :custom
   (which-key-idle-delay 1.0)
   (which-key-idle-secondary-delay nil)
   (which-key-ellipsis "..")
   (which-key-prefix-prefix "+")
   (which-key-sort-order 'which-key-key-order-alpha)
   (which-key-min-display-lines 3)
   (which-key-max-display-columns nil)
   ;; Allow a key binding to be modified by multiple rules in
   ;; `which-key-replacement-alist'
   (which-key-allow-multiple-replacements t)
   :config
   (setq
    which-key-replacement-alist
    (append
     which-key-replacement-alist
     (list
      '(("\\`g z" . "\\`evil-\\(?:mc\\|multiedit\\)-\\(.*\\)")    . (nil . "⌶·\\1"))
      '(("\\`g c" . "\\`evilnc-\\(.*\\)")                         . (nil . "#·\\1"))
      '(("\\`g" . "\\`[Ii]nfo[-:]?\\(?:a-\\)?\\(.*\\)")           . (nil . "ɩ·\\1"))
      '(("\\`SPC TAB" . "\\`tabspaces-\\(.*\\)")                  . (nil . "⭾·\\1"))
      '(("\\`SPC p" . "\\`\\+?\\(?:consult-\\)?project-\\(.*\\)") . (nil . "🅟·\\1"))
      '(("" . "\\`evil[-:]?\\(?:a-\\)?\\(.*\\)")                  . (nil . "ɛ·\\1")))))
   ;; Setup `which-key' integration with the minibuffer
   (which-key-setup-minibuffer))
#+end_src
*** me-keybindings.el package =general=
#+begin_src emacs-lisp
(use-package general
  :straight t
  ;; PERF: Loading `general' early make Emacs very slow on startup.
  :after evil
  :demand t
  :config
  ;; Advise `define-key' to automatically unbind keys when necessary.
  (general-auto-unbind-keys)
  ;; Set up some basic equivalents (like `general-nmap') with short named
  ;; aliases (like `nmap') for VIM mapping functions.
  (general-evil-setup t)

  ;; Global leader
  (general-create-definer +minemacs--internal-map!
    ;; The order of states matters, the last is prioritized
    :states '(insert emacs visual normal)
    :keymaps 'override
    :prefix minemacs-leader-key
    :global-prefix minemacs-global-leader-prefix)

  ;; Local leader
  (general-create-definer +minemacs--internal-map-local!
    :states '(insert emacs visual normal)
    :keymaps 'override
    :prefix minemacs-localleader-key
    :global-prefix minemacs-global-mode-prefix)

  ;; Define the built-in global keybindings
  (+minemacs--internal-map!
    ;; ====== Top level functions ======
    "SPC" '(execute-extended-command :wk "M-x")
    ">"   '(switch-to-next-buffer :wk "Next buffer")
    "<"   '(switch-to-prev-buffer :wk "Previous buffer")
    ";"   '(pp-eval-expression :wk "Eval expression")
    "X"   #'org-capture
    "u"   '(universal-argument :wk "C-u")
    "C"   #'universal-coding-system-argument

    ;; ====== Quit/Session ======
    "q"   '(nil :wk "quit/session")
    "qq"  #'save-buffers-kill-terminal
    "qQ"  #'kill-emacs
    "qS"  #'server-start
    "qR"  #'recover-session
    "qd"  #'desktop-read
    "qD"  #'desktop-lazy-complete
    "qs"  #'desktop-save

    ;; ====== Files ======
    "f"   '(nil :wk "file")
    "fS"  '(write-file :wk "Save as ...")
    "fD"  #'+delete-this-file
    "fu"  #'+sudo-find-file
    "fU"  #'+sudo-this-file
    "fR"  #'+move-this-file
    "ff"  #'find-file
    "fs"  #'save-buffer
    "ft"  #'recover-this-file
    "fT"  #'recover-file
    "fy"  #'+yank-this-file-name
    "fE"  `(,(+cmdfy! (dired (or minemacs-config-dir minemacs-root-dir)))
            :wk "User config directory")

    ;; ====== Buffers ======
    "b"   '(nil :wk "buffer")
    "bI"  #'ibuffer
    "bu"  #'+sudo-save-buffer
    "bS"  #'save-some-buffers
    "bs"  #'scratch-buffer
    "bM"  #'view-echo-area-messages
    "bA"  #'+kill-some-buffers
    "bk"  `(,(+cmdfy! (kill-buffer (current-buffer)))
            :wk "Kill this buffer")
    "bK"  `(,(+cmdfy! (+kill-buffer-and-its-windows (current-buffer)))
            :wk "Kill this buffer and its windows")
    "br"  '(revert-buffer :wk "Revert")
    "bR"  '(rename-buffer :wk "Rename")
    ;; Bookmarks
    "bm"  '(nil :wk "bookmark")
    "bmm"  #'bookmark-set
    "bmd"  #'bookmark-delete
    ;; Files / Local variables
    "bv"  '(nil :wk "locals")
    "bvv" '(add-file-local-variable :wk "Add")
    "bvV" '(delete-file-local-variable :wk "Delete")
    "bvp" '(add-file-local-variable-prop-line :wk "Add in prop line")
    "bvP" '(delete-file-local-variable-prop-line :wk "Delete from prop line")
    "bvd" '(add-dir-local-variable :wk "Add to dir-locals")
    "bvD" '(delete-dir-local-variable :wk "Delete from dir-locals")
    "bvr"  '(nil :wk "reload dir-locals for...")
    "bvrr" '(+dir-locals-reload-for-this-buffer :wk "This buffer")
    "bvrd" '(+dir-locals-reload-for-all-buffers-in-this-directory :wk "All buffers in this directory")

    ;; ====== Insert ======
    "i"   '(nil :wk "insert")
    "iu"  '(insert-char :wk "Unicode char")
    "ie"  `(,(when (>= emacs-major-version 29) #'emoji-search) :wk "Emoji")

    ;; ====== Window ======
    "w"   '(nil :wk "window")
    "wd"  #'delete-window
    "wD"  #'delete-window-on
    "wm"  #'maximize-window
    "wu"  #'winner-undo
    "wU"  #'winner-redo

    ;; ====== Applications (Open) ======
    "o"   '(nil   :wk "app/open")
    "o-"  '(dired :wk "Dired") ;; Will be overwritten if dirvish is used
    "oa"  #'org-agenda
    "oe"  #'eshell

    ;; ====== Search ======
    "s"   '(nil :wk "search")
    "sw"  '+webjump

    ;; ======  Mode specific a.k.a. "local leader" ======
    "m"   '(nil :wk "mode-specific")

    ;; ====== VC ======
    "g"   '(nil :wk "git/vc")

    ;; ====== Workspaces ======
    "TAB" '(nil :wk "workspace")

    ;; ====== Toggle ======
    "t"   '(nil :wk "toggle")
    "td"  '(toggle-debug-on-error :wk "Debug on error")
    "tr"  #'read-only-mode
    "tl"  #'follow-mode
    "tV"  '(netextender-toggle :wk "NetExtender")
    "te"  '(ecryptfs-toggle-mount-private :wk "eCryptfs")
    "tv"  #'visible-mode

    ;; ====== Code ======
    "c"   '(nil :wk "code")
    "cf"  '(nil :wk "format buffer")

    ;; ====== Workspaces ======
    "r"   '(nil :wk "workspace") ;; TODO: use tab-bar-mode and tab-line-mode

    ;; ====== Notes ======
    "n"   '(nil :wk "notes")

    ;; ====== Help ======
    "h"   '(nil :wk "help")
    "hi"  #'info
    "hg"  #'general-describe-keybindings
    "hs"  #'+screenshot-svg
    "he"  '(nil :wk "elisp/emacs")
    "hes" #'elisp-index-search
    "hem" #'info-emacs-manual
    "hei" #'Info-search
    "hd"  '(nil :wk "describe")
    "hdk" #'describe-key
    "hdm" #'describe-keymap
    "hdb" #'describe-bindings
    "hds" #'describe-symbol
    "hdv" #'describe-variable
    "hdc" #'describe-command
    "hdf" #'describe-function
    "hdp" #'describe-package

    ;; ====== Project ======
    "p"   '(nil :wk "project"))

  ;; HACK: This is a synchronization feature, providing `me-general-ready' tells
  ;; the `+map!', `+map-local!', ... macros that `general' is ready and the
  ;; definers `+minemacs--internal-map!', `+minemacs--internal-map-local!', ...
  ;; are available (See the `+map!' macro definition in "elisp/+minemacs.el").
  (provide 'me-general-ready))
#+end_src
*** me-keybindings.el package =hydra=
#+begin_src emacs-lisp
(use-package hydra
   :straight t)
#+end_src
*** me-keybindings.el =TAIL=
#+begin_src emacs-lisp
(provide me-keybindings)
;;; me-keybindings ends here
#+end_src
** me-loaddefs.el
=me-loaddefs.el= 此文件是由 =minemacs-generate-loaddefs= 收集autoload 函数
** me-modules.el
:properties:
:header-args: :tangle core/me-modules.el
:end:
=me-modules.el= 模块划分文件
*** me-modules.el =HEAD=
#+begin_src emacs-lisp
;;; me-modules.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-modules.el 核心模块
#+begin_src emacs-lisp
(defcustom minemacs-core-modules
  '(me-splash        ; Simple splash screen
    me-keybindings   ; Keybinding (general, which-key, hydra, ...)
    me-evil          ; Emacs as Vim (evil, evil-collection, evil-escape, evil-snipe, evil-numbers, ...)
    me-core-ui       ; Core UI (doom-themes, modus-themes, doom-modeline, ...)
    me-completion)   ; Completion (vertico, marginalia, corfu, cape, consult, embark, ...)
  "MinEmacs enabled core modules."
  :group 'minemacs-core
  :type '(repeat symbol))
#+end_src
*** me-modules.el 定制模块
#+begin_src emacs-lisp
(defcustom minemacs-modules
  '(me-ui            ; User interface (focus, writeroom-mode, mixed-pitch, ...)
    me-editor        ; Editing (yasnippet, smartparens, unicode-fonts, ligature, ...)
    me-daemon        ; Emacs daemon tweaks
    me-undo          ; Better undoing (undo-fu, undo-fu-session, vundo, ...)
    me-multi-cursors ; Multi-cursors editing (iedit, evil-mc, evil-iedit-state, ...)
    me-vc            ; Version control (magit, forge, core-review, diff-hl, ...)
    me-project       ; Project management (project, projectile, consult-projectile, treemacs-projectile, ...)
    me-prog          ; Programming stuff (tree-sitter, eglot, eldoc, eldoc-box, apheleia, editorconfig, ...)
    me-checkers      ; Static checkers (flymake, flymake-easy, ...)
    me-debug         ; Debugging tools (gdb-mi, realgud, disaster, ...)
    ;; me-lsp        ; LSP and DAP (lsp-mode, dap-mode, consult-lsp, lsp-pyright, ccls, ...)
    me-lisp          ; Lisps development (parinfer-rust, sly, macrostep, geiser, elisp, helpful, eros, ...)
    ;; me-embedded   ; Embedded systems (arduino, openocd, bitbake, vhdl-mode, ...)
    ;; me-robot      ; Robotics stuff (ros, robot-mode, ...)
    me-data          ; Data file formats (csv, yaml, toml, json, plantuml-mode, ...)
    ;; me-math       ; Mathematics (maxima, ess, ein, julia-mode, octave, ...)
    ;; me-modeling   ; Modeling tools (scad-mode, ...)
    me-org           ; Org-mode for life (org, org-contrib, org-modern, org-appear, ...)
    me-extra         ; Extra features (better-jumper, crux, ...)
    me-notes         ; Notes & Zettelkasten (org-roam, consult-org-roam, ...)
    me-eaf           ; EAF apps (browser, jupyter, file-sender, ...)
    ;; me-email      ; Email (mu4e, mu4e-alert, org-msg, ...)
    ;; me-rss        ; News feed (elfeed, ...)
    ;; me-lifestyle  ; *Very* opinionated lifestyle packages (awqat, ...)
    me-docs          ; Documents (pdf-tools, nov, ...)
    me-latex         ; LaTeX (auctex, auctex-latexmk, reftex, bibtex, ...)
    ;; me-biblio     ; Bibliography & citations (org-cite, citar, zotxt, ...)
    me-natural-langs ; Natural language stuff (spell-fu, go-translate, eglot-ltex, ...)
    me-files         ; Files and directories (dirvish, treemacs, vlf, ...)
    me-tools         ; System tools (tramp, vterm, tldr, ssh-deploy, docker, ...)
    me-tty           ; Emacs from terminal (xt-mouse, xclip, ...)
    ;; me-fun        ; Games and funny packages (xkcd, speed-type, ...)
    ;; me-media      ; Multimedia (empv, emms, ...)
    ;; me-workspaces ; Workspace separation (tabspaces, tab-bar, ...). NOTE: This is a WIP
    ;; me-binary        ; Display binary files in hex or decompile them (hexl, ...) ...
    me-window)       ; Frame & window tweaks
  "MinEmacs enabled modules."
  :group 'minemacs-core
  :type '(repeat symbol))
#+end_src
*** me-modules.el =TAIL=
#+begin_src emacs-lisp
(provide me-modules)
;;; me-modules ends here
#+end_src
** me-splash.el
:properties:
:header-args: :tangle core/me-splash.el
:end:
=me-splash.el= 下载包过程中简易界面 参考 [[github.com/rougier/emacs-splash][emacs-splash]]
*** me-splash.el =HEAD=
#+begin_src emacs-lisp
;;; me-splash.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-splash.el 界面定制
#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
(defvar minemacs-splash-buffer-name "*minemacs-splash*")

(defun minemacs-splash ()
  "MinEmacs splash screen"
  ;; If there are buffer associated with filenames, we don't show splash screen.
  (when (zerop (length (seq-filter #'identity (mapcar #'buffer-file-name (buffer-list)))))
    (let* ((buffer (get-buffer-create minemacs-splash-buffer-name))
           (height (- (window-body-height nil) 1))
           (padding-center (min 5 (- (/ height 3) 1)))
           (padding-bottom (min 2 (- height (/ height 3) 3))))
      (with-current-buffer buffer
        (erase-buffer)
        ;; Buffer local settings
        (setq-local cursor-type nil
                    vertical-scroll-bar nil
                    horizontal-scroll-bar nil)

        ;; Vertical padding to center
        (insert-char ?\n padding-center)

        ;; Central text
        (insert-char ?\s 10)
        (insert (propertize "MinEmacs" 'face 'bold))
        (insert-char ?\n)
        (insert-char ?\s 10)
        (insert (propertize
                 (format "Running GNU Emacs %s%s"
                         emacs-version
                         (if emacs-repository-version
                             (format " (%s)" (substring emacs-repository-version 0 10))
                           ""))
                 'face 'shadow))

        ;; Bootstraping
        (unless (file-exists-p (concat minemacs-local-dir "straight/repos/straight.el/bootstrap.el"))
          (insert-char ?\n)
          (insert-char ?\s 10)
          (insert (propertize "You are running MinEmacs for the first time."
                              'face 'warning))
          (insert-char ?\n)
          (insert-char ?\s 10)
          (insert (propertize "Please wait while MinEmacs installs the required packages."
                              'face 'warning)))

        ;; Vertical padding to bottom
        (insert-char ?\n padding-bottom)

        ;; Copyright text
        (insert-char ?\n)
        (insert-char ?\s 10)
        (insert (propertize "Minimal Emacs configuration for daily use" 'face 'shadow))
        (insert-char ?\n)
        (insert-char ?\s 10)
        (insert-text-button "github.com/abougouffa/minemacs"
                            'action (lambda (_) (browse-url "https://github.com/abougouffa/minemacs"))
                            'help-echo "Visit MinEmacs repo"
                            'follow-link t)
        (insert-char ?\n)

        (goto-char 0)
        (read-only-mode t)

        (local-set-key (kbd "<escape>") (lambda () (interactive) (minemacs-splash-kill)))
        (local-set-key (kbd "q") (lambda () (interactive) (minemacs-splash-kill)))
        (local-set-key (kbd "<mouse-1>") 'mouse-set-point)
        (local-set-key (kbd "<mouse-2>") 'operate-this-button)

        (display-buffer-same-window buffer nil)))))

(defun minemacs-splash-kill ()
  (when (get-buffer minemacs-splash-buffer-name)
    (kill-buffer minemacs-splash-buffer-name)))

;; Display splash screen
(minemacs-splash)

;; Close splash screen automatically after Emacs gets loaded
(add-hook
 'emacs-startup-hook
 (defun +minemacs-splash--kill-h ()
   (run-at-time 0.5 nil #'minemacs-splash-kill)))
#+end_src
*** me-splash.el =TAIL=
#+begin_src emacs-lisp
(provide me-splash)
;;; me-splash ends here
#+end_src
** me-vars.el
:properties:
:header-args: :tangle core/me-vars.el
:end:
=me-vars.el= 一些自定义变量
*** me-vars.el =HEAD=
#+begin_src emacs-lisp
;;; me-vars.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-vars.el 变量定义
#+begin_src emacs-lisp
;;; MinEmacs directories

(defgroup minemacs nil
  "MinEmacs specific functionalities.")

(defgroup minemacs-core nil
  "MinEmacs core tweaks."
  :group 'minemacs)

(defgroup minemacs-ui nil
  "MinEmacs UI tweaks."
  :group 'minemacs)

(defgroup minemacs-edit nil
  "MinEmacs editor tweaks."
  :group 'minemacs)

(defgroup minemacs-prog nil
  "MinEmacs programming stuff."
  :group 'minemacs)

(defgroup minemacs-keybinding nil
  "MinEmacs keybinding."
  :group 'minemacs)

(defgroup minemacs-utils nil
  "MinEmacs utility functions."
  :group 'minemacs)

(defconst minemacs-config-dir
  (file-name-as-directory
   (or (getenv "MINEMACS_DIR")
       (getenv "MINEMACSDIR")
       "~/.minemacs.d/"))
  "MinEmacs user customization directory.")

(defconst minemacs-debug
  (and (or (getenv "MINEMACS_DEBUG") init-file-debug) t)
  "MinEmacs is started in debug mode.")

(defconst minemacs-verbose
  (and (or (getenv "MINEMACS_VERBOSE") minemacs-debug) t)
  "MinEmacs is started in verbose mode.")

(defconst minemacs-not-lazy
  (or (daemonp) (and (getenv "MINEMACS_NOT_LAZY") t))
  "Load lazy packages (minemacs-lazy-hook) immediately.")

(defcustom minemacs-msg-level
  (let ((level (string-to-number (or (getenv "MINEMACS_MSG_LEVEL") ""))))
    (cond (minemacs-verbose 4)
          ((> level 0) level)
          (t 1)))
  "Level of printed messages.
1 - `+error!'
2 - `+info!'
3 - `+log!'
4 - `+debug!'"
  :group 'minemacs-core
  :type '(choice
          (const :tag "Error" 1)
          (const :tag "Info" 2)
          (const :tag "Log" 3)
          (const :tag "Debug" 4)))

;; Derive the root directory from this file path
(defconst minemacs-root-dir
  (abbreviate-file-name
   (file-name-directory
    (directory-file-name
     (file-name-directory (file-truename load-file-name))))))
(defconst minemacs-core-dir (concat minemacs-root-dir "core/"))
(defconst minemacs-assets-dir (concat minemacs-root-dir "assets/"))
(defconst minemacs-elisp-dir (concat minemacs-root-dir "elisp/"))
(defconst minemacs-modules-dir (concat minemacs-root-dir "modules/"))
(defconst minemacs-extras-dir (concat minemacs-modules-dir "extras/"))
(defconst minemacs-local-dir (concat minemacs-root-dir "local/"))
(defconst minemacs-cache-dir (concat minemacs-local-dir "cache/"))
(defconst minemacs-loaddefs-file (concat minemacs-core-dir "me-loaddefs.el"))

(defconst os/linux (and (memq system-type '(gnu gnu/linux)) t))
(defconst os/bsd (and (memq system-type '(darwin berkeley-unix gnu/kfreebsd)) t))
(defconst os/win (and (memq system-type '(cygwin windows-nt ms-dos)) t))
(defconst os/mac (eq system-type 'darwin))

;; Should return x86_64, aarch64, armhf, ...
(defconst sys/arch (intern (car (split-string system-configuration "-"))))

(defconst emacs/features
  (mapcar #'intern
          (mapcar (apply-partially #'string-replace "_" "-")
                  (mapcar #'downcase (split-string system-configuration-features))))
  "List of symbols representing Emacs' enabled features.
Compiled from the `system-configuration-features'.")

(defcustom minemacs-fonts nil
  "Fonts to use within MinEmacs."
  :group 'minemacs-ui
  :type '(plist
          (:font-family string)
          (:font-size natnum)
          (:unicode-font-family string)
          (:variable-pitch-font-family string)
          (:variable-pitch-font-size natnum)))

(defcustom minemacs-leader-key "SPC"
  "MinEmacs leader key."
  :group 'minemacs-keybinding
  :type 'string)

(defcustom minemacs-localleader-key "SPC m"
  "MinEmacs local leader (a.k.a. mode specific) key sequence."
  :group 'minemacs-keybinding
  :type 'string)

(defcustom minemacs-global-leader-prefix "C-SPC"
  "MinEmacs general leader key."
  :group 'minemacs-keybinding
  :type 'string)

(defcustom minemacs-global-mode-prefix "C-SPC m"
  "MinEmacs general local leader (a.k.a. mode specific) key sequence."
  :group 'minemacs-keybinding
  :type 'string)

(defcustom minemacs-theme 'doom-one-light
  "The theme of MinEmacs."
  :group 'minemacs-ui
  :type 'symbol)

(defcustom minemacs-after-set-fonts-hook nil
  "Runs after setting MinEmacs fonts, runs at the end of `+set-fonts'."
  :group 'minemacs-ui
  :type 'hook)

(defcustom minemacs-after-load-theme-hook nil
  "Runs after loading MinEmacs theme, runs at the end of `+load-theme'."
  :group 'minemacs-ui
  :type 'hook)

(defcustom minemacs-after-startup-hook nil
  "This hook will be run after loading Emacs.

MinEmacs hooks will be run in this order:
1. `minemacs-after-startup-hook'
2. `minemacs-lazy-hook'"
  :group 'minemacs-core
  :type 'hook)

(defcustom minemacs-lazy-hook nil
  "This hook will be run after loading Emacs, with laziness.

MinEmacs hooks will be run in this order:
1. `minemacs-after-startup-hook'
2. `minemacs-lazy-hook'"
  :group 'minemacs-core
  :type 'hook)

;; Setup default fonts (depending on the OS)
(let ((mono-font (cond (os/linux "monospace")
                       (os/win "Lucida Console")
                       (os/mac "monospace")))
      (varp-font (cond (os/linux "monospace")
                       (os/win "Tahoma")
                       (os/mac "monospace"))))
  (defconst minemacs-default-fonts
    `(:font-family ,mono-font
      :font-size 13
      :unicode-font-family nil
      :variable-pitch-font-family ,varp-font
      :variable-pitch-font-size 13)
    "Default fonts of MinEmacs."))

(defcustom +env-save-vars
  '("PATH" "MANPATH" "CMAKE_PREFIX_PATH" "PKG_CONFIG_PATH" "LSP_USE_PLISTS")
  "List of the environment variables to saved by `+env-save'.
You need to run Emacs from terminal to get the environment variables.
MinEmacs then save them when calling `+env-save' to be used in GUI sessions as well."
  :group 'minemacs-core
  :type '(repeat string))
#+end_src
*** me-vars.el =TAIL=
#+begin_src emacs-lisp
(provide me-vars)
;;; me-vars ends here
#+end_src
** me-use-package-pin-ref.el
:properties:
:header-args: :tangle core/me-use-package-pin-ref.el
:end:
=me-use-package-pin-ref.el= 使用确定版本的包
[[https://github.com/radian-software/straight.el#how-do-i-pin-package-versions-or-use-only-tagged-releases][How do I pin package versions or use only tagged releases?]]
*** me-use-package-pin-ref.el =HEAD=
#+begin_src emacs-lisp
;;; me-use-package-pin-ref.el --- Extend use-package to allow straight-x package pinning -*- lexical-   binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-use-package-pin-ref.el 扩展use-package支持固定版本的包
#+begin_src emacs-lisp
 (with-eval-after-load 'straight
   ;; Add a profile (and lockfile) for stable package revisions.
   (add-to-list 'straight-profiles '(pinned . "pinned.el"))
   (require 'straight-x))

 ;; Allow pinning versions from `use-package' using the `:pin-ref' keyword
 (with-eval-after-load 'use-package-core
   (add-to-list 'use-package-keywords :pin-ref)

   (defun use-package-normalize/:pin-ref (_name-symbol keyword args)
     (use-package-only-one (symbol-name keyword) args
       (lambda (_label arg)
         (cond
          ((stringp arg) arg)
          ((symbolp arg) (symbol-name arg))
          (t (use-package-error ":pin-ref wants a commit hash or a ref."))))))

   (defun use-package-handler/:pin-ref (name-symbol _keyword ref rest state)
     (let ((body (use-package-process-keywords name-symbol rest state)))
       (if (null ref)
           body
         `((let ((straight-current-profile 'pinned))
            (push '(,(symbol-name name-symbol) . ,ref) straight-x-pinned-packages)
            ,(macroexp-progn body)))))))
#+end_src
*** me-use-package-pin-ref.el =TAIL=
#+begin_src emacs-lisp
(provide me-use-package-pin-ref)
;;; me-use-package-pin-ref ends here
#+end_src

** minemacs-loaded.el
:properties:
:header-args: :tangle core/minemacs-loaded.el
:end:
=minemacs-loaded.el=  Virtual module loaded at end of init.el (after custom-vars.el)
Used to synchronize loading some other stuff after loading Emacs
*** minemacs-loaded.el =HEAD=
#+begin_src emacs-lisp
;;; minemacs-loaded.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** minemacs-loaded.el 同步加载一些其他东西
#+begin_src emacs-lisp
 ;; Run hooks
 (when minemacs-after-startup-hook
   (setq minemacs-after-startup-hook (reverse minemacs-after-startup-hook))
   (+log! "Running %d `minemacs-after-startup-hook' hooks."
          (length minemacs-after-startup-hook))
   (run-hooks 'minemacs-after-startup-hook))

 (if minemacs-not-lazy
     (require 'minemacs-lazy)
   (+eval-when-idle-for! 2
     (require 'minemacs-lazy)))

 (+log! "Providing `minemacs-loaded'.")
#+end_src
*** minemacs-loaded.el =TAIL=
#+begin_src emacs-lisp
(provide minemacs-loaded)
;;; minemacs-loaded ends here
#+end_src

** minemacs-lazy.el
:properties:
:header-args: :tangle core/minemacs-lazy.el
:end:
=minemacs-lazy.el= 惰性加载hook
Virtual module loaded when idle after `minemacs-loaded'.
Used to synchronize loading some other stuff after loading Emacs.
*** minemacs-lazy.el HEAD
#+begin_src emacs-lisp
;;; minemacs-lazy.el -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** minemacs-lazy.el =lazy hook=
#+begin_src emacs-lisp
 ;; The hooks in `minemacs-lazy-hook' are loaded incrementally when Emacs goes
 ;; idle, but when `minemacs-not-lazy' is set to t, they will be all loaded at
 ;; once.

 ;; Run hooks
 (when minemacs-lazy-hook
   ;; Reverse the order to follow the order in which modules are loaded. Make
   ;; sure `gcmh-mode' is the last to be called. The `gc-cons-threshold' has been
   ;; set in "early-init.el" to a ridiculously high value to reduce the number of
   ;; garbage collections at startup, it will be overwritten by `gcmh-mode', so
   ;; we defer loading it to the end to maximize the benefit.
   (setq minemacs-lazy-hook (append (delq 'gcmh-mode (reverse minemacs-lazy-hook)) '(gcmh-mode)))
   (if minemacs-not-lazy
       (progn ; If `minemacs-no-lazy' is bound and true, force loading lazy hooks immediately
         (+log! "Loading %d lazy packages immediately."
                (length minemacs-lazy-hook))
         (run-hooks 'minemacs-lazy-hook))
     (+log! "Loading %d lazy packages incrementally." (length minemacs-lazy-hook))
     ;; Run hooks one by one, as a FIFO.
     (apply #'+eval-when-idle (append '(1) minemacs-lazy-hook))))

 (+log! "Providing `minemacs-lazy'.")
#+end_src
*** minemacs-lazy.el TAIL
#+begin_src emacs-lisp
(provide 'minemacs-lazy)
;;; minemacs-lazy.el ends here
#+end_src
* elisp/
** +binary.el
:properties:
:header-args: :tangle elisp/+binary.el
:end:
*** +binary.el =HEAD=
#+begin_src emacs-lisp
;;; +binary.el --- binary -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +binary.el 二进制相关
#+begin_src emacs-lisp
(defgroup minemacs-binary nil
  "MinEmacs binary files."
  :group 'minemacs)

(defcustom +binary-objdump-executable (executable-find "objdump")
  "Path to the executable \"objdump\" utility."
  :group 'minemacs-binary
  :type 'string)

(defcustom +binary-objdump-enable t
  "Enable or disable disassembling suitable files with objdump."
  :group 'minemacs-binary
  :type 'boolean)

(defcustom +binary-hexl-enable t
  "Enable or disable openning suitable files in `hexl-mode'."
  :group 'minemacs-binary
  :type 'boolean)

;;;###autoload
(defun +binary-objdump-buffer-p (&optional buffer)
  "Can the BUFFER be viewed as a disassembled code with objdump."
  (and +binary-objdump-enable
       (when-let* ((file (buffer-file-name (or buffer (current-buffer))))
                   (file (file-truename file)))
         (and +binary-objdump-executable
              (file-exists-p file)
              (not (file-directory-p file))
              (not (zerop (file-attribute-size (file-attributes file))))
              (not (string-match-p
                    "file format not recognized"
                    (with-temp-buffer
                      (shell-command (format "%s --file-HEADs %s"
                                             +binary-objdump-executable
                                             (shell-quote-argument file))
                                     (current-buffer))
                      (buffer-string))))))))

;; A predicate for detecting binary files. Inspired by:
;; emacs.stackexchange.com/q/10277/37002)
(defun +binary-buffer-p (&optional buffer)
  "Return whether BUFFER or the current buffer is binary.

A binary buffer is defined as containing at least one null byte.

Returns either nil, or the position of the first null byte."
  (with-current-buffer (or buffer (current-buffer))
    (save-excursion
      (goto-char (point-min))
      (search-forward (string ?\x00) nil t 1))))

;;;###autoload
(defun +binary-hexl-buffer-p (&optional buffer)
  "Is the current buffer should be viewed using `hexl-mode'."
  (and +binary-hexl-enable
       (+binary-buffer-p buffer)
       ;; Executables are viewed with objdump mode
       (not (+binary-objdump-buffer-p buffer))))

;;;###autoload
(define-derived-mode objdump-disassemble-mode
  asm-mode "Objdump Mode"
  "Major mode for viewing executable files disassembled using objdump."
  (if (+binary-objdump-buffer-p)
      (when-let ((file (buffer-file-name))
                 (buffer-read-only nil))
        (message "Disassembling file \"%s\" using objdump." (file-name-nondirectory file))
        (erase-buffer)
        (call-process "objdump" nil (current-buffer) nil "-d" file)
        (view-mode)
        (goto-char (point-min))
        (set-buffer-modified-p nil)
        (set-visited-file-name nil t)
        (buffer-disable-undo)
        (set-buffer-modified-p nil)
        (setq-local buffer-read-only t))
    (message "Objdump can not be used with this buffer.")))

;;;###autoload
(defun +binary-hexl-mode-maybe ()
  "If `hexl-mode' is not already active, and the current buffer
is binary, activate `hexl-mode'."
  (interactive)
  (unless (eq major-mode 'hexl-mode)
    (when (+binary-hexl-buffer-p)
      (hexl-mode))))

;;;###autoload
(defun +binary-setup-modes ()
  (add-to-list 'magic-fallback-mode-alist '(+binary-objdump-buffer-p . objdump-disassemble-mode) t)
  (add-to-list 'magic-fallback-mode-alist '(+binary-hexl-buffer-p . +binary-hexl-mode-maybe) t))
#+end_src
*** +binary.el =TAIL=
#+begin_src emacs-lisp
;;; binary ends here
#+end_src
** +buffer.el
:properties:
:header-args: :tangle elisp/+buffer.el
:end:
*** +buffer.el =HEAD=
#+begin_src emacs-lisp
;;; +buffer.el --- binary -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +buffer.el 一些关于buffer的函数
#+begin_src emacs-lisp
(defgroup minemacs-buffer nil
  "MinEmacs buffer stuff."
  :group 'minemacs)

;; From: emacswiki.org/emacs/download/misc-cmds.el
;; Candidate as a replacement for `kill-buffer', at least when used interactively.
;; For example: (define-key global-map [remap kill-buffer] 'kill-buffer-and-its-windows)
;; We cannot just redefine `kill-buffer', because some programs count on a
;; specific other buffer taking the place of the killed buffer (in the window).
;;;###autoload
(defun +kill-buffer-and-its-windows (buffer &optional msgp)
  "Kill BUFFER and delete its windows.  Default is `current-buffer'.
BUFFER may be either a buffer or its name (a string)."
  (interactive (list (read-buffer "Kill buffer: " (current-buffer) 'existing) 'MSGP))
  (setq buffer (get-buffer buffer))
  (if (buffer-live-p buffer) ; Kill live buffer only.
      (let ((wins (get-buffer-window-list buffer nil t))) ; On all frames.
        (when (kill-buffer buffer) ; Only delete windows if buffer killed.
          (dolist (win wins) ; (User might keep buffer if modified.)
            (when (window-live-p win)
              ;; Ignore error, in particular,
              ;; "Attempt to delete the sole visible or iconified frame".
              (condition-case nil (delete-window win) (error nil))))))
    (when msgp (user-error "Cannot kill buffer.  Not a live buffer: `%s'" buffer))))

;; From: emacswiki.org/emacs/download/misc-cmds.el
;;;###autoload
(defun +region-to-buffer (start end buffer arg)
  "Copy region to BUFFER: At beginning (prefix >= 0), end (< 0), or replace.
START and END are the region boundaries.
BUFFER is a buffer or its name (a string).
With prefix ARG >= 0: `append-to-buffer':
  Append contents of region to end of BUFFER.
  (Point is moved to end of BUFFER first.)
With prefix ARG < 0:  `prepend-to-buffer':
  Prepend contents of region to beginning of BUFFER.
  (Point is moved to beginning of BUFFER first.)
With no prefix ARG (nil): `copy-to-buffer'.
  Write region to BUFFER, replacing any previous contents."
  (interactive
   (let ((arg (and current-prefix-arg (prefix-numeric-value current-prefix-arg))))
     (list (region-beginning)
           (region-end)
           (read-buffer
            (concat (if arg
                        (if (natnump arg) "Append" "Prepend")
                      "Write")
                    " region to buffer: ")
            (if (fboundp 'another-buffer) ; Defined in `misc-fns.el'.
                (another-buffer nil t)
              (other-buffer (current-buffer))))
           arg)))
  (setq buffer (get-buffer-create buffer)) ; Convert to buffer.
  (when (eq buffer (current-buffer)) (error "Cannot copy region to its own buffer"))
  (cond ((natnump arg)
         (with-current-buffer buffer (goto-char (point-max)))
         (append-to-buffer buffer start end))
        (arg
         (with-current-buffer buffer (goto-char (point-min)))
         (prepend-to-buffer buffer start end))
        (t (copy-to-buffer buffer start end))))

;; From: emacswiki.org/emacs/download/misc-cmds.el
;;;###autoload
(defun +region-to-file (start end filename arg)
  "With prefix arg, this is `append-to-file'.  Without, it is `write-region'.
START and END are the region boundaries.
Prefix ARG non-nil means append region to end of  file FILENAME.
Prefix ARG nil means write region to FILENAME, replacing contents."
  (interactive
   (list (region-beginning)
         (region-end)
         (read-file-name (concat (if current-prefix-arg "Append" "Write")
                                 " region to file: "))
         current-prefix-arg))
  (let* ((curr-file (buffer-file-name))
         (same-file-p (and curr-file (string= curr-file filename))))
    (cond ((or (not same-file-p)
               (progn (when (fboundp 'flash-ding) (flash-ding))
                      (yes-or-no-p
                       (format
                        "Do you really want to REPLACE the contents of `%s' by just the REGION? "
                        (file-name-nondirectory curr-file)))))
           (write-region start end filename arg)
           (when same-file-p (revert-buffer t t)))
          (t (message "OK.  Not written.")))))

;;;###autoload
(defun +kill-some-buffers (&optional list)
  "Kill some buffers.  Asks the user whether to kill the modified ones.
Non-interactively, if optional argument LIST is non-nil, it
specifies the list of buffers to kill, asking for approval for each one.
See `kill-some-buffers'."
  (interactive)
  ;; Replace the `kill-buffer-ask' locally (used by `kill-some-buffers')
  ;; with our function which don't ask about unmodified buffers.
  (cl-letf (((symbol-function 'kill-buffer-ask) #'+kill-buffer-ask-if-modified))
    (kill-some-buffers list)))

(defcustom +kill-buffer-no-ask-list
  (list messages-buffer-name "*Warnings*")
  "A list of buffer names to be killed without confirmation."
  :group 'minemacs-buffer
  :type '(repeat string))

(with-eval-after-load 'comp
  (when (featurep 'native-compile)
    (setq
     +kill-buffer-no-ask-list
     (append +kill-buffer-no-ask-list
             (list comp-async-buffer-name comp-log-buffer-name)))))

;;;###autoload
(defun +kill-buffer-ask-if-modified (buffer)
  "Like `kill-buffer-ask', but kills BUFFER without confirmation if buffer is unmodified.
Kill without asking for buffer names in `+kill-buffer-no-ask-list'."
  (when (or (not (buffer-modified-p buffer))
            (member (buffer-name buffer) +kill-buffer-no-ask-list)
            (yes-or-no-p (format "Buffer %s HAS BEEN MODIFIED.  Kill? "
                                 (buffer-name buffer))))
    (kill-buffer buffer)))

;; From: emacswiki.org/emacs/download/misc-cmds.el
;;;###autoload
(defun +delete-extra-windows-for-buffer ()
  "Delete all other windows showing the selected window's buffer."
  (interactive)
  (let* ((selwin (selected-window))
         (buf (window-buffer selwin)))
    (walk-windows
     (lambda (ww)
       (unless (eq ww selwin)
         (when (eq (window-buffer ww) buf)
           (delete-window ww))))
     'NO-MINI 'THIS-FRAME)))

;; From: emacswiki.org/emacs/download/misc-cmds.el
;;;###autoload
(defun +delete-window-maybe-kill-buffer ()
  "Delete selected window.
If no other window shows its buffer, kill the buffer too."
  (interactive)
  (let* ((selwin (selected-window))
         (buf (window-buffer selwin)))
    (delete-window selwin)
    (unless (get-buffer-window buf 'visible) (kill-buffer buf))))

;;;###autoload
(defun +fill-scratch-buffer ()
  "Fill the `initial-scratch-message'.
When available, use \"fortune\" to add a random quote."
  ;; Print load time, and a quote to *scratch*
  (with-current-buffer (get-scratch-buffer-create)
    (erase-buffer)
    (insert (format
             ";; MinEmacs loaded in %.2fs with %d garbage collection%s done!\n"
             (string-to-number (car (string-split (emacs-init-time))))
             gcs-done (if (> gcs-done 1) "s" "")))
    (insert ";; ==============================\n")
    ;; Insert a random quote from "fortune" when the command is available
    (when (executable-find "fortune")
      (insert (string-join
               (mapcar (apply-partially #'concat ";; ")
                       (string-lines (shell-command-to-string "fortune")))
               "\n"))
      (insert "\n;; ==============================\n"))
    ;; Set initial scratch message
    (setq initial-scratch-message (buffer-string))))
#+end_src
*** +buffer.el =TAIL=
#+begin_src emacs-lisp
;;; buffer ends here
#+end_src
** ecryptfs.el
:properties:
:header-args: :tangle elisp/+ecryptfs.el
:end:
This allows me to mount my private directory encrypted using ecryptfs-utils.
It is a port of "ecryptfs-mount-private" shell command. It uses extracts the
encryption key from a GPG encrypted file containting the ecryptfs password.
The decryption of the password is performed using Emacs' `epg'.
*** ecryptfs.el =HEAD=
*** ecryptfs.el 私有文件夹加密解密
#+begin_src emacs-lisp
(require 'epg)

(defgroup minemacs-ecryptfs nil
  "MinEmacs eCryptfs."
  :group 'minemacs)

(defcustom ecryptfs-private-dir-name "Private"
  "eCryptfs private directory name."
  :group 'minemacs-ecryptfs
  :type 'string)

(defcustom ecryptfs-root-dir "~/.ecryptfs/"
  "eCryptfs root configuration directory."
  :group 'minemacs-ecryptfs
  :type 'directory)

(defvar ecryptfs-wrapping-independent-p (file-exists-p (concat ecryptfs-root-dir "wrapping-independent")))

(defvar ecryptfs-wrapped-passphrase-file (concat ecryptfs-root-dir "wrapped-passphrase"))

(defvar ecryptfs-mount-passphrase-sig-file (concat ecryptfs-root-dir ecryptfs-private-dir-name ".sig"))

(defvar ecryptfs-buffer-name "*emacs-ecryptfs*")

(defvar ecryptfs-process-name "emacs-ecryptfs")

(defvar ecryptfs--mount-private-cmd "/sbin/mount.ecryptfs_private")

(defvar ecryptfs--umount-private-cmd "/sbin/umount.ecryptfs_private")

(defvar ecryptfs--passphrase
  (lambda ()
    (string-trim-right
     (epg-decrypt-file
      (epg-make-context)
      (expand-file-name (concat ecryptfs-root-dir "my-pass.gpg"))
      nil))))

(defvar ecryptfs-encrypt-filenames-p
  (not (eq 1 (with-temp-buffer
               (insert-file-contents ecryptfs-mount-passphrase-sig-file)
               (count-lines (point-min) (point-max))))))

(defvar ecryptfs--command-format
  (if ecryptfs-encrypt-filenames-p
      "ecryptfs-insert-wrapped-passphrase-into-keyring %s '%s'"
    "ecryptfs-unwrap-passphrase %s '%s' | ecryptfs-add-passphrase -"))

(defun ecryptfs-private-mounted-p ()
  (let ((mount (shell-command-to-string "mount")))
    (and (string-match-p (concat ".*" (expand-file-name ecryptfs-private-dir-name "~") ".*ecryptfs.*") mount)
         t)))

;;;###autoload
(defun ecryptfs-toggle-mount-private ()
  "Mount/Unmount eCryptfs' private directory."
  (interactive)
  (if (ecryptfs-private-mounted-p)
      (ecryptfs-umount-private)
    (ecryptfs-mount-private)))

;;;###autoload
(defun ecryptfs-mount-private ()
  "Mount eCryptfs' private directory."
  (interactive)
  (if (not (and (file-exists-p ecryptfs-wrapped-passphrase-file)
                (file-exists-p ecryptfs-mount-passphrase-sig-file)))
      (user-error "Encrypted private directory \"%s\" is not setup properly."
                  ecryptfs-private-dir-name)
    (let ((try-again t))
      (message "Encrypted filenames mode [%s]" (if ecryptfs-encrypt-filenames-p "✓" "⨯"))
      (while (and ;; In the first iteration, we try to silently mount the ecryptfs private directory,
              ;; this would succeed if the key is available in the keyring.
              (and (shell-command ecryptfs--mount-private-cmd
                                  ecryptfs-buffer-name)
                   (message "Successfully mounted private directory."))
              try-again)
        (setq try-again nil)
        (if (zerop
             (shell-command
              (format ecryptfs--command-format
                      ecryptfs-wrapped-passphrase-file
                      (funcall ecryptfs--passphrase))
              ecryptfs-buffer-name))
            (message "Successfully mounted private directory.")
          (user-error "A problem occured while mounting the private directory, see %s"
                      ecryptfs-buffer-name))))))

;;;###autoload
(defun ecryptfs-umount-private ()
  "Unmount eCryptfs' private directory."
  (interactive)
  (if (zerop (shell-command ecryptfs--umount-private-cmd
                            ecryptfs-buffer-name))
      (message "Unmounted private directory successfully.")
    (user-error "Cannot unmount the private directory, seems to be already unmounted.")))
#+end_src
*** ecryptfs.el =TAIL=
#+begin_src emacs-lisp
;;; ecryptfs.el ends here
#+end_src
** +io.el
:properties:
:header-args: :tangle elisp/+io.el
:end:
*** +io.el =HEAD=
#+begin_src emacs-lisp
;;; +io.el --- io -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +io.el 一些路径和文件的处理函数
#+begin_src emacs-lisp
;;;###autoload
(defun +file-mime-type (file)
  "Get MIME type for FILE based on magic codes provided by the 'file' command.
Return a symbol of the MIME type, ex: `text/x-lisp', `text/plain',
`application/x-object', `application/octet-stream', etc."
  (if (executable-find "file")
      (let ((mime-type (shell-command-to-string (format "file --brief --mime-type %s" file))))
        (intern (string-trim-right mime-type)))
    (error "The \"file\" command isn't installed.")))

;;;###autoload
(defun +file-name-incremental (filename)
  "Return an unique file name for FILENAME.
If \"file.ext\" exists, returns \"file-0.ext\"."
  (let* ((ext (file-name-extension filename))
         (dir (file-name-directory filename))
         (file (file-name-base filename))
         (filename-regex (concat "^" file "\\(?:-\\(?1:[[:digit:]]+\\)\\)?" (if ext (concat "\\." ext) "")))
         (last-file (car (last (directory-files dir nil filename-regex))))
         (last-file-num (when (and last-file (string-match filename-regex last-file) (match-string 1 last-file))))
         (num (1+ (string-to-number (or last-file-num "-1")))))
    (file-name-concat dir (format "%s%s%s" file (if last-file (format "-%d" num) "") (if ext (concat "." ext) "")))))

;;;###autoload
(defun +file-read-to-string (filename)
  "Return a string with the contents of FILENAME."
  (when (and (file-exists-p filename) (not (file-directory-p filename)))
    (with-temp-buffer
      (insert-file-contents filename)
      (buffer-string))))

;;;###autoload
(defun +directory-subdirs (dir)
  "Return a list of sub-directories in DIR."
  (when dir
    (seq-filter #'file-directory-p
                (mapcar #'abbreviate-file-name
                        (directory-files dir t "[^.][^.]?$")))))

;;;###autoload
(defun +directory-ensure (&rest path-parts)
  "Concatenate PATH-PARTS to construct a path and return it.

Ensure the path exists, if not create it. The exact behavior is to create the
parent directory if the path is a file, and if the path is a directory, create
that directory."
  (let* ((path (mapconcat #'identity path-parts nil))
         (parent-dir (file-name-directory path)))
    (unless (file-directory-p parent-dir)
      (ignore-errors (mkdir parent-dir t))
      (unless (file-directory-p parent-dir)
        (+error! "Cannot create directory %s" parent-dir)))
    path))

;;;###autoload
(defun +delete-this-file (&optional path force-p)
  "Delete PATH.

If PATH is not specified, default to the current buffer's file.

If FORCE-P, delete without confirmation."
  (interactive
   (list (buffer-file-name (buffer-base-buffer))
         current-prefix-arg))
  (let* ((path (or path (buffer-file-name (buffer-base-buffer))))
         (short-path (abbreviate-file-name path)))
    (unless (and path (file-exists-p path))
      (user-error "Buffer is not visiting any file"))
    (unless (file-exists-p path)
      (error "File doesn't exist: %s" path))
    (unless (or force-p (y-or-n-p (format "Really delete %S?" short-path)))
      (user-error "Aborted"))
    (let ((buf (current-buffer)))
      (unwind-protect
          (progn (delete-file path t) t)
        (when (file-exists-p path)
          (error "Failed to delete %S" short-path))))))

;;;###autoload
(defun +move-this-file (new-path &optional force-p)
  "Move current buffer's file to NEW-PATH.

If FORCE-P, overwrite the destination file if it exists, without confirmation."
  (interactive
   (list (read-file-name "Move file to: ")
         current-prefix-arg))
  (unless (and buffer-file-name (file-exists-p buffer-file-name))
    (user-error "Buffer is not visiting any file"))
  (let ((old-path (buffer-file-name (buffer-base-buffer)))
        (new-path (expand-file-name new-path)))
    (when (directory-name-p new-path)
      (setq new-path (expand-file-name (file-name-nondirectory old-path) new-path)))
    (make-directory (file-name-directory new-path) t)
    (rename-file old-path new-path (or force-p 1))
    (set-visited-file-name new-path t t)
    ;; (doom-files--update-refs old-path new-path)
    (message "File moved to %S" (abbreviate-file-name new-path))))

;;;###autoload
(defun +tramp-sudo-file-path (file)
  "Construct a Tramp sudo path to FILE. Works for both local and remote files."
  (let ((host (or (file-remote-p file 'host) "localhost")))
    (concat "/" (when (file-remote-p file)
                  (concat (file-remote-p file 'method) ":"
                          (if-let (user (file-remote-p file 'user))
                              (concat user "@" host)
                            host)
                          "|"))
            "sudo:root@" host
            ":" (or (file-remote-p file 'localname)
                    file))))

;;;###autoload
(defun +sudo-find-file (file)
  "Open FILE as root."
  (interactive "FOpen file as root: ")
  (find-file (+tramp-sudo-file-path file)))

;;;###autoload
(defun +sudo-this-file ()
  "Open the current file as root."
  (interactive)
  (if-let ((this-file (or buffer-file-name
                          (when (or (derived-mode-p 'dired-mode)
                                    (derived-mode-p 'wdired-mode))
                            default-directory))))
      (find-file (+tramp-sudo-file-path this-file))
    (user-error "Current buffer not bound to a file")))

;;;###autoload
(defun +sudo-save-buffer ()
  "Save this file as root."
  (interactive)
  (if buffer-file-name
      (if-let ((file (+tramp-sudo-file-path buffer-file-name))
               (buffer (find-file-noselect file))
               (origin (current-buffer)))
          (progn
            (copy-to-buffer buffer (point-min) (point-max))
            (unwind-protect
                (with-current-buffer buffer
                  (save-buffer))
              (unless (eq origin buffer)
                (kill-buffer buffer))
              (with-current-buffer origin
                (revert-buffer t t))))
        (user-error "Unable to open %S" file))
    (user-error "Current buffer not bound to a file")))

;;;###autoload
(defun +yank-this-file-name ()
  "Yank the file name of this buffer."
  (interactive)
  (let ((file (buffer-file-name)))
    (if (null file)
        (user-error "This buffer isn't bound to a file.")
      (with-temp-buffer
        (insert file)
        (kill-ring-save (point-min) (point-max))))))

;;;###autoload
(defun +clean-file-name (filename &optional downcase-p)
  "Clean file name."
  ;; Clean slashes, backslashes, ":", ";", spaces, and tabs
  (replace-regexp-in-string
   "[:;\t\n\r /\\_]+" "-"
   (replace-regexp-in-string
    "[‘’‚’“”„”\"`'()&]+" ""
    (if downcase-p (downcase filename) filename))))

(defcustom +html2pdf-default-backend 'wkhtmltopdf
  "The default backend to convert HTML files to PDFs in `+html2pdf'."
  :group 'minemacs-utils
  :type '(choice
          (const wkhtmltopdf)
          (const htmldoc)
          (const weasyprint)
          (const pandoc+context)))

;;;###autoload
(defun +html2pdf (infile outfile &optional backend)
  "Convert HTML file INFILE to PDF and save it to OUTFILE.
When BACKEND is provided, the corresponding program is used, otherwise, the
value of `+html2pdf-default-backend' is used."
  (let ((default-directory (file-name-directory infile))
        (backend (or backend +html2pdf-default-backend)))
    (pcase backend
      ('weasyprint
       (call-process
        "weasyprint" nil nil nil
        "--encoding" "utf-8"
        "--stylesheet" (expand-file-name "templates/weasyprint-pdf.css" minemacs-assets-dir)
        infile outfile))
      ('htmldoc
       (call-process
        "htmldoc" nil nil nil
        "--charset" "utf-8"
        "--bodyfont" "sans" "--textfont" "sans" "--headfootfont" "sans"
        "--top" "10#mm" "--bottom" "10#mm" "--right" "10#mm" "--left" "10#mm"
        "--fontsize" "11"
        "--size" "a4"
        "--continuous"
        "--outfile" outfile infile))
      ('wkhtmltopdf
       (call-process
        "wkhtmltopdf" nil nil nil
        "--images" "--disable-javascript" "--enable-local-file-access"
        "--encoding" "utf-8"
        infile outfile))
      ('pandoc+context
       (call-process
        "pandoc" nil nil nil
        "--pdf-engine=context"
        "--variable" "fontsize=10pt"
        "--variable" "linkstyle=slanted"
        "-o" outfile infile)))))

;;;###autoload
(defun +txt2html (infile outfile &optional mail-mode-p)
  "Convert plain-text file INFILE to HTML and save it to OUTFILE.
When MAIL-MODE-P is non-nil, --mailmode is passed to \"txt2html\"."
  (apply
   #'call-process
   (append '("txt2html" nil nil nil "-8")
           (when mail-mode-p '("--mailmode"))
           (list "--outfile" outfile infile))))

(defvar +save-as-pdf-filename nil
  "File name to use, if non-nil, for the output file.")

;;;###autoload
(defun +save-as-pdf (infile &optional mail-mode-p)
  "Save URL as PDF.
This function's signature is compatible with `browse-url-browser-function'
so it can be used to save HTML pages or emails to PDF.
When MAIL-MODE-P is non-nil, treat INFILE as a mail."
  (let* ((infile (string-trim-left infile "file://"))
         (outfile (+file-name-incremental
                   (or +save-as-pdf-filename
                       (expand-file-name
                        (file-name-with-extension (file-name-base infile) ".pdf")
                        (file-name-directory infile))))))
    (if (zerop
         ;; For HTML files, just call `+html2pdf'
         (if (string= "html" (file-name-extension infile))
             (+html2pdf infile outfile)
           ;; For non-HTML (plain-text) files, convert them to HTML then call `+html2pdf'
           (let ((tmp-html (make-temp-file "txt2html-" nil ".html")))
             (+txt2html infile tmp-html mail-mode-p)
             (+html2pdf tmp-html outfile))))
        (message "Exported PDF to %s"
                 (truncate-string-to-width
                  (abbreviate-file-name outfile)
                  (/ (window-width (minibuffer-window)) 2) nil nil t))
      (user-error
       (if (file-exists-p outfile)
           "PDF created but with some errors!"
         "An error occured, cannot create the PDF!")))))

;;;###autoload
(defcustom +single-file-executable (executable-find "single-file")
  "The executable for \"single-file\" which is used archive HTML pages.")

;;;###autoload
(defun +single-file (url out-file)
  "Save URL into OUT-FILE as a standalone HTML file."
  (when +single-file-executable
    (make-process
     :name "single-file-cli"
     :buffer "*single-file*"
     :command (list
               +single-file-executable
               "--browser-executable-path" browse-url-chromium-program
               url out-file))))
#+end_src
*** +io.el =TAIL=
#+begin_src emacs-lisp
;;; +io.el ends here
#+end_src
** +emacs.el
:properties:
:header-args: :tangle elisp/+emacs.el
:end:
*** +emacs.el =HEAD=
#+begin_src emacs-lisp
;;; +emacs.el --- emacs -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +emacs.el =.dir_local=
#+begin_src emacs-lisp
;;;###autoload
(defun +dir-locals-reload-for-this-buffer ()
  "Reload directory-local for the current buffer"
  (interactive)
  (let ((enable-local-variables :all))
    (hack-dir-local-variables-non-file-buffer)
    (+info! "Reloaded directory-local variables for buffer %s"
            (buffer-name (current-buffer)))))

;;;###autoload
(defun +dir-locals-reload-for-all-buffers-in-this-directory ()
  "For every buffer with the same `default-directory` as the
current buffer's, reload dir-locals."
  (interactive)
  (let ((dir default-directory))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (equal default-directory dir)
          (+dir-locals-reload-for-this-buffer))))))

(defun +dir-locals--autoreload-h ()
  (when (and (buffer-file-name)
             (equal dir-locals-file (file-name-nondirectory (buffer-file-name))))
    (+dir-locals-reload-for-all-buffers-in-this-directory)
    (message "Reloaded directory-local variables defined in %s." dir-locals-file)))

(defvar +dir-locals--autoreload-p nil)

;;;###autoload
(defun +dir-locals-toggle-autoreload (&optional enable)
  "Toggle autoloading directory-local variables after editing the \".dir-locals\" file.
If ENABLE is non-nil, force enabling autoreloading."
  (interactive)
  (if (or enable +dir-locals--autoreload-p)
      (progn
        (remove-hook 'after-save-hook #'+dir-locals--autoreload-h)
        (setq +dir-locals--autoreload-p nil)
        (message "Disabled auto-reloading directory-locals."))
    (add-hook 'after-save-hook #'+dir-locals--autoreload-h)
    (setq +dir-locals--autoreload-p t)
    (message "Enabled auto-reloading directory-locals.")))

;;;###autoload
(defun +dir-locals-open-or-create ()
  "Open or create the dir-locals.el for the current project."
  (interactive)
  (let* ((file-name (buffer-file-name))
         (base-dir (car (ensure-list (dir-locals-find-file file-name)))))
    (find-file
     (cond (base-dir (expand-file-name dir-locals-file base-dir))
           ((project-current) (expand-file-name dir-locals-file (project-root (project-current))))
           ((vc-root-dir) (expand-file-name dir-locals-file (vc-root-dir)))
           (t (expand-file-name dir-locals-file (file-name-directory file-name)))))))
#+end_src
*** +emacs.el =whitespace=
#+begin_src emacs-lisp
;; The hook is defined and enabled by default in `me-defaults'
;;;###autoload
(defun +toggle-auto-whitespace-cleanup ()
  "Toggle auto-deleting trailing whitespaces."
  (interactive)
  (if (member #'+save--whitespace-cleanup-h before-save-hook)
      (progn
        (message "+toggle-auto-whitespace-cleanup: Disabled.")
        (remove-hook 'before-save-hook #'+save--whitespace-cleanup-h))
    (message "+toggle-auto-whitespace-cleanup: Enabled.")
    (add-hook 'before-save-hook #'+save--whitespace-cleanup-h)))
#+end_src
*** +emacs.el =what-faces=
#+begin_src emacs-lisp
;; Adapted from: rougier/nano-emacs
;;;###autoload
(defun +what-faces (pos)
  "Get the font faces at POS."
  (interactive "d")
  (let ((faces (remq nil
                     (list
                      (get-char-property pos 'read-face-name)
                      (get-char-property pos 'face)
                      (plist-get (text-properties-at pos) 'face)))))
    (message "Faces: %s" faces)))
#+end_src
*** +emacs.el =screen-svg=
#+begin_src emacs-lisp
(defcustom +screenshot-delay 5
  "A delay to wait before taking the screenshot.
Applicable only when calling `+screenshot-svg' with a prefix."
  :group 'minemacs-utils
  :type 'number)

;; Inspired by: reddit.com/r/emacs/comments/idz35e/comment/g2c2c6y
;;;###autoload
(defun +screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring. If launched with a
prefix or universal argument, it waits for a moment (defined by
`+screenshot-delay') before taking the screenshot."
  (interactive)
  (if current-prefix-arg
      (run-with-timer +screenshot-delay nil #'+screenshot-svg--take-screenshot)
    (+screenshot-svg--take-screenshot)))

(defun +screenshot-svg--take-screenshot ()
  (let* ((filename (make-temp-file "emacs-" nil ".svg"))
         (data (x-export-frames nil 'svg)))
    (with-temp-file filename (insert data))
    (kill-new filename)
    (message "Screenshot saved to %s" filename)))
#+end_src
*** +emacs.el =webjump=
#+begin_src emacs-lisp
;;;###autoload
(defun +region-or-thing-at-point ()
  "Return the region or the thing at point."
  (when-let* ((thing (or
                      (prog1 (thing-at-point 'region t)
                        (deactivate-mark))
                      (thing-at-point 'symbol t)
                      (thing-at-point 'email t)
                      (thing-at-point 'number t)
                      (thing-at-point 'string t)
                      (thing-at-point 'word t))))
    (if (length> (string-lines thing) 1)
        ;; If the matching thing has multi-lines, use the first one
        (car (string-lines thing))
      thing)))

(defvar +webjump-read-string-initial-query nil)

(defun +webjump-read-string-with-initial-query (prompt)
  (let ((input (read-string (concat prompt ": ") +webjump-read-string-initial-query)))
    (if (webjump-null-or-blank-string-p input) nil input)))

;;;###autoload
(defun +webjump ()
  "Like `webjump', with initial query filled from `+region-org-thing-at-point'."
  (interactive)
  (require 'webjump)
  (let ((+webjump-read-string-initial-query (+region-or-thing-at-point)))
    (cl-letf (((symbol-function 'webjump-read-string) #'+webjump-read-string-with-initial-query))
      (webjump))))
#+end_src
*** +emacs.el =TAIL=
#+begin_src emacs-lisp
;;; +emacs.el ends here
#+end_src
** +keybinding.el
:properties:
:header-args: :tangle elisp/+keybinding.el
:end:
*** +keybinding.el =HEAD=
#+begin_src emacs-lisp
;;; +keybinding.el --- +keybinding -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +keybinding.el 按键相关宏
#+begin_src emacs-lisp
;; PERF+HACK: At some point, MinEmacs startup become too slow, specially when
;; initializing `general' and `evil'. After trying several configurations, I
;; figured out that deferring `general' solves the issue. However, deferring
;; `general' means that we cannot define the keybindings when loading other
;; packages, i.e. before `general' gets loaded and the MinEmacs definers (i.e.
;; `+minemacs--internal-map!', `+minemacs--internal-map-local!', ...) are made
;; available. We overcome this by defining these macros to define the
;; keybindings by wrapping the actual definition in a `with-eval-after-load'
;; block to be evaluated only after `general' gets loaded and configured and the
;; definers are ready (See `me-keybindings').
;;;###autoload
(defmacro +map! (&rest args)
  "A wrapper around `+minemacs--internal-map!'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (+minemacs--internal-map! ,@args)))

;;;###autoload
(defmacro +map-local! (&rest args)
  "A wrapper around `+minemacs--internal-map-local!'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (+minemacs--internal-map-local! ,@args)))

;; Wrappers around `general's VIM like definers, needs `general-evil-setup' to
;; be executed (See `me-keybindings')
;;;###autoload
(defmacro +nmap! (&rest args)
  "A wrapper around `general-nmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-nmap ,@args)))

;;;###autoload
(defmacro +vmap! (&rest args)
  "A wrapper around `general-vmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-vmap ,@args)))

;;;###autoload
(defmacro +mmap! (&rest args)
  "A wrapper around `general-mmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-mmap ,@args)))

;;;###autoload
(defmacro +imap! (&rest args)
  "A wrapper around `general-imap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-imap ,@args)))

;;;###autoload
(defmacro +emap! (&rest args)
  "A wrapper around `general-emap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-emap ,@args)))

;;;###autoload
(defmacro +omap! (&rest args)
  "A wrapper around `general-omap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-omap ,@args)))

;;;###autoload
(defmacro +rmap! (&rest args)
  "A wrapper around `general-rmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-rmap ,@args)))

;;;###autoload
(defmacro +iemap! (&rest args)
  "A wrapper around `general-iemap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-iemap ,@args)))

;;;###autoload
(defmacro +nvmap! (&rest args)
  "A wrapper around `general-nvmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-nvmap ,@args)))
#+end_src
*** +keybinding.el =TAIL=
#+begin_src emacs-lisp
;;; +keybinding.el ends here
#+end_src
** +minemacs.el
:properties:
:header-args: :tangle elisp/+minemacs.el
:end:
=minemacs.el= 一些宏和方法 简化配置
*** +minemacs.el =HEAD=
#+begin_src emacs-lisp
;;; +minemacs.el --- +keybinding -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +minemacs.el =log=
#+begin_src emacs-lisp
;;;###autoload
(defmacro +error! (msg &rest vars)
  "Log error MSG and VARS using `message'."
  (when (>= minemacs-msg-level 1)
    `(apply #'message (list (concat "[MinEmacs:Error] " ,msg) ,@vars))))

;;;###autoload
(defmacro +info! (msg &rest vars)
  "Log info MSG and VARS using `message'."
  (when (>= minemacs-msg-level 2)
    `(let ((inhibit-message t))
      (apply #'message (list (concat "[MinEmacs:Info] " ,msg) ,@vars)))))

;;;###autoload
(defmacro +log! (msg &rest vars)
  "Log MSG and VARS using `message' when `minemacs-verbose' is non-nil."
  (when (>= minemacs-msg-level 3)
    `(let ((inhibit-message t))
      (apply #'message (list (concat "[MinEmacs:Log] " ,msg) ,@vars)))))

;;;###autoload
(defmacro +debug! (msg &rest vars)
  "Log error MSG and VARS using `message'."
  (when (>= minemacs-msg-level 4)
    `(let ((inhibit-message t))
      (apply #'message (list (concat "[MinEmacs:Debug] " ,msg) ,@vars)))))
#+end_src
*** +minemacs.el =featurep=
#+begin_src emacs-lisp
;;;###autoload
(defun +emacs-features-p (&rest feats)
  "Is features FEATS are enabled in this Emacs build."
  (cl-every (lambda (feat) (memq feat emacs/features)) feats))
#+end_src
*** +minemacs.el =inhibit-message=
#+begin_src emacs-lisp
;;;###autoload
(defmacro +fn-inhibit-messages! (fn &optional no-message-log)
  "Add an advice around the function FN to suppress messages in echo area.
If NO-MESSAGE-LOG is non-nil, do not print any message to *Messages* buffer."
  (let ((advice-fn (make-symbol (format "+%s--inhibit-messages-a" fn))))
    `(advice-add
      ',fn :around
      (defun ,advice-fn (origfn &rest args)
       (let ((message-log-max (unless ,no-message-log message-log-max)))
        (with-temp-message (or (current-message) "")
         (+log! "Inhibiting messages of %s" ,(symbol-name fn))
         (apply origfn args)))))))

;;;###autoload
(defmacro +shutup! (&rest body)
  "Suppress new messages temporarily in the echo area and the `*Messages*' buffer while BODY is evaluated."
  (if (not minemacs-verbose)
      `(let ((message-log-max nil))
        (with-temp-message (or (current-message) "") ,@body))
    `(progn ,@body)))

;;;###autoload
(defmacro +suppress! (&rest body)
  "Suppress new messages temporarily in the echo area while BODY is evaluated."
  (if (not minemacs-verbose)
      `(with-temp-message (or (current-message) "") ,@body)
    `(progn ,@body)))
#+end_src
*** +minemacs.el =convert to interactive=
#+begin_src emacs-lisp
;;;###autoload
(defmacro +cmdfy! (&rest body)
  "Convert BODY to an interactive command."
  `(lambda ()
     (interactive)
     ,@body))
#+end_src
*** +minemacs.el =set-fonts=
#+begin_src emacs-lisp
;;;###autoload
(defun +set-fonts ()
  "Set Emacs' fonts from `minemacs-fonts'."
  (interactive)
  ;; TODO: use (font-family-list) to check if the font is available
  (custom-set-faces
   `(default
     ((t (:font ,(format "%s %d"
                  (or (plist-get minemacs-fonts :font-family)
                   (plist-get minemacs-default-fonts :font-family))
                  (or (plist-get minemacs-fonts :font-size)
                   (plist-get minemacs-default-fonts :font-size)))))))
   `(fixed-pitch
     ((t (:inherit (default)))))
   `(fixed-pitch-serif
     ((t (:inherit (default)))))
   `(variable-pitch
     ((t (:font ,(format "%s %d"
                  (or (plist-get minemacs-fonts :variable-pitch-font-family)
                   (plist-get minemacs-default-fonts :variable-pitch-font-family))
                  (or (plist-get minemacs-fonts :variable-pitch-font-size)
                   (plist-get minemacs-default-fonts :variable-pitch-font-size))))))))
  ;; Run hooks
  (run-hooks 'minemacs-after-set-fonts-hook))
#+end_src
*** +minemacs.el =load-theme=
#+begin_src emacs-lisp
;;;###autoload
(defun +load-theme ()
  "Load Emacs' theme from `minemacs-theme'."
  (interactive)
  (when minemacs-theme
    (+log! "Loading user theme: %s" minemacs-theme)
    ;; Fallback to built-in `tsdh-light' when `minemacs-theme' is not available.
    (unless (ignore-errors (load-theme minemacs-theme t))
      (+error! "Cannot load theme \"%s\", falling back to \"tsdh-light\"." minemacs-theme)
      (load-theme 'tsdh-light t)))
  ;; Run hooks
  (run-hooks 'minemacs-after-load-theme-hook))
#+end_src
*** +minemacs.el =eval-when-idle=
*** +minemacs.el =deferred=
#+begin_src emacs-lisp
;;;###autoload
(defmacro +deferred! (&rest body)
  "Run BODY after Emacs gets loaded, a.k.a. after `minemacs-loaded'."
  `(with-eval-after-load 'minemacs-loaded
    ,@body))

;;;###autoload
(defmacro +deferred-when! (condition &rest body)
  "Like `+deferred!', with BODY executed only if CONDITION is non-nil."
  (declare (indent 1))
  `(when ,condition (+deferred! ,@body)))

;;;###autoload
(defmacro +deferred-unless! (condition &rest body)
  "Like `+deferred!', with BODY executed only if CONDITION is nil."
  (declare (indent 1))
  `(unless ,condition (+deferred! ,@body)))

;;;###autoload
(defmacro +deferred-or-immediate! (condition &rest body)
  "Like `+deferred!', with BODY deferred if CONDITION is non-nil, otherwise it acts like `progn'."
  (declare (indent 1))
  `(if ,condition (+deferred! ,@body) (progn ,@body)))
#+end_src
*** +minemacs.el =lazy=
#+begin_src emacs-lisp
;;;###autoload
(defmacro +lazy! (&rest body)
  "Run BODY as a lazy block (see `minemacs-lazy')."
  `(with-eval-after-load 'minemacs-lazy
    (+eval-when-idle-for! 1.0
     ,@body)))

;;;###autoload
(defmacro +lazy-when! (condition &rest body)
  "Like `+lazy!', with BODY executed only if CONDITION is non-nil."
  (declare (indent 1))
  `(when ,condition (+lazy! ,@body)))

;;;###autoload
(defmacro +lazy-unless! (condition &rest body)
  "Like `+lazy!', with BODY executed only if CONDITION is nil."
  (declare (indent 1))
  `(unless ,condition (+lazy! ,@body)))

;;;###autoload
(defmacro +lazy-or-immediate! (condition &rest body)
  "Like `+lazy!', with BODY deferred if CONDITION is non nil, otherwise it acts like `progn'."
  (declare (indent 1))
  `(if ,condition (+lazy! ,@body) (progn ,@body)))
#+end_src
*** +minemacs.el =after-load=
#+begin_src emacs-lisp
;;;###autoload
(defmacro +after-load! (features &rest body)
  "Execute BODY after FEATURES have been loaded."
  (declare (indent 1))
  (let ((features (if (+quoted features) (+unquote features) (eval features))))
    (if (symbolp features)
        `(with-eval-after-load ',features ,@body)
      (let ((feature (car features)))
        (cond
         ((memq feature '(:or :any))
          (macroexp-progn
           (cl-loop
            for next in (cdr features)
            collect `(with-eval-after-load ',(+unquote next) ,@body))))
         ((memq feature '(:and :all))
          (dolist (next (reverse (cdr features)) (car body))
            (setq body `((with-eval-after-load ',(+unquote next) ,@body)))))
         (t `(+after-load! '(:all ,@features) ,@body)))))))
#+end_src
*** +minemacs.el =hook=
#+begin_src emacs-lisp
;; Adapted from: github.com/d12frosted/environment
;;;###autoload
(defmacro +hook-with-delay! (hook secs function &optional depth local)
  "Add the FUNCTION to the value of HOOK.
The FUNCTION is delayed to be evaluated in SECS once HOOK is
triggered.
DEPTH and LOCAL are passed as is to `add-hook'."
  (let* ((f-name (make-symbol (format "%s-on-%s-delayed-%ds-h" (+unquote function) (+unquote hook) secs)))
         (f-doc (format "Call `%s' in %d seconds" (symbol-name (+unquote function)) secs)))
    `(eval-when-compile
       (defun ,f-name () ,f-doc
        (run-with-idle-timer ,secs nil ,function))
       (add-hook ,hook #',f-name ,depth ,local))))

(defvar +hook-once-num 0)

;;;###autoload
(defmacro +hook-once! (hook &rest body)
  "Hook BODY in HOOK, it runs only once."
  (declare (indent 1))
  (let ((hook (+unquote hook))
        (fn-name (intern (format "+hook-once--function-%d-h" (cl-incf +hook-once-num)))))
    `(add-hook
      ',hook
      (defun ,fn-name ()
       ,(macroexp-progn body)
       (remove-hook ',hook ',fn-name)))))
#+end_src
*** +minemacs.el =complie-function=
#+begin_src emacs-lisp
;; Adapted from: Doom Emacs
;;;###autoload
(defun +compile-functions (&rest fns)
  "Queue FNS to be byte/natively-compiled after a brief delay."
  (dolist (fn fns)
    (+eval-when-idle!
      (or (and (featurep 'native-compile)
               (or (subr-native-elisp-p (indirect-function fn))
                   ;; Do not log to `comp-log-buffer-name'
                   (cl-letf (((symbol-function 'comp-log-to-buffer) #'ignore))
                     (+shutup! (ignore-errors (native-compile fn))))))
          (byte-code-function-p fn)
          (let (byte-compile-warnings)
            (+shutup! (byte-compile fn)))))))
#+end_src
*** +minemacs.el =env load & save=
#+begin_src emacs-lisp
;;;###autoload
(defun +env-save ()
  "Load environment variables of the current session to the file
  \".emacs.d/local/system-env.el\"."
  (interactive)
  (with-temp-buffer
    (insert ";; -*- mode: emacs-lisp; no-byte-compile: t; no-native-compile: t; -*-\n\n")
    (dolist (env-var +env-save-vars)
      (when-let ((var-val (getenv env-var)))
        (when (equal "PATH" env-var)
          (insert
           (format
            "\n;; Helper function\n%s\n"
            '(defun +add-to-path (path)
              (unless (member path exec-path)
               (add-to-list 'exec-path path)))))
          (insert "\n;; Adding PATH content to `exec-path'\n")
          (dolist (path (parse-colon-path var-val))
            (when path
              (insert
               (format
                "(+add-to-path \"%s\")\n"
                path path))))
          (insert "\n"))
        (insert
         (format "(setenv \"%s\" \"%s\")\n" env-var var-val))))
    (write-file (concat minemacs-local-dir "system-env.el"))))

;;;###autoload
(defun +env-load ()
  "Load environment variables from the file saved in
  \".emacs.d/local/system-env.el\" if available."
  (interactive)
  (let ((env-file (concat minemacs-local-dir "system-env.el")))
    (when (file-exists-p env-file)
      (+load env-file))))
#+end_src
*** +minemacs.el =ignore-root=
#+begin_src emacs-lisp
;;;###autoload
(defun +ignore-root (&rest roots)
  "Add ROOTS to ignored projects, recentf, etc."
  (dolist (root roots)
    (with-eval-after-load 'recentf
      (add-to-list 'recentf-exclude root))))
#+end_src
*** +minemacs.el =TAIL=
#+begin_src emacs-lisp
;;; +minemacs.el ends here
#+end_src
** WAIT netextender.el
=netextender.el= 程序netextender的封装
暂时用不到  可以学习一下如何和命令行程序交互
:properties:
:header-args: :tangle elisp/netextender.el
:end:
*** netextender.el =HEAD=
#+begin_src emacs-lisp
;;; netextender.el --- +keybinding -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** netextender.el =netextender=
#+begin_src emacs-lisp
(defvar netextender-process-name "netextender")
(defvar netextender-buffer-name " *NetExtender*")

(defgroup minemacs-netextender nil
  "MinEmacs NetExtender."
  :group 'minemacs)

(defcustom netextender-passphrase-file "~/.ssh/sslvpn.gpg"
  "GPG encrypted NetExtender connection parameters."
  :group 'minemacs-netextender
  :type 'file)

(defcustom netextender-command '("~/.local/bin/netextender")
  "Custom NetExtender launcher."
  :group 'minemacs-netextender
  :type '(choice string file))

;; If the command doesn't exist, generate it.
(unless (file-exists-p (car netextender-command))
  (setq netextender-command (cons (make-temp-file "netextender") (cdr netextender-command)))
  (set-file-modes (car netextender-command) #o755) ;; Make it executable
  (with-temp-buffer
    (insert
     (format "#!/bin/bash

if ! command -v netExtender &> /dev/null; then
  echo \"netExtender not found, installing from AUR using 'yay'\"
  yay -S netextender
fi

MY_LOGIN_PARAMS_FILE=\"%s\"

echo \"Y\\n\" | netExtender --auto-reconnect $(gpg -q --for-your-eyes-only --no-tty -d \"${MY_LOGIN_PARAMS_FILE}\")"
             (expand-file-name netextender-passphrase-file)))
    (write-file (car netextender-command))))

(defun netextender-check-system ()
  "Return non-nil if system setup is OK."
  (let* ((pppd-command "/usr/sbin/pppd")
         (pppd-modes (file-modes pppd-command)))
    ;; pppd must be run as root (via setuid)
    (if (and pppd-modes (zerop (logand (lsh 1 11) pppd-modes))) ;; Check if the setuid bit isn't set
        (prog1 nil ;; return nil
          (message "pppd needs root permissions, please set the setuid bit of %s." pppd-command))
      t)))

;;;###autoload
(defun netextender-start ()
  "Launch a NetExtender VPN session."
  (interactive)
  (if (netextender-check-system)
      (unless (get-process netextender-process-name)
        (if (make-process :name netextender-process-name
                          :buffer netextender-buffer-name
                          :command netextender-command)
            (message "Started NetExtender VPN session.")
          (user-error "Cannot start NetExtender.")))
    (user-error "Cannot start a netExtender VPN session.")))

(defun netextender-kill ()
  "Kill the created NetExtender VPN session."
  (interactive)
  (let ((netextender-process (get-process netextender-process-name)))
    (if netextender-process
        (if (kill-process netextender-process)
            (message "Killed NetExtender VPN session.")
          (user-error "Cannot kill NetExtender."))
      (message "No running NetExtender session."))))

;;;###autoload
(defun netextender-toggle ()
  "Toggle connection to NetExtender."
  (interactive)
  (if (get-process netextender-process-name)
      (netextender-kill)
    (netextender-start)))
#+end_src
*** netextender.el =TAIL=
#+begin_src emacs-lisp
;;; netextender.el ends here
#+end_src
** +project.el
:properties:
:header-args: :tangle elisp/project.el
:end:
*** +project.el =HEAD=
#+begin_src emacs-lisp
;;; +project.el --- project -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +project.el 自动扫描目录添加项目
#+begin_src emacs-lisp
(defgroup minemacs-project nil
  "MinEmacs project stuff."
  :group 'minemacs)

(defcustom +project-scan-dir-paths nil
  "A list of paths to scan and add to known projects list.
It can be a list of strings (paths) or a list of (cons \"~/path/to/projects\" recursive?)
to scan directories recursively."
  :group 'minemacs-project
  :type '(repeat (choice directory (cons directory boolean))))

;;;###autoload
(defun +project-scan-for-projects ()
  "Scan and remember projects under `+project-scan-dir-paths'."
  (interactive)
  (dolist (cons-dir +project-scan-dir-paths)
    (let* ((cons-dir (ensure-list cons-dir))
           (root-dir (car cons-dir))
           (recursive (cdr cons-dir))
           (sub-dirs (+directory-subdirs root-dir)))
      (dolist (dir sub-dirs)
        (project-remember-projects-under dir recursive)))))

;;;###autoload
(defun +project-add-project (dir &optional dont-ask)
  "Switch to another project at DIR.
When DIR is not detected as a project, ask to force it to be by adding a
\".project.el\" file."
  (interactive (list (project-prompt-project-dir)))
  (project-switch-project dir)
  (when (and (not (project-current))
             (or dont-ask
                 (yes-or-no-p "Directory not detected as a project, add \".project.el\"? ")))
    (with-temp-buffer
      (write-file (expand-file-name ".project.el" dir)))))

;;;###autoload
(defun +project-gdb ()
  "Invoke `gdb' in the project's root."
  (interactive)
  (let ((default-directory (project-root (project-current t))))
    (call-interactively #'gdb)))
#+end_src
*** +project.el =TAIL=
#+begin_src emacs-lisp
;;; +project.el ends here
#+end_src
** +primitives.el
:properties:
:header-args: :tangle elisp/primitives.el
:end:
*** +primitives.el =HEAD=
#+begin_src emacs-lisp
;;; +primitives.el --- primitives -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +primitives.el =plist= & =alist= miss fuction
#+begin_src emacs-lisp
;;; === Some plist and alist missing functions ===

;;;###autoload
(defun +plist-keys (plist)
  "Return the keys of PLIST."
  (let (keys)
    (while plist
      (push (car plist) keys)
      (setq plist (cddr plist)))
    keys))

;;;###autoload
(defmacro +plist-push! (plist &rest key-vals)
  "Push KEY-VALS to PLIST."
  (declare (indent 1))
  (let ((out (list 'progn)))
    (while (length> key-vals 0)
      (let ((key (pop key-vals))
            (val (pop key-vals)))
        (add-to-list
         'out
         `(setq ,plist (plist-put ,plist ,key ,val)) t)))
    out))

;;;###autoload
(defun +plist-combine (&rest plists)
  "Create a single property list from all plists in PLISTS.
Modified from `org-combine-plists'. This supposes the values to be vectors,
and concatenate them."
  (let ((res (copy-sequence (pop plists)))
        prop val plist)
    (while plists
      (setq plist (pop plists))
      (while plist
        (setq prop (pop plist) val (pop plist))
        (setq res (plist-put res prop (vconcat val (plist-get res prop))))))
    res))

;;;###autoload
(defun +plist-delete (plist prop)
  "Delete property PROP from PLIST.
Adapted from `org-plist-delete'."
  (let (p)
    (while plist
      (if (not (eq prop (car plist)))
          (setq p (plist-put p (car plist) (nth 1 plist))))
      (setq plist (cddr plist)))
    p))

;;;###autoload
(defun +plist-to-alist (plist &optional trim-col)
  (let ((res '()))
    (while plist
      (let* ((key (pop plist))
             (val (pop plist))
             (key (if (and trim-col (string-prefix-p ":" (symbol-name key)))
                      (intern (substring (symbol-name key) 1))
                    key)))
        (push (cons key val) res)))
    (nreverse res)))

;;;###autoload
(defun +alist-to-plist (alist &optional add-col)
  (let ((res '()))
    (dolist (x alist)
      (push (if add-col (intern (format ":%s" (car x))) (car x)) res)
      (push (cdr x) res))
    (nreverse res)))

;;;###autoload
(defun +alist-set (key val alist &optional symbol)
  "Set property KEY to VAL in ALIST. Return new alist.
This creates the association if it is missing, and otherwise sets
the cdr of the first matching association in the list. It does
not create duplicate associations. By default, key comparison is
done with `equal'. However, if SYMBOL is non-nil, then `eq' is
used instead.

This method may mutate the original alist, but you still need to
use the return value of this method instead of the original
alist, to ensure correct results."
  ;; Implementation taken from `straight--alist-set'
  ;; See [1] for the genesis of this method, which should really be
  ;; built in.
  ;;
  ;; [1]: emacs.stackexchange.com/q/33892/12534
  (if-let ((pair (if symbol (assq key alist) (assoc key alist))))
      (setcdr pair val)
    (push (cons key val) alist))
  alist)
#+end_src
*** +primitives.el =serialization=
#+begin_src emacs-lisp
;;; === Serialization ===

(defcustom +serialized-symbols-directory (concat minemacs-local-dir "+serialized-symbols/")
  "Default directory to store serialized symbols."
  :group 'minemacs-core
  :type 'directory)

;;;###autoload
(defun +serialize-sym (sym &optional dir filename-format)
  "Serialize SYM to DIR.
If FILENAME-FORMAT is non-nil, use it to format the file name (ex. \"file-%s.el\").
Return the written file name, or nil if SYM is not bound."
  (when (boundp sym)
    (let ((out-file (expand-file-name
                     (format (or filename-format "%s.el") (symbol-name sym))
                     (or dir +serialized-symbols-directory))))
      (+log! "Saving `%s' to file \"%s\"" (symbol-name sym) (abbreviate-file-name out-file))
      (with-temp-buffer
        (prin1 (eval sym) (current-buffer))
        (+shutup! (write-file out-file)))
      out-file)))

;;;###autoload
(defun +deserialize-sym (sym &optional dir mutate filename-format)
  "Deserialize SYM from DIR, if MUTATE is non-nil, assign the object to SYM.
If FILENAME-FORMAT is non-nil, use it to format the file name (ex. \"file-%s.el\").
Return the deserialized object, or nil if the SYM.el file dont exist."
  (let ((in-file (expand-file-name
                  (format (or filename-format "%s.el") (symbol-name sym))
                  (or dir +serialized-symbols-directory)))
        res)
    (when (file-exists-p in-file)
      (+log! "Loading `%s' from file \"%s\"" sym (abbreviate-file-name in-file))
      (with-temp-buffer
        (insert-file-contents in-file)
        (goto-char (point-min))
        (ignore-errors (setq res (read (current-buffer)))))
      (when mutate (set sym res)))
    res))
#+end_src
*** +primitives.el =misc=
#+begin_src emacs-lisp
;;; === Misc ===

;; See: emacs.stackexchange.com/q/3022/37002
;;;###autoload
(defun +reset-sym (sym)
  "Reset SYM to its standard value."
  (set sym (eval (car (get sym 'standard-value)))))

;;;###autoload
(defmacro +reset-var! (var)
  "Reset VAR to its standard value."
  `(setq ,var (eval (car (get ',var 'standard-value)))))

;; Adapted from `evil-unquote', takes functions into account
;;;###autoload
(defun +unquote (expr)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe expr) '(quote function))
    (setq expr (cadr expr)))
  expr)

;;;###autoload
(defun +quoted (expr)
  "Retrun t when EXP is quoted."
  (memq (car-safe expr) '(quote function)))

;;;###autoload
(defun +apply-partially-right (fun &rest args)
  "Like `apply-partially', but applies the ARGS to the right of FUN."
  (lambda (&rest args2)
    (apply fun (append args2 args))))
#+end_src
*** +primitives.el =TAIL=
#+begin_src emacs-lisp
;;; +primitives.el ends here
#+end_src
** +systemd.el
=+systemd.el= 启动 关闭 检查 服务状态 --user
:properties:
:header-args: :tangle elisp/systemd.el
:end:
*** +systemd.el =HEAD=
#+begin_src emacs-lisp
;;; +systemd.el --- systemd wrapper -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +systemd.el =systemd wrapper=
#+begin_src emacs-lisp
;;;###autoload
(defun +systemd-running-p (service)
  "Check if the systemd SERVICE is running."
  (zerop (call-process "systemctl" nil nil nil "--user" "is-active" "--quiet" service ".service")))

;;;###autoload
(defun +systemd-command (service command &optional pre-fn post-fn)
  "Call systemd with COMMAND and SERVICE."
  (when pre-fn (funcall pre-fn))
  (let ((success (zerop (call-process "systemctl" nil nil nil "--user" command service ".service"))))
    (unless success
      (user-error "[systemd]: Failed on calling '%s' on service %s.service." command service))
    (when post-fn (funcall post-fn success))
    success))

;;;###autoload
(defun +systemd-start (service &optional pre-fn post-fn)
  "Start systemd SERVICE."
  (+systemd-command service "start" pre-fn post-fn))

;;;###autoload
(defun +systemd-stop (service &optional pre-fn post-fn)
  "Stops the systemd SERVICE."
  (+systemd-command service "stop" pre-fn post-fn))
#+end_src
*** +systemd.el =TAIL=
#+begin_src emacs-lisp
;;; +systemd.el ends here
#+end_src
** +unix.el
:properties:
:header-args: :tangle elisp/unix.el
:end:
*** +unix.el =HEAD=
#+begin_src emacs-lisp
;;; +unix.el --- unix cmd wrapper -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** +unix.el =unix cmd wrapper=
#+begin_src emacs-lisp
;; From: emacswiki.org/emacs/download/misc-cmds.el
(defun +read-shell-file-command (command)
  "Prompt for shell COMMAND, using current buffer's file as default arg.
If buffer is not associated with a file, you are prompted for a file.
COMMAND is a symbol."
  (let ((file (or (buffer-file-name) (read-file-name "File: "))))
    (setq file (and file (file-name-nondirectory file))
          command (format "%s  " command)) ; Convert to string.
    (read-from-minibuffer
     "" (cons (concat command (and file  (concat " " file))) (length command)))))

;;;###autoload
(defun +chmod-this-file (cmd)
  "Execute Unix command `chmod'.  Current buffer's file is default arg.
CMD is the command to execute (interactively, `chmod')."
  (interactive (list (+read-shell-file-command 'chmod)))
  (shell-command cmd))

;;;###autoload
(defun +chgrp-this-file (cmd)
  "Execute Unix command `chgrp'.  Current buffer's file is default arg.
CMD is the command to execute (interactively, `chgrp')."
  (interactive (list (+read-shell-file-command 'chgrp)))
  (shell-command cmd))

;;;###autoload
(defun +chown-this-file (cmd)
  "Execute Unix command `chown'.  Current buffer's file is default arg.
CMD is the command to execute (interactively, `chown')."
  (interactive (list (+read-shell-file-command 'chown)))
  (shell-command cmd))
#+end_src
*** +unix.el =TAIL=
#+begin_src emacs-lisp
;;; +unix.el ends here
#+end_src
** valgrind.el
:properties:
:header-args: :tangle elisp/valgrind.el
:end:
*** valgrind.el =HEAD=
#+begin_src emacs-lisp
;;; valgrind.el --- valgrind wrapper -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** valgrind.el =valgrind wrapper=
#+begin_src emacs-lisp
(require 'compile)

(defgroup valgrind nil
  "Run valgrind as inferior of Emacs, parse error messages."
  :group 'tools
  :group 'processes)

(defcustom valgrind-command "valgrind --leak-check=full "
  "*Last shell command used to run valgrind; default for next valgrind run.
Sometimes it is useful for files to supply local values for this variable.
You might also use mode hooks to specify it in certain modes, like this:
  (add-hook 'c-mode-hook
    (lambda ()
      (unless (or (file-exists-p \"makefile\")
                  (file-exists-p \"Makefile\"))
        (set (make-local-variable 'valgrind-command)
             (concat \"make -k \"
                     (file-name-sans-extension buffer-file-name))))))"
  :type 'string
  :group 'valgrind)

;; History of compile commands.
(defvar valgrind-history nil)

;; Integration with `savehist'
(with-eval-after-load 'savehist
  (add-to-list 'savehist-additional-variables 'valgrind-history))

;;;###autoload
(defun valgrind (command)
  "Run valgrind.
Runs COMMAND, a shell command, in a separate process asynchronously
with output going to the buffer `*valgrind*'.
You can then use the command \\[next-error] to find the next error message
and move to the source code that caused it."
  (interactive
   (if (or compilation-read-command current-prefix-arg)
       (list (read-from-minibuffer "Valgrind command: "
                                   (eval valgrind-command) nil nil
                                   '(valgrind-history . 1)))
     (list (eval valgrind-command))))
  (let ((default-directory (or (project-root (project-current)) default-directory)))
    (unless (equal command (eval valgrind-command))
      (setq valgrind-command command))
    (compilation-start command nil (lambda (mode) "*valgrind*"))))


(provide 'valgrind)
#+end_src
*** valgrind.el =TAIL=
#+begin_src emacs-lisp
;;; valgrind.el ends here
#+end_src
* modules/
=modules= 目录下是各个模块
** extras/
** obsolete/
** WAIT me-biblio.el
:properties:
:header-args: :tangle modules/me-biblio.el
:end:
=me-biblio.el= bibliography 用来做文献引用
*** me-biblio.el =HEAD=
#+begin_src emacs-lisp
;;; me-biblio.el --- bibliography -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-biblio.el package =oc=
#+begin_src emacs-lisp
(use-package oc
  :straight (:type built-in)
  :after org
  :demand t
  :custom
  (org-cite-export-processors '((latex biblatex) (t csl)))
  (org-support-shift-select t)
  :config
  (+map-local! :keymaps 'org-mode-map
    "C" #'org-cite-insert))

(use-package oc-csl
  :straight (:type built-in)
  :after oc
  :demand t)

(use-package oc-natbib
  :straight (:type built-in)
  :after oc
  :demand t)

(use-package oc-biblatex
  :straight (:type built-in)
  :after oc
  :demand t)
#+end_src
*** me-biblio.el pacakge =zotxt=
#+begin_src emacs-lisp
(use-package zotxt
  :straight t
  :preface
  (defconst +zotero-available-p (executable-find "zotero"))
  :when +zotero-available-p
  :init
  (+map-local! :keymaps 'org-mode-map
    "z" #'org-zotxt-mode)
  (+map-local! :keymaps 'markdown-mode-map
    "z" #'zotxt-citekey-mode))
#+end_src
*** me-biblio.el package =citar=
#+begin_src emacs-lisp
(use-package citar
  :straight t
  :after oc
  :demand t
  :custom
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  (citar-symbol-separator "  ")
  :config
  (defun +citar--set-symbols ()
    (setq citar-symbols
          `((file ,(all-the-icons-octicon "file-pdf"      :face 'error) . " ")
            (note ,(all-the-icons-octicon "file-text"     :face 'warning) . " ")
            (link ,(all-the-icons-octicon "link-external" :face 'org-link) . " "))))

  ;; Properly setup citar-symbols
  (if (display-graphic-p)
      (+citar--set-symbols)
    (add-hook
     'server-after-make-frame-hook
     (defun +citar--set-symbols-once-h ()
       (when (display-graphic-p)
         (+citar--set-symbols)
         (remove-hook 'server-after-make-frame-hook
                      #'+citar--set-symbols-once-h))))))

(use-package citar-org-roam
  :straight t
  :after citar org-roam
  :demand t
  :commands +org-roam-node-from-cite
  :config
  ;; Modified form: jethrokuan.github.io/org-roam-guide/
  (defun +org-roam-node-from-cite (entry-key)
    (interactive (list (citar-select-ref)))
    (let ((title (citar-format--entry
                  "${author editor} (${date urldate}) :: ${title}"
                  (citar-get-entry entry-key))))
      (org-roam-capture- :templates
                         `(("r" "reference" plain
                            "%?"
                            :if-new (file+head "references/${citekey}.org"
                                     ,(concat
                                       ":properties:\n"
                                       ":roam_refs: [cite:@${citekey}]\n"
                                       ":end:\n"
                                       "#+title: ${title}\n"))
                            :immediate-finish t
                            :unnarrowed t))
                         :info (list :citekey entry-key)
                         :node (org-roam-node-create :title title)
                         :props '(:finalize find-file))))
  (citar-org-roam-mode 1))

(use-package citar-embark
  :straight t
  :after citar embark
  :demand t
  :config
  (citar-embark-mode 1))
#+end_src
*** me-biblio.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-biblio)
;;; me-biblio.el ends here
#+end_src
** WAIT me-binary.el
:properties:
:header-args: :tangle modules/me-binary.el
:end:
=me-binary.el= 二进制一些信息的查看
*** me-binary.el =HEAD=
#+begin_src emacs-lisp
;;; me-binary.el --- stuff to work with binary files -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-binary.el 加载 =+binary-setup-modes=
#+begin_src emacs-lisp
;; +binary-* are autoloaded
(+deferred!
 ;; BUG: Loading continuously on `dirvish'.
 ;; BUG: Showing up randomly on `tramp' files.
 (setq +binary-objdump-enable nil)
 (+binary-setup-modes))
#+end_src
*** me-binary.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-binary)
;;; me-binary.el ends here
#+end_src
** me-checkers.el
:properties:
:header-args: :tangle modules/me-checkers.el
:end:
*** me-checkers.el =HEAD=
#+begin_src emacs-lisp
;;; me-checkers.el --- syntax checking -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-checkers.el package =flymake=
#+begin_src emacs-lisp
(use-package flymake
  :straight (:type built-in)
  :init
  (+map! "tf" #'flymake-mode)
  :custom
  (flymake-fringe-indicator-position 'right-fringe)
  (flymake-error-bitmap '(+flymake-bitmap-left-arrow-hi-res compilation-error))
  (flymake-warning-bitmap '(+flymake-bitmap-left-arrow-hi-res compilation-warning))
  (flymake-note-bitmap '(+flymake-bitmap-left-arrow-hi-res compilation-info))
  :config
  (+map-local! :keymaps 'flymake-mode-map
    "f"  '(nil :wk "flymake")
    "fn" #'flymake-goto-next-error
    "fN" #'flymake-goto-prev-error
    "fs" #'flymake-start
    "fb" #'flymake-show-buffer-diagnostics
    "fp" #'flymake-show-project-diagnostics)

  ;; Use the session's load-path with flymake
  (setq elisp-flymake-byte-compile-load-path load-path)
  ;; Larger right frings
  (set-fringe-style '(8 . 13))

  ;; Better fringe bitmaps
  (when (fboundp 'define-fringe-bitmap)
    (define-fringe-bitmap '+flymake-bitmap-arrow
      [#b11111000
       #b01111100
       #b00111110
       #b00011111
       #b00111110
       #b01111100
       #b11111000])
    (define-fringe-bitmap '+flymake-bitmap-arrow-hi-res
      [#b01111000000
       #b00111100000
       #b00011110000
       #b00001111000
       #b00000111100
       #b00000011110
       #b00000011110
       #b00000111100
       #b00001111000
       #b00011110000
       #b00111100000
       #b01111000000]
      nil 13)
    (define-fringe-bitmap '+flymake-bitmap-left-arrow-hi-res
      [#b00000011110
       #b00000111100
       #b00001111000
       #b00011110000
       #b00111100000
       #b01111000000
       #b01111000000
       #b00111100000
       #b00011110000
       #b00001111000
       #b00000111100
       #b00000011110]
      nil 13)))

(use-package flymake-easy
  :straight t)
#+end_src
*** me-checkers.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-checkers)
;;; me-checkers.el ends here
#+end_src
** me-daemon.el
:properties:
:header-args: :tangle modules/me-daemon.el
:end:
*** me-daemon.el =HEAD=
#+begin_src emacs-lisp
;;; me-daemon.el --- daemon -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-daemon.el =email (mu4e)=
#+begin_src emacs-lisp
;; Email (mu4e)
(+lazy-when! (memq 'me-email minemacs-modules)
  (when (require 'mu4e nil t)
    (unless (mu4e-running-p)
      (+info! "Starting `mu4e' in background.")
      (let ((inhibit-message t))
        (mu4e t)))))
#+end_src
*** me-daemon.el =rss (elfeed)=
#+begin_src emacs-lisp
;; RSS (elfeed)
(+lazy-when! (memq 'me-rss minemacs-modules)
  (run-at-time
   (* 60 5) ;; 5min
   (* 60 60) ;; 1h
   (lambda ()
     (+info! "Updating RSS feed.")
     (let ((inhibit-message t))
       (elfeed-update)))))
#+end_src
*** me-daemon.el =emacs server=
#+begin_src emacs-lisp
;; When we start in a non-daemon Emacs, we start a server whe Emacs is idle.
(+lazy-unless! (daemonp)
  (require 'server) ; For using `server-running-p'
  (unless (server-running-p)
    (let ((inhibit-message t))
      (+info! "Starting Emacs daemon in background.")
      (server-start nil t))))

;; Reload theme when creating a frame on the daemon
(add-hook
 'server-after-make-frame-hook
 (defun +daemon--reload-theme-h ()
   (load-theme minemacs-theme t)))

(+hook-once! server-after-make-frame-hook
  (when (and (display-graphic-p)
             (bound-and-true-p display-battery-mode))
    (display-battery-mode -1)
    (display-battery-mode 1)))
#+end_src
*** me-daemon.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-daemon)
;;; me-daemon.el ends here
#+end_src
** me-data.el
:properties:
:header-args: :tangle modules/me-data.el
:end:
=me-data.el= 一些配置文件相关包(csv, yaml, xml, graphviz, ...)
*** me-data.el =HEAD=
#+begin_src emacs-lisp
;;; me-data.el --- Data and visualizaion formats (csv, yaml, xml, graphviz, ...) -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-data.el =csv-mode=
#+begin_src emacs-lisp
(use-package csv-mode
  :straight t
  :mode "\\.csv\\'"
  :config
  (+map-local! :keymaps 'csv-mode-map
    "r" #'+csv-rainbow
    "a" #'csv-align-fields
    "u" #'csv-unalign-fields
    "s" #'csv-sort-fields
    "S" #'csv-sort-numeric-fields
    "k" #'csv-kill-fields
    "t" #'csv-transpose)

  ;; Adapted from: reddit.com/r/emacs/comments/26c71k/comment/chq2r8m
  (defun +csv-rainbow (&optional separator)
    "Colorize CSV columns."
    (interactive (list (when current-prefix-arg (read-char "Separator: "))))
    (require 'color)
    (font-lock-mode 1)
    (let* ((separator (or separator ?\,))
           (n (count-matches (string separator) (point-at-bol) (point-at-eol)))
           (colors (cl-loop for i from 0 to 1.0 by (/ 2.0 n)
                            collect (apply #'color-rgb-to-hex
                                           (color-hsl-to-rgb i 0.3 0.5)))))
      (cl-loop for i from 2 to (1+ n) by 2
               for c in colors
               for r = (format "^\\([^%c\n]*[%c\n]\\)\\{%d\\}" separator separator i)
               do (font-lock-add-keywords nil `((,r (1 '(face (:foreground ,c))))))))))
#+end_src
*** me-data.el =yaml-mode=
#+begin_src emacs-lisp
(use-package yaml-mode
  :straight t
  :mode "Procfile\\'")

(use-package yaml-pro
  :straight t
  :hook (yaml-mode . yaml-pro-mode)
  :hook (yaml-ts-mode . yaml-pro-ts-mode))
#+end_src
*** me-data.el =toml-mode=
#+begin_src emacs-lisp
(use-package toml-mode
  :straight t
  :mode "\\.toml\\'")
#+end_src
*** me-data.el =json-mode=
#+begin_src emacs-lisp
(use-package json-mode
  :straight t
  :mode "\\.js\\(?:on\\|[hl]int\\(?:rc\\)?\\)\\'"
  :config
  (+map-local! :keymaps 'json-mode-map
    "p" #'json-mode-show-path
    "t" #'json-toggle-boolean
    "d" #'json-mode-kill-path
    "x" #'json-nullify-sexp
    "+" #'json-increment-number-at-point
    "-" #'json-decrement-number-at-point
    "f" #'json-mode-beautify))
#+end_src
*** NO me-data.el =graphviz-dot-mode=
#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :straight (graphviz-dot-mode :files ("graphviz-dot-mode.el" "texinfo"))
  :custom
  (graphviz-dot-view-command "xdot %s")
  (graphviz-dot-preview-extension "svg")
  :config
  (+map-local! :keymaps 'graphviz-dot-mode-map
    "p" #'graphviz-dot-preview
    "P" #'graphviz-dot-view
    "l" #'graphviz-turn-on-live-preview
    "L" #'graphviz-turn-off-live-preview)
  (+eglot-register 'graphviz-dot-mode '("dot-language-server" "--stdio")))
#+end_src
*** me-data.el =nxml=
#+begin_src emacs-lisp
(use-package nxml-mode
  :straight (:type built-in)
  :config
  (+eglot-register '(nxml-mode xml-mode) "lemminx"))
#+end_src
*** me-data.el =plantuml-mode=
#+begin_src emacs-lisp
(use-package plantuml-mode
  :straight t
  :mode "\\.plantuml\\'"
  :hook (plantuml-mode . +plantuml-mode-setup)
  :custom
  (plantuml-jar-path (concat minemacs-local-dir "plantuml/plantuml.jar"))
  (plantuml-indent-level 2)
  :config
  (setq
   plantuml-default-exec-mode
   (cond
    ;; Prefer the system's executable when available
    ((executable-find plantuml-executable-path) 'executable)
    ;; Then, use the JAR if it exists or try to download it
    ((let ((ret (or (file-exists-p plantuml-jar-path)
                    (and (not noninteractive) (ignore-errors (plantuml-download-jar))))))
       (or (eq ret t) (and (stringp ret) (not (string-equal ret "Aborted.")))))
     'jar)
    ;; Fall back to the server configured at `plantuml-server-url'
    'server))

  ;; Define `capf' function, based on `plantuml-complete-symbol'
  (defun +plantuml-completion-at-point ()
    "Perform symbol-at-pt completion on word before cursor."
    (when (derived-mode-p 'plantuml-mode) ; do not fire up on other modes
      (let* ((end-pos (point))
             (sym-at-pt (or (thing-at-point 'symbol) ""))
             (max-match (try-completion sym-at-pt plantuml-kwdList)))
        (unless (null max-match)
          (list (- end-pos (length sym-at-pt))
                end-pos
                (if (eq max-match t)
                    (list keyword)
                  (all-completions sym-at-pt plantuml-kwdList)))))))

  ;; Add support for `capf'
  (defun +plantuml-mode-setup ()
    (add-to-list 'completion-at-point-functions #'+plantuml-completion-at-point))

  (+map-local! :keymaps 'plantuml-mode-map
    "p" #'plantuml-preview-buffer
    "P" #'plantuml-preview
    "d" `(,(+cmdfy!
            (if plantuml-mode-debug-enabled
                (plantuml-disable-debug)
              (plantuml-enable-debug)))
          :wk "Toggle debug")))
#+end_src
*** NO me-data.el =mermaid-mode=
#+begin_src emacs-lisp
(use-package mermaid-mode
  :straight t
  :config
  (+map-local! :keymaps 'mermaid-mode-map
    "c" 'mermaid-compile
    "f" 'mermaid-compile-file
    "b" 'mermaid-compile-buffer
    "r" 'mermaid-compile-region
    "b" 'mermaid-open-browser
    "d" 'mermaid-open-doc))

(use-package ob-mermaid
  :straight (:host github :repo "arnm/ob-mermaid")
  :after ob
  :demand t
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages '((mermaid . t)))))
#+end_src
*** NO me-data.el =d2-mode=
#+begin_src emacs-lisp
(use-package d2-mode
  :straight t
  :mode "\\.d2\\'"
  :config
  (+map-local! :keymaps 'd2-mode-map
    "cc" #'d2-compile
    "cf" #'d2-compile-file
    "cb" #'d2-compile-buffer
    "cr" #'d2-compile-region
    "cF" #'d2-compile-file-and-browse
    "cB" #'d2-compile-buffer-and-browse
    "cR" #'d2-compile-region-and-browse
    "o"  #'d2-open-browser
    "v"  #'d2-view-current-svg
    "h"  #'d2-open-doc))

(use-package ob-d2
  :straight t
  :after ob
  :demand t
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages '((d2 . t)))))
#+end_src
*** me-data.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-data)
;;; me-data.el ends here
#+end_src
** me-debug.el
:properties:
:header-args: :tangle modules/me-debug.el
:end:
*** me-debug.el =HEAD=
#+begin_src emacs-lisp
;;; me-debug.el --- debugging stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-debug.el =gdb-mi=
#+begin_src emacs-lisp
(use-package gdb-mi
  :straight (:type built-in)
  :custom
  (gdb-show-main t) ; display source file containing main routine at startup
  (gdb-many-windows t) ; start in gdb-many-windows mode
  (gdb-debug-log-max 1024) ; default 128
  (gdb-restore-window-configuration-after-quit t)
  (gdb-thread-buffer-verbose-names nil)
  (gdb-window-configuration-directory (+directory-ensure minemacs-local-dir "gdb/"))
  (gdb-max-source-window-count 1) ; IDEA: maybe increase it!
  (gdb-display-io-nopopup nil) ; IDEA: maybe change it!
  :config
  ;; Add an overlay for the current line (mimics dap-mode)
  (defvar +gud-overlay
    (let* ((overlay (make-overlay (point-min) (point-min))))
      (overlay-put overlay 'face 'highlight)
      overlay)
    "Overlay variable for GUD highlighting.")

  (advice-add
   'gud-display-line :after
   (defun +gud--display-overlay-a (true-file _line)
     (let* ((overlay +gud-overlay)
            (buffer (gud-find-file true-file)))
       (with-current-buffer buffer
         (move-overlay overlay (line-beginning-position) (line-end-position) (current-buffer))))))

  (add-hook
   'kill-buffer-hook
   (defun +gud--delete-overlay-h ()
     (when (derived-mode-p 'gud-mode)
       (delete-overlay +gud-overlay)))))
#+end_src
*** me-debug.el =realgud=
#+begin_src emacs-lisp
(use-package realgud
  :straight t
  :init
  (+map-local! :keymaps '(c-mode-map c++-mode-map python-mode-map
                          rust-mode-map rust-ts-mode-map
                          sh-mode-map bash-ts-mode-map)
    "r" '(nil :wk "realgud")
    "rd" #'+realgud:start
    "rh" #'+realgud-hydra/body))

(use-package realgud-lldb
  :straight t
  :commands realgud--lldb)

(use-package realgud-ipdb
  :straight t)
#+end_src
*** me-debug.el =disaster= 查看汇编
#+begin_src emacs-lisp
(use-package disaster
  :straight t
  :preface
  (defconst +objdump-available-p (executable-find "objdump"))
  :when +objdump-available-p
  :init
  (+map-local! :keymaps '(c-mode-map c++-mode-map fortran-mode-map)
    "D" #'disaster))
#+end_src
*** me-debug.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-debug)
;;; me-debug.el ends here
#+end_src
** me-docs.el
:properties:
:header-args: :tangle modules/me-docs.el
:end:
*** me-docs.el =HEAD=
#+begin_src emacs-lisp
;;; me-docs.el --- Documents (PDF, EPUB, DOC...) -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-docs.el =doc-view=
#+begin_src emacs-lisp
(use-package doc-view
  :straight (:type built-in)
  :custom
  (doc-view-mupdf-use-svg (+emacs-features-p 'rsvg)))
#+end_src
*** me-docs.el =pdf-tools=
#+begin_src emacs-lisp
(use-package pdf-tools
  :straight t
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :magic ("%PDF" . pdf-view-mode)
  :custom
  (pdf-view-display-size 'fit-page)
  (pdf-view-image-relief 2)
  (pdf-view-use-scaling t)
  :init
  (+register-build-function #'pdf-tools-install))
#+end_src
*** me-docs.el =nov= 查看epub电子书
#+begin_src emacs-lisp
(use-package nov
  :straight t
  :mode ("\\.epub\\'" . nov-mode)
  :custom
  (nov-save-place-file (concat minemacs-local-dir "nov/save-place.el"))
  :config
  (+nmap! :keymaps 'nov-mode-map
    "RET" #'nov-scroll-up)
  (defun doom-modeline-segment--nov-info ()
    (concat " " (propertize (cdr (assoc 'creator nov-metadata))
                            'face 'doom-modeline-project-parent-dir)
            " " (cdr (assoc 'title nov-metadata))
            " " (propertize (format "%d/%d" (1+ nov-documents-index)
                                    (length nov-documents))
                            'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 80
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)

    (setq-local
     mode-line-format
     `((:eval
        (doom-modeline-segment--workspace-name))
       (:eval
        (doom-modeline-segment--window-number))
       (:eval
        (doom-modeline-segment--nov-info))
       ,(propertize
         " %P "
         'face 'doom-modeline-buffer-minor-mode)
       ,(propertize
         " "
         'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
         'display `((space
                     :align-to
                     (- (+ right right-fringe right-margin)
                      ,(* (let ((width (doom-modeline--font-width)))
                           (or (and (= width 1) 1)
                            (/ width (frame-char-width) 1.0)))
                        (string-width
                         (format-mode-line
                          (cons ""
                           '(:eval (doom-modeline-segment--major-mode))))))))))
       (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src
*** me-docs.el =crdt= 协同编辑
#+begin_src emacs-lisp
(use-package crdt
  :straight t
  :preface
  (defconst +tuntox-available-p (executable-find "tuntox"))
  (defconst +stunnel-available-p (executable-find "stunnel"))
  :when (or +tuntox-available-p +stunnel-available-p)
  :init
  (cond (+tuntox-available-p
         (setq crdt-use-tuntox t
               crdt-tuntox-password-in-url t))
        (+stunnel-available-p
         (setq crdt-use-stunnel t))))
#+end_src
*** me-docs.el [[https://github.com/misohena/el-easydraw][edraw]] 简易绘图
#+begin_src emacs-lisp
(use-package edraw
  :straight (:host github :repo "misohena/el-easydraw")
  :when +easydraw-available-p)

(use-package edraw-org
  :hook (org-mode . edraw-org-setup-default)
  :when +easydraw-available-p)
#+end_src
*** me-docs.el =markdown=
#+begin_src emacs-lisp
(use-package markdown-mode
  :straight t
  :mode ("README\\.md\\'" . gfm-mode)
  :custom
  (markdown-hide-markup t)
  (markdown-enable-math t))

(use-package poly-markdown
  :straight t)
#+end_src
*** me-docs.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-docs)
;;; me-docs.el ends here
#+end_src

[[edraw:][test_edVdraw]]
** me-eaf.el
:properties:
:header-args: :tangle modules/me-eaf.el
:end:
*** me-eaf.el =HEAD=
#+begin_src emacs-lisp
;;; me-eaf.el --- EAF applications -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-eaf.el =emacs-application-framework=
#+begin_src emacs-lisp
(unless (+emacs-features-p 'lucid)
  (use-package eaf
    :straight (:host github :repo "emacs-eaf/emacs-application-framework" :files (:defaults "*"))
    :init
    (+map! "oo" #'eaf-open)
    ;; Evil integration doesn't work, start `eaf-mode' in `emacs-state'.
    (with-eval-after-load 'evil
      (evil-set-initial-state 'eaf-mode 'emacs))
    (+register-build-function #'eaf-install-and-update)
    :commands eaf-file-sender-qrcode-in-dired +eaf-open-mail-as-html +browse-url-eaf eaf-open-browser
    :custom
    ;; Generic
    (eaf-apps-to-install
     '(browser mindmap jupyter pdf-viewer file-sender video-player markdown-previewer))
    (eaf-start-python-process-when-require t)
    (eaf-kill-process-after-last-buffer-closed t)
    (eaf-fullscreen-p nil)
    (eaf-config-location (concat minemacs-local-dir "eaf/"))
    ;; Debug
    (eaf-enable-debug nil)
    ;; Web engine
    (eaf-webengine-font-family (plist-get minemacs-fonts :font-family))
    (eaf-webengine-fixed-font-family (plist-get minemacs-fonts :font-family))
    (eaf-webengine-serif-font-family (plist-get minemacs-fonts :variable-pitch-font-family))
    (eaf-webengine-font-size 16)
    (eaf-webengine-fixed-font-size 16)
    (eaf-webengine-enable-scrollbar t)
    (eaf-webengine-scroll-step 200)
    (eaf-webengine-default-zoom 1.25)
    (eaf-webengine-show-hover-link t)
    (eaf-webengine-download-path "~/Downloads")
    (eaf-webengine-enable-plugin t)
    (eaf-webengine-enable-javascript t)
    (eaf-webengine-enable-javascript-access-clipboard t)
    ;; Web browser
    (eaf-browser-continue-where-left-off t)
    (eaf-browser-enable-adblocker t)
    (eaf-browser-ignore-history-list '("google.com/search" "file://"))
    (eaf-browser-translate-language "en")
    (eaf-browser-blank-page-url "https://www.duckduckgo.com")
    (eaf-browser-chrome-history-file (concat minemacs-local-dir "eaf/browser/chrome-history"))
    (eaf-browser-default-search-engine "duckduckgo")
    (eaf-browser-continue-where-left-off t)
    (eaf-browser-aria2-auto-file-renaming t)
    ;; Video player
    (eaf-video-player-keybinding
     '(("p" . "toggle_play")
       ("q" . "close_buffer")
       ("h" . "play_backward")
       ("l" . "play_forward")
       ("j" . "decrease_volume")
       ("k" . "increase_volume")
       ("f" . "toggle_fullscreen")
       ("R" . "restart")))
    ;; Jupyter
    (eaf-jupyter-font-family (plist-get minemacs-fonts :font-family))
    (eaf-jupyter-font-size 14)
    ;; PDF viewer
    (eaf-pdf-outline-buffer-indent 2)
    :config
    ;; Try to load enabled apps, and install them if they aren't installed
    (let (not-installed-apps)
      (dolist (app eaf-apps-to-install)
        (unless (require (intern (format "eaf-%s" app)) nil t)
          (push app not-installed-apps)))
      (when not-installed-apps
        (warn "Some apps are not installed: %s" not-installed-apps)))

    (defun +browse-url-eaf (url &rest args)
      "Open URL in EAF Browser."
      (interactive (browse-url-interactive-arg "URL: "))
      (eaf-open-browser (browse-url-encode-url url) args))))
#+end_src
*** me-eaf.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-eaf)
;;; me-eaf.el ends here
#+end_src
** me-editor.el
:properties:
:header-args: :tangle modules/me-editor.el
:end:
*** me-editor.el =HEAD=
#+begin_src emacs-lisp
;;; me-editor.el --- Editing stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-editor.el [[https://github.com/minad/tempel][tempel]]
Tempel 可以在 org-mode 中使用，通过定义不同的模板，可以根据模板快速生成代码、文档等。Tempel 的模板支持嵌套，可以根据不同的参数值生成不同的代码。
#+begin_src emacs-lisp
(use-package tempel
  :straight t
  :custom
  (tempel-trigger-prefix "<") ;; Require trigger prefix before template name when completing.
  (tempel-path (concat minemacs-root-dir "templates/tempel/*.eld"))
  :bind (("M-\"" . tempel-complete) ;; Alternative tempel-expand
         ("M-*" . tempel-insert))
  :hook ((prog-mode text-mode) . +tempel-setup-capf-h)
  :hook (prog-mode . tempel-abbrev-mode)
  :defines +tempel-setup-capf-h
  :config
  ;; Setup completion at point
  (defun +tempel-setup-capf-h ()
    ;; Add the Tempel Capf to `completion-at-point-functions'.
    ;; `tempel-expand' only triggers on exact matches. Alternatively use
    ;; `tempel-complete' if you want to see all matches, but then you
    ;; should also configure `tempel-trigger-prefix', such that Tempel
    ;; does not trigger too often when you don't expect it. NOTE: We add
    ;; `tempel-expand' *before* the main programming mode Capf, such
    ;; that it will be tried first.
    (setq-local
     completion-at-point-functions
     (if (derived-mode-p 'org-mode 'markdown-mode)
         '(tempel-complete)
       (cons #'tempel-complete completion-at-point-functions))))
  (global-tempel-abbrev-mode 1))

(use-package tempel-collection
  :straight t
  :after tempel
  :demand t)
#+end_src
*** me-editor.el [[https://github.com/rolandwalker/unicode-fonts][unicode-fonts]]
unicode-fonts 是一个 Emacs 包，它为 Emacs 中的 Unicode 字符提供了良好的显示效果。在 Emacs 中，如果一个字体不能正确地显示 Unicode 字符，这些字符将以方块或空心的框框代替。unicode-fonts 包可以解决这个问题，它会检测 Emacs 中所使用的字体是否支持 Unicode 字符，并动态地将 Unicode 字符映射到支持它们的字体上，从而让 Unicode 字符在 Emacs 中正常地显示。
#+begin_src emacs-lisp
(use-package unicode-fonts
  :straight t
  :hook (minemacs-after-startup . +unicode-fonts-setup)
  :config
  (defun +unicode-fonts-setup ()
    "Prefer the `:unicode-font-family' from `minemacs-fonts'."
    (when-let ((frame (selected-frame)))
      (when (display-multi-font-p frame)
        (with-selected-frame frame
          (when-let ((unicode-font-family (plist-get minemacs-fonts :unicode-font-family)))
            (dolist (unicode-block unicode-fonts-block-font-mapping)
              (push unicode-font-family (cadr unicode-block))))
          (unicode-fonts-setup))))))
#+end_src
*** me-editor.el [[https://github.com/mickeynp/ligature.el][ligature]]
+ ligature.el 是一个 Emacs 包，它可以在 Emacs 中启用和显示代码连字 (ligatures)。代码连字是指某些字符的特殊组合，可以将它们连接成更好的单个字符，以提高代码的可读性。例如，箭头，等于号，不等号，以及其他一些特殊符号。启用代码连字可以让代码看起来更加美观，也可以使代码更容易阅读。
+ ligature.el 支持许多字体，包括 Fira Code，Hasklig，Iosevka，JetBrains Mono，Operator Mono 和 PragmataPro。此外，它还可以与许多不同的 Emacs 模式一起使用，包括 Org mode，LaTeX mode 和 Magit mode 等。它还提供了许多自定义选项，以便根据用户的喜好进行配置，例如指定要使用的字体和要使用连字的字符列表。
#+begin_src emacs-lisp
(when (and (>= emacs-major-version 28) (+emacs-features-p 'harfbuzz 'cairo))
  (use-package ligature
    :straight t
    :after minemacs-loaded
    :hook (prog-mode . ligature-mode)
    :config
    ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))
    ;; Enable traditional ligature support in eww-mode, if the
    ;; `variable-pitch' face supports it
    (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
    ;; Enable all "Cascadia Code" ligatures in programming modes
    (ligature-set-ligatures
     'prog-mode
     '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
       "\\\\" "://"))))
#+end_src
*** TODO me-editor.el [[https://github.com/Fuco1/smartparens][smartparens]]
Smartparens 是一个 Emacs 的插件，它提供了一些智能的括号匹配和操作功能。主要功能包括：
+ 自动匹配括号：输入左括号时自动插入右括号，光标在左括号处时高亮右括号。
+ 括号包围：快速将一个词语包围在括号、引号等符号中。
+ 括号删除：删除一个括号时自动删除匹配的另一个括号，删除一对括号时也可以将中间的内容一起删除。
+ 括号替换：可以快速将一个类型的括号替换成另一个类型的括号。
+ 括号交换：可以快速交换一对括号中的内容，或者将一对括号移动到另一个位置。
#+begin_src emacs-lisp
(use-package smartparens
  :straight t
  :hook (prog-mode . smartparens-mode)
  :config
  (with-eval-after-load 'evil-mc
    ;; Make evil-mc cooperate with smartparens better
    (let ((vars (cdr (assq :default evil-mc-cursor-variables))))
      (unless (memq (car sp--mc/cursor-specific-vars) vars)
        (setcdr (assq :default evil-mc-cursor-variables)
                (append vars sp--mc/cursor-specific-vars))))))

;; Default `smartparens' configuration (for example, do not complete a single
;; quote)
(use-package smartparens-config
  :after smartparens
  :demand t)
#+end_src
*** me-editor.el [[https://github.com/magnars/expand-region.el][expand-region]]
+ expand-region.el 是一个 Emacs 的包，它允许你增加当前光标所在位置选定区域的大小。它能够自动检测当前光标所在的语法结构，如单词、句子、段落、函数、括号等，并选中其整个区域。使用它，你可以更快地选择一大段文本，而不必手动一个字符一个字符地选择。
+ expand-region.el 提供了一个命令 er/expand-region，它用于增加选定区域的大小。你可以通过按多次该命令来逐步扩大选定区域的大小，还可以通过 er/contract-region 命令来缩小选定区域的大小。
+ expand-region.el 还可以自定义其语法结构的识别方式，以适应不同的编程语言和文本格式。它还提供了许多插件和扩展，例如可以将其与多行编辑、注释等其他编辑功能结合使用。
#+begin_src emacs-lisp
;; I learn this trick from ReneFroger, need latest expand-region
;; @see https://github.com/redguardtoo/evil-matchit/issues/38
(use-package expand-region
  :straight t
  :init
  (+vmap! "v" #'er/expand-region))
#+end_src
*** me-editor.el [[https://github.com/minad/goggles][goggles]]
Goggles 使用脉冲突出显示修改后的区域 目前支持 undo、yank、kill 和 delete 命令
#+begin_src emacs-lisp
(use-package goggles
  :straight t
  :hook ((prog-mode text-mode) . goggles-mode)
  :config
  ;; Pulse for evil commands
  (goggles-define undo primitive-undo evil-undo)
  (goggles-define yank yank yank-pop evil-yank evil-yank-line)
  (goggles-define kill kill-region)
  (goggles-define delete delete-region evil-delete evil-delete-line))
#+end_src
*** me-editor.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-editor)
;;; me-editor.el ends here
#+end_src
** WAIT me-email.el
:properties:
:header-args: :tangle modules/me-email.el
:end:
*** me-email.el =HEAD=
#+begin_src emacs-lisp
;;; me-email.el --- Editing stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-email.el =mu4e=
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.mailrc\\'" . conf-space-mode))

(defconst +mu4e-load-path "/usr/share/emacs/site-lisp/mu4e/")

(defgroup minemacs-mu4e nil
  "MinEmacs mu4e tweaks."
  :group 'minemacs)

(defconst +mu4e-available-p
  (and (executable-find "mu")
       (executable-find "msmtp")
       (executable-find "mbsync")
       (file-directory-p +mu4e-load-path)))

(use-package mu4e
  :when +mu4e-available-p
  :load-path +mu4e-load-path
  :commands mu4e-compose-new mu4e--start mu4e
  :hook (mu4e-headers-mode . (lambda ()
                               (visual-line-mode -1)
                               (display-line-numbers-mode -1)))
  :init
  (+map! "om" #'mu4e)
  :custom
  (mu4e-confirm-quit t)
  (mu4e-search-results-limit 1000)
  (mu4e-index-cleanup t)
  (mu4e-attachment-dir "~/Downloads/mu4e-attachements/")
  (mu4e-update-interval (* 1 60)) ;; Every 1 min
  (mu4e-context-policy 'pick-first) ;; Start with the first context
  (mu4e-compose-context-policy 'ask) ;; Always ask which context to use when composing a new mail
  (mu4e-sent-messages-behavior 'sent) ;; Will be overwritten for Gmail accounts
  (mu4e-get-mail-command "mbsync -a") ;; Use mbsync to get mails
  (mu4e-index-update-error-warning nil) ;; Do not show warning after update
  (mu4e-hide-index-messages t) ;; Hide minibuffer messages after indexing
  (mu4e-change-filenames-when-moving t)
  (mu4e-completing-read-function #'completing-read) ;; Use `vertico' instead of `ido'
  (mu4e-main-hide-personal-addresses t) ;; Don't display a list of my own addresses!
  (mu4e-modeline-support nil) ;; `mu4e-alert' is much nicer.
  (mu4e-eldoc-support t)
  (sendmail-program (executable-find "msmtp")) ;; Use msmtp to send mails
  (send-mail-function #'smtpmail-send-it)
  (message-sendmail-f-is-evil t)
  (message-sendmail-extra-arguments '("--read-envelope-from"))
  (message-send-mail-function #'message-send-mail-with-sendmail)
  (message-sendmail-envelope-from 'obey-mail-envelope-from)
  (message-mail-user-agent 'mu4e-user-agent)
  (message-kill-buffer-on-exit t) ;; Close after sending
  (mail-envelope-from 'header)
  (mail-specify-envelope-from t)
  (mail-user-agent 'mu4e-user-agent)
  (read-mail-command 'mu4e)
  :config
  (+nvmap! :keymaps 'mu4e-view-mode-map
    "p" #'mu4e-view-save-attachments)
  (+nvmap! :keymaps '(mu4e-headers-mode-map mu4e-view-mode-map)
    "gw" #'+mu4e-open-mail-as-html
    "g RET" #'browse-url-at-point)
  (+map-local! :keymaps '(mu4e-compose-mode-map org-msg-edit-mode-map)
    "s" #'message-send-and-exit
    "d" #'message-kill-buffer
    "S" #'message-dont-send)

  (defun +mu4e-open-mail-as-html ()
    "Open the HTML mail in EAF Browser."
    (interactive)
    (if-let ((msg (mu4e-message-at-point t))
             ;; Bind browse-url-browser-function locally, so it works
             ;; even if EAF Browser is not set as a default browser.
             (browse-url-browser-function
              (cond
               ((featurep 'me-eaf) #'eaf-open-browser)
               (t #'browse-url-xdg-open))))
        (mu4e-action-view-in-browser msg)
      (message "No message at point.")))

  ;; Force running update and index in background
  (advice-add
   'mu4e-update-mail-and-index :around
   (defun +mu4e--update-mail-quitely-a (origfn run-in-background)
     (+info! "Getting new emails")
     (apply origfn '(t)))))

;; Reply to iCalendar meeting requests
(use-package mu4e-icalendar
  :when +mu4e-available-p
  :load-path +mu4e-load-path
  :after mu4e
  :demand t
  :config
  (mu4e-icalendar-setup))

(use-package me-mu4e-ui
  :after mu4e
  :demand t
  :config
  ;; Setup the UI (mostly inspired by Doom Emacs, with a lot of improvements)
  (+mu4e-ui-setup))

(use-package me-mu4e-gmail
  :after mu4e
  :demand t
  :config
  ;; Setup Gmail specific hacks (adapted from Doom Emacs, with a lot of
  ;; improvements)
  (+mu4e-gmail-setup))

(use-package me-mu4e-extras
  :after mu4e
  :demand t
  :config
  ;; Enable MinEmacs's mu4e extra features, including:
  ;; - Auto BCC the `+mu4e-auto-bcc-address';
  ;; - Prompt for the "From" address from the account aliases `+mu4e-account-aliases';
  ;; - Check for the subject before sending;
  ;; - Add an action to save the mail as PDF;
  ;; - Add an action to save all the attachements;
  ;; - Add an action to save the message at point.
  (+mu4e-extras-setup)
  ;; Redefine bookmarks queries to ignore spams
  (+mu4e-extras-ignore-spams-in-bookmarks-setup))

(use-package org-msg
  :straight t
  :after mu4e
  :demand t
  :custom
  (org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil tex:dvipng")
  (org-msg-startup "hidestars indent inlineimages")
  (org-msg-greeting-name-limit 3)
  (org-msg-convert-citation t)
  (org-msg-default-alternatives '((new . (utf-8 html))
                                  (reply-to-text . (utf-8 html))
                                  (reply-to-html . (utf-8 html))))
  (org-msg-attached-file-reference
   (rx (or (seq "attach" (or "ment" "ed"))
           (seq "enclosed")
           (seq "attach" (any ?é ?e) (? "e") (? "s"))
           (seq "ci" (or " " "-") "joint" (? "e")) ;; ci-joint
           (seq (or (seq "pi" (any ?è ?e) "ce") "fichier" "document") (? "s") (+ (or " " eol)) "joint" (? "e") (? "s")) ;; pièce jointe
           (seq (or (seq space "p" (zero-or-one (any ?- ?.)) "j" (any space ?: ?\; ?, ?.))))))) ;; p.j
  :config
  (+nvmap! :keymaps 'org-msg-edit-mode-map
    "TAB" #'org-msg-tab
    "gg"  #'org-msg-goto-body)
  (+map-local! :keymaps 'org-msg-edit-mode-map
    "a"  '(nil :wk "attach")
    "aa" #'org-msg-attach-attach
    "ad" #'org-msg-attach-delete
    "p"  #'org-msg-preview)
  (org-msg-mode 1))

(use-package mu4e-alert
  :straight t
  :after mu4e
  :demand t
  :custom
  (mu4e-alert-icon "/usr/share/icons/Papirus/64x64/apps/mail-client.svg")
  (mu4e-alert-set-window-urgency nil)
  (mu4e-alert-group-by :to)
  (mu4e-alert-email-notification-types '(subjects))
  :init
  (defcustom +mu4e-alert-bell-command
    (when (or os/linux os/bsd)
      '("paplay" . "/usr/share/sounds/freedesktop/stereo/message.oga"))
    "A cons list of the command and arguments to play the notification bell."
    :group 'minemacs-mu4e
    :type '(cons string string))
  :config
  ;; Enable on mu4e notifications in doom-modeline
  (setq doom-modeline-mu4e t)

  ;; Ignore spams!
  (setq mu4e-alert-interesting-mail-query
        (+mu4e-extras-ignore-spams-query mu4e-alert-interesting-mail-query))

  (mu4e-alert-enable-mode-line-display)
  (mu4e-alert-enable-notifications)
  (mu4e-alert-set-default-style 'libnotify)

  (defun +mu4e-name-or-email (msg)
    (let* ((from (car (plist-get msg :from)))
           (name (plist-get from :name)))
      (if (or (null name) (eq name ""))
          (plist-get from :email)
        name)))

  (defun +mu4e-alert-grouped-mail-notif-formatter (mail-group _all-mails)
    (when +mu4e-alert-bell-command
      (start-process "mu4e-alert-bell" nil (car +mu4e-alert-bell-command) (cdr +mu4e-alert-bell-command)))
    (let ((mail-count (length mail-group)))
      (list
       :title (format "You have %d unread email%s"
                      mail-count (if (> mail-count 1) "s" ""))
       :body (concat
              "• "
              (string-join
               (mapcar
                (lambda (msg)
                  (format "<b>%s</b>: %s"
                          (+mu4e-name-or-email msg)
                          (plist-get msg :subject)))
                mail-group)
               "\n• ")))))

  (setq mu4e-alert-grouped-mail-notification-formatter
        #'+mu4e-alert-grouped-mail-notif-formatter))
#+end_src
*** me-email.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-email)
;;; me-email.el ends here
#+end_src
** WAIT me-embedded.el
:properties:
:header-args: :tangle modules/me-embedded.el
:end:
嵌入式系统相关的包
*** me-embedded.el =HEAD=
#+begin_src emacs-lisp
;;; me-embedded.el --- Embedded systems stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-embedded.el =embedded system=
#+begin_src emacs-lisp
(use-package embed
  :straight (:host github :repo "xal-0/embed-el")
  :init
  (+map! :infix "o"
    "b" '(nil :wk "embed")
    "bo" #'embed-openocd-start
    "bO" #'embed-openocd-stop
    "bg" #'embed-openocd-gdb
    "bf" #'embed-openocd-flash))

(use-package arduino-mode
  :straight (:host github :repo "bookest/arduino-mode")
  :hook (arduino-mode . display-line-numbers-mode)
  :hook (arduino-mode . hs-minor-mode))

(use-package bitbake-modes
  :straight (:host bitbucket :repo "olanilsson/bitbake-modes"))

(use-package vhdl-mode
  :straight (:type built-in)
  :config
  ;; Setup vhdl_ls from rust_hdl (AUR: rust_hdl-git)
  (+eglot-register 'vhdl-mode "vhdl_ls"))

(use-package verilog-mode
  :straight (:type built-in)
  :config
  ;; Setup Verilog/SystemVerilog LSP servers
  (+eglot-register 'verilog-mode "svls" "verible-verilog-ls" "svlangserver"))

(use-package mips-mode
  :straight t
  :mode "\\.mips\\'")

(use-package riscv-mode
  :straight t
  :mode "\\.riscv\\'")

(use-package x86-lookup
  :straight t
  :custom
  (x86-lookup-browse-pdf-function 'x86-lookup-browse-pdf-pdf-tools)
  ;; Get manual from intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html
  (x86-lookup-pdf (concat minemacs-local-dir "x86-lookup/325383-sdm-vol-2abcd.pdf")))
#+end_src
*** me-embedded.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-embedded)
;;; me-embedded.el ends here
#+end_src
** me-extra.el
:properties:
:header-args: :tangle modules/me-extra.el
:end:
*** me-extra.el =HEAD=
#+begin_src emacs-lisp
;;; me-extra.el --- Some extra functionalities -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-extra.el =better-jumper=
#+begin_src emacs-lisp
(use-package better-jumper
  :straight t
  :hook (minemacs-after-startup . better-jumper-mode)
  :config
  ;; Map extra mouse buttons to jump forward/backward
  (global-set-key (kbd "C-o") #'better-jumper-jump-backward)
  (global-set-key (kbd "C-i") #'better-jumper-jump-forward))
#+end_src
*** me-extra.el =crux=
#+begin_src emacs-lisp
(use-package crux
  :straight t
  :init
  (+map!
    "fo" #'crux-open-with
    "fU" #'crux-sudo-edit
    "fD" #'crux-delete-file-and-buffer
    "fC" #'crux-copy-file-preserve-attributes
    "id" #'crux-insert-date
    "bo" #'crux-kill-other-buffers))
#+end_src
*** me-extra.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-extra)
;;; me-extra.el ends here
#+end_src
** me-files.el
:properties:
:header-args: :tangle modules/me-files.el
:end:
*** me-files.el =HEAD=
#+begin_src emacs-lisp
;;; me-files.el --- File management -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-files.el =dirvish=
dirvish 是 Emacs 中一个目录管理工具，它提供了类似于 Vim 中 NERDTree 的功能，让用户可以在 Emacs 中浏览文件系统，打开文件、目录或新建文件。通过使用 dirvish，用户可以在不离开 Emacs 的情况下管理文件系统，提高工作效率。
#+begin_src emacs-lisp
(use-package dirvish
  :straight t
  :hook (minemacs-after-startup . dirvish-override-dired-mode)
  :custom
  (dirvish-attributes '(subtree-state all-the-icons file-size vc-state git-msg))
  (dirvish-cache-dir (+directory-ensure minemacs-cache-dir "dirvish/"))
  (dirvish-mode-line-format '(:left (sort file-time symlink) :right (omit yank index)))
  (dirvish-side-width 30)
  (dirvish-fd-default-dir "~/")
  (dirvish-use-header-line t) ; 'global make header line span all panes
  (dirvish-use-mode-line t)
  :init
  (+map!
    ;; Open
    "o-" '(dirvish :wk "Dirvish")
    "oq" '(dirvish-quick-access :wk "Dirvish quick access")
    ;; Search
    "sd" '(dirvish-fd :wk "Dirvish fd"))
  :config
  (+nvmap! :keymaps 'dirvish-mode-map
    "q" #'dirvish-quit
    "s" #'dirvish-subtree-toggle
    "h" #'dired-up-directory
    "l" #'dired-find-file
    "y" #'dirvish-yank-menu))
#+end_src
*** me-files.el =vlf-setup=
very large file大文件游览
#+begin_src emacs-lisp
(use-package vlf-setup
  :straight vlf
  :after minemacs-loaded
  :demand t)
#+end_src
*** me-files.el =treemacs=
文件游览导航
#+begin_src emacs-lisp
(use-package treemacs
  :straight t
  :init
  (+map!
    "op" '(treemacs :wk "Side panel"))
  :custom
  (treemacs-persist-file (concat minemacs-local-dir "treemacs/persist.el"))
  (treemacs-last-error-persist-file (concat minemacs-local-dir "treemacs/last-error-persist.el"))
  (treemacs-width 30))

(use-package treemacs-evil
  :straight t
  :after treemacs evil
  :demand t)

(use-package treemacs-all-the-icons
  :straight t
  :after treemacs all-the-icons
  :demand t
  :config
  (treemacs-load-theme "all-the-icons"))
#+end_src
*** me-files.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-files)
;;; me-files.el ends here
#+end_src
** me-fun.el
:properties:
:header-args: :tangle modules/me-fun.el
:end:
*** me-fun.el =HEAD=
#+begin_src emacs-lisp
;;; me-fun.el --- Some funny stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-fun.el xkcd
xkcd漫画阅读
#+begin_src emacs-lisp
(use-package xkcd
  :straight t
  :init
  (+map! "ox" #'xkcd)
  :custom
  (xkcd-cache-dir (+directory-ensure minemacs-local-dir "xkcd/"))
  (xkcd-cache-latest (concat minemacs-local-dir "xkcd/latest"))
  :config
  (+nvmap! :keymaps 'xkcd-mode-map
    "j" #'xkcd-next
    "k" #'xkcd-prev
    "l" #'xkcd-get-latest
    "L" #'xkcd-get-latest-cached
    "<right>" #'xkcd-next
    "<left>" #'xkcd-prev
    "o" #'xkcd-open-browser
    "O" #'xkcd-open-explanation-browser
    "r" #'xkcd-rand
    "y" #'xkcd-copy-link)
  (+ignore-root xkcd-cache-dir))
#+end_src
*** me-fun.el speed-type

#+begin_src emacs-lisp
(use-package speed-type
  :straight t)
#+end_src
*** me-fun.el [[https://github.com/zkry/asm-blox][asm-blow]]
asm-blox是一款受WebAssembly Text格式（WAT）启发的编程游戏。在这个游戏中，你需要按照给定的规则，使用汇编语言编写程序，将一些小方块（称为“blox”）移动到指定的位置。游戏提供了多个级别，每个级别会逐步增加难度。除了编写程序之外，你还可以尝试修改游戏中的其他内容（例如方块的数量、大小、颜色等），来探索它们对游戏规则的影响。此外，asm-blox还提供了一个在线编辑器，使得编写和测试代码变得非常方便。
#+begin_src emacs-lisp
(use-package asm-blox
  :straight t)
#+end_src
*** me-fun.el =TAIL=
#+begin_src emacs-lisp
(provide 'me-fun)
;;; me-fun.el ends here
#+end_src
** WAIT me-guns.el
:properties:
:header-args: :tangle modules/me-guns.el
:end:
*** me-guns.el =HEAD=
#+begin_src emacs-lisp
;;; me-gnus.el --- Email stuff using Gnus -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-guns.el email use gnus
#+begin_src emacs-lisp
;; See: emacswiki.org/emacs/GnusTutorial
;; github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org
(setq gnus-init-file (concat minemacs-config-dir "gnus.el"))
#+end_src
*** me-guns.el =TAIL=
#+begin_src emacs-lisp
(provide me-gnus)
;;; me-guns.el ends here
#+end_src
** STRT me-latex.el
:properties:
:header-args: :tangle modules/me-latex.el
:end:
LaTeX是一种文本排版系统，通常用于制作科技论文、报告、学术出版物、书籍、幻灯片等等。
*** me-latex.el =HEAD=
#+begin_src emacs-lisp
;;; me-latex.el --- LaTeX related stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-latex.el mark
#+begin_src emacs-lisp
;; Adapted from Doom Emacs
(use-package tex
  :straight auctex
  :hook ((tex-mode TeX-mode latex-mode LaTeX-mode) . TeX-source-correlate-mode)
  :hook ((tex-mode TeX-mode latex-mode LaTeX-mode) . hs-minor-mode)
  :custom
  (TeX-parse-self t) ; parse on load
  (TeX-auto-save t)  ; parse on save
  (TeX-auto-local ".auctex-auto") ; use hidden directories for AUCTeX files.
  (TeX-style-local ".auctex-style")
  (TeX-source-correlate-method 'synctex)
  (TeX-source-correlate-start-server nil) ; don't start the Emacs server when correlating sources.
  (TeX-electric-sub-and-superscript t) ; automatically insert braces after sub/superscript in `LaTeX-math-mode'.
  (TeX-save-query nil) ; just save, don't ask before each compilation.
  (TeX-engine 'xetex) ; use XeLaTeX by default
  (TeX-PDF-mode t) ; export to PDF by default
  :init
  (+map-local! :keymaps '(tex-mode-map TeX-mode-map latex-mode-map LaTeX-mode-map)
    "c" #'TeX-command-run-all
    "m" #'TeX-command-master
    "e" #'TeX-engine-set
    "v" #'TeX-view)
  :config
  (when (functionp 'pdf-tools-install)
    (add-to-list 'TeX-view-program-selection '(output-pdf "PDF Tools"))))

(use-package latex
  :straight auctex
  :config
  ;; Add the TOC entry to the sectioning hooks.
  (setq LaTeX-fill-break-at-separators nil
        LaTeX-item-indent 0))

;; Adapted from Doom Emacs
(use-package auctex-latexmk
  :straight t
  :after latex
  :demand t
  :hook (LaTeX-mode . +tex--set-latexmk-as-default-cmd-h)
  :defines +tex--set-latexmk-as-default-cmd-h
  :custom
  (auctex-latexmk-inherit-TeX-PDF-mode t)
  :config
  (setq-default
   TeX-command-list
   (cons
    '("LatexMk-2" "latexmk -shell-escape %(-PDF)%S%(mode) %(file-line-error) %(extraopts) %t" TeX-run-latexmk nil
      (plain-tex-mode latex-mode doctex-mode) :help "Run LatexMk with shell-escape")
    TeX-command-list))

  (defun +tex--set-latexmk-as-default-cmd-h ()
    (setq TeX-command-default "LatexMk-2"))

  ;; Add LatexMk as a TeX target.
  (auctex-latexmk-setup))

(use-package bibtex
  :straight (:type built-in)
  :hook (bibtex-mode . display-line-numbers-mode)
  :custom
  (bibtex-dialect 'biblatex)
  (bibtex-align-at-equal-sign t)
  (bibtex-text-indentation 20)
  :config
  (+map-local! :keymaps 'bibtex-mode-map
    "l" #'bibtex-fill-entry
    "r" #'bibtex-reformat))

;; Inspired by Doom Emacs
(use-package reftex
  :straight (:type built-in)
  :hook (LaTeX-mode . turn-on-reftex)
  :hook (reftex-toc-mode . reftex-toc-rescan)
  :custom
  ;; Get RefTeX working with BibLaTeX. See: tex.stackexchange.com/a/31992/43165
  (reftex-cite-format
   '((?a . "\\autocite[]{%l}")
     (?b . "\\blockcquote[]{%l}{}")
     (?c . "\\cite[]{%l}")
     (?f . "\\footcite[]{%l}")
     (?n . "\\nocite{%l}")
     (?p . "\\parencite[]{%l}")
     (?s . "\\smartcite[]{%l}")
     (?t . "\\textcite[]{%l}"))
   ;; This is needed when `reftex-cite-format' is set. See:
   ;; superuser.com/a/1386206
   (LaTeX-reftex-cite-format-auto-activate nil)
   (reftex-plug-into-AUCTeX t)
   (reftex-toc-split-windows-fraction 0.3))
  :config
  (+map-local! :keymaps 'reftex-mode-map
    ";" 'reftex-toc)
  (+nvmap! :keymaps 'reflex-toc-mode-map
    "j"   #'next-line
    "k"   #'previous-line
    "q"   #'kill-buffer-and-window
    "ESC" #'kill-buffer-and-window)
  (with-eval-after-load 'evil
    (add-hook 'reftex-mode-hook #'evil-normalize-keymaps)))

(use-package me-latex-fonts
  :after latex
  :demand t)
#+end_src
*** me-latex.el =TAIL=
#+begin_src emacs-lisp
(provide me-latex)
;;; me-latex.el ends here
#+end_src
** me-lifestyle.el
:properties:
:header-args: :tangle modules/me-lifestyle.el
:end:
*** me-lifestyle.el =HEAD=
#+begin_src emacs-lisp
;;; me-lifestyle.el --- *Highly* opinionated lifestyles apps -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-lifestyle.el awqat
awqat它提供了显示伊斯兰教离线礼拜时间表的功能.
#+begin_src emacs-lisp
(use-package awqat
  :straight (:host github :repo "zkry/awqat")
  :commands awqat-times-for-day
  :custom
  ;; In your "config.el", you need to set `calendar-latitude' and
  ;; `calendar-longitude' (both defined in `solar'). Alongside with the
  ;; calculation method, either by setting the right angles for Fajr and Isha,
  ;; or by using one of the predefined presets (see `awqat' for more
  ;; information).
  (awqat-mode-line-format " 🕌 ${prayer} (${hours}h${minutes}m) ")
  (awqat-update-interval 30.0))
#+end_src
*** me-lifestyle.el =TAIL=
#+begin_src emacs-lisp
(provide me-lifestyle)
;;; me-lifestyle.el ends here
#+end_src
** WAIT me-lisp.el
:properties:
:header-args: :tangle modules/me-lisp.el
:end:
*** me-lisp.el =HEAD=
#+begin_src emacs-lisp
;;; lisp.el --- Lisp, Scheme, Elisp -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-lisp.el parinfer-rust-mode
+ 在系统架构为 x86_64 时使用 Rust 实现的 parinfer-rust-mode 插件。 parinfer-rust-mode 是一个可以自动匹配括号和引号的插件，可以方便 Lisp 方言编程的使用。
+ 这段代码还设置了 parinfer-rust 的自动下载和存储路径，并将 parinfer-rust-mode 添加到了 emacs-lisp-mode、clojure-mode、scheme-mode、lisp-mode、racket-mode 和 hy-mode 这些模式的 hook 中，以便在这些模式下启用 parinfer-rust-mode。
#+begin_src emacs-lisp
(when (+emacs-features-p 'modules)
  (use-package parinfer-rust-mode
    :straight t
    :when (eq sys/arch 'x86_64)
    :custom
    (parinfer-rust-library-directory (concat minemacs-local-dir "parinfer-rust/"))
    (parinfer-rust-auto-download (eq sys/arch 'x86_64))
    :hook ((emacs-lisp-mode
            clojure-mode
            scheme-mode
            lisp-mode
            racket-mode
            hy-mode)
           . parinfer-rust-mode)))
#+end_src
*** me-lisp.el mark
#+begin_src emacs-lisp
;; Common Lisp
(use-package sly
  :straight t
  :custom
  (sly-mrepl-history-file-name (+directory-ensure minemacs-local-dir "sly/mrepl-history.el"))
  (sly-net-coding-system 'utf-8-unix)
  :config
  (dolist (impl '("lisp"   ; Default Lisp implementation on the system
                  "clisp"  ; GNU CLISP
                  "abcl"   ; Armed Bear Common Lisp
                  "ecl"    ; Embeddable Common-Lisp
                  "gcl"    ; GNU Common Lisp
                  "ccl"    ; Clozure Common Lisp
                  "cmucl"  ; CMU Common Lisp
                  "clasp"  ; Common Lisp on LLVM
                  "sbcl")) ; Steel Bank Common Lisp
    (when (executable-find impl)
      (add-to-list
       'sly-lisp-implementations
       `(,(intern impl) (,impl) :coding-system utf-8-unix))))
  (setq inferior-lisp-program (caar (cdar sly-lisp-implementations))
        sly-default-lisp (caar sly-lisp-implementations))

  (+map-local! :keymaps '(lisp-mode-map)
    "s"  #'sly
    "c"  '(nil :wk "compile")
    "cc" #'sly-compile-file
    "cC" #'sly-compile-and-load-file
    "cd" #'sly-compile-defun
    "cr" #'sly-compile-region
    "g"  '(nil :wk "goto/find")
    "gn" #'sly-goto-first-note
    "gL" #'sly-load-file
    "gn" #'sly-next-note
    "gN" #'sly-previous-note
    "gs" #'sly-stickers-next-sticker
    "gS" #'sly-stickers-prev-sticker
    "gN" #'sly-previous-note
    "gd" #'sly-edit-definition
    "gD" #'sly-edit-definition-other-window
    "gb" #'sly-pop-find-definition-stack
    "h"  '(nil :wk "help/info")
    "hs" #'sly-describe-symbol
    "hf" #'sly-describe-function
    "hc" #'sly-who-calls
    "hC" #'sly-calls-who
    "hs" #'sly-who-calls
    "hC" #'sly-calls-who
    "hd" #'sly-disassemble-symbol
    "hD" #'sly-disassemble-definition
    "r"  '(nil :wk "repl")
    "rr" #'sly-restart-inferior-lisp
    "rc" #'sly-mrepl-clear-repl
    "rs" #'sly-mrepl-sync
    "rn" #'sly-mrepl-new
    "rq" #'sly-quit-lisp))

;; Scheme
(use-package racket-mode
  :straight t)

(use-package geiser
  :straight t
  :custom
  (geiser-default-implementation 'guile))

(use-package geiser-chez
  :straight t)

(use-package geiser-chibi
  :straight t)

(use-package geiser-chicken
  :straight t)

(use-package geiser-gambit
  :straight t)

(use-package geiser-gauche
  :straight t)

(use-package geiser-guile
  :straight t)

(use-package geiser-kawa
  :straight t)

(use-package geiser-mit
  :straight t)

(use-package geiser-racket
  :straight t)

(use-package geiser-stklos
  :straight t)

;; Clojure
(use-package clojure-mode
  :straight t)

(use-package cider
  :straight t)

;; Macro expansion
(use-package macrostep
  :straight (macrostep :fork (:host github :repo "abougouffa/macrostep" :branch "fix_keymap"))
  :init
  (+map-local! :keymaps '(emacs-lisp-mode-map lisp-mode-map)
    "m" '(macrostep-expand :wk "Expand macro")))

(use-package macrostep-geiser
  :straight t
  :after geiser
  :hook ((geiser-mode geiser-repl-mode) . macrostep-geiser-setup)
  :init
  (+map-local! :keymaps '(geiser-mode-map geiser-repl-mode-map)
    "m" '(macrostep-expand :wk "Expand macro")
    "M" #'macrostep-geiser-expand-all))

(use-package sly-macrostep
  :straight t
  :after sly
  :demand t
  :init
  (+map-local! :keymaps '(sly-mode-map sly-editing-mode-map sly-mrepl-mode-map)
    "m" '(macrostep-expand :wk "Expand macro")))

;; Emacs Lisp
(use-package elisp-mode
  :straight (:type built-in)
  :hook (emacs-lisp-mode . (lambda () (setq-local tab-width 8))) ;; to view built-in packages correctly
  :after minemacs-loaded ; prevent elisp-mode from being loaded too early
  :init
  (+map-local! :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map ielm-map lisp-mode-map racket-mode-map scheme-mode-map)
    "p" #'check-parens)
  :config
  (+map-local! :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
    "d"   '(nil :wk "edebug")
    "df"  'edebug-defun
    "dF"  'edebug-all-forms
    "dd"  'edebug-all-defs
    "dr"  'edebug-remove-instrumentation
    "do"  'edebug-on-entry
    "dO"  'edebug-cancel-on-entry
    "db"  '(nil :wk "breakpoints")
    "dbb" 'edebug-set-breakpoint
    "dbr" 'edebug-unset-breakpoint
    "dbn" 'edebug-next-breakpoint
    "e"   '(nil :wk "eval")
    "eb"  'eval-buffer
    "ed"  'eval-defun
    "ee"  'eval-last-sexp
    "er"  'eval-region
    "eR"  'elisp-eval-region-or-buffer
    "el"  'load-library
    "g"   '(nil :wk "goto/find")
    "gf"  'find-function-at-point
    "gR"  'find-function
    "gv"  'find-variable-at-point
    "gV"  'find-variable
    "gL"  'find-library
    "c"   '(nil :wk "compile")
    "cc"  #'elisp-byte-compile-buffer
    "cf"  #'elisp-byte-compile-file
    "cn"  #'emacs-lisp-native-compile-and-load
    "cb"  #'emacs-lisp-byte-compile-and-load)
  (+map-local! :keymaps '(edebug-mode-map)
    "e"   '(nil :wk "eval")
    "ee"  'edebug-eval-last-sexp
    "eE"  'edebug-eval-expression
    "et"  'edebug-eval-top-level-form))

(use-package me-elisp-extras
  :after elisp-mode minemacs-loaded
  :demand t
  :config
  (+elisp-indent-setup)
  (+elisp-highlighting-setup))

(use-package elisp-demos
  :straight t
  :after elisp-mode minemacs-loaded
  :demand t
  :init
  (+map! :infix "he"
    "d" #'elisp-demos-find-demo
    "D" #'elisp-demos-add-demo)
  (advice-add #'describe-function-1 :after #'elisp-demos-advice-describe-function-1)
  (advice-add #'helpful-update :after #'elisp-demos-advice-helpful-update))

(use-package helpful
  :straight t
  :init
  (+map! :keymaps 'emacs-lisp-mode-map
    :infix "h"
    "p" #'helpful-at-point
    "o" #'helpful-symbol
    "c" #'helpful-command
    "F" #'helpful-function
    "f" #'helpful-callable))

(use-package info-colors
  :straight t
  :hook (Info-selection . info-colors-fontify-node))

(use-package eros
  :straight t
  :after elisp-mode minemacs-loaded
  :demand t
  :custom
  (eros-eval-result-prefix "⟹ ")
  :config
  (eros-mode 1))
#+end_src
*** me-lisp.el =TAIL=
#+begin_src emacs-lisp
(provide me-lisp)
;;; me-lisp.el ends here
#+end_src
** me-lsp.el
:properties:
:header-args: :tangle modules/me-lsp.el
:end:
*** me-lsp.el =HEAD=
#+begin_src emacs-lisp
;;; me-lsp.el --- Debugging and programming using lsp-mode and dap-mode -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** WAIT me-lsp.el
#+begin_src emacs-lisp
(use-package lsp-mode
  :straight t
  :preface
  (setq lsp-use-plists t)
  :commands +lsp-auto-enable
  :custom
  (lsp-session-file (concat minemacs-local-dir "lsp/session.el"))
  (lsp-server-install-dir (concat minemacs-local-dir "lsp/servers/"))
  (lsp-keep-workspace-alive nil)
  (lsp-log-io nil)
  (lsp-idle-delay 1.0)
  (lsp-log-max (when minemacs-debug message-log-max))
  ;; Less intrusive UI
  (lsp-eldoc-render-all nil) ; clangd docs looks ugly on eldoc-box!
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-lens-enable nil)
  ;; Maybe set to nil and enable modes manually (`lsp-completion-mode',
  ;; `lsp-modeline-diagnostics-mode', ...)
  (lsp-auto-configure t)
  ;; Those stuff should be managed by Emacs's builtins (whitespace-cleanup, treesit, ...)
  (lsp-semantic-tokens-enable t) ; when t, hides unreachable ifdefs!
  (lsp-enable-on-type-formatting nil)
  (lsp-enable-text-document-color nil)
  (lsp-trim-trailing-whitespace nil)
  (lsp-insert-final-newline nil)
  (lsp-trim-final-newlines nil)
  :init
  (+map!
    :infix "c"
    "l"  '(nil :wk "lsp session")
    "ll" #'lsp
    "lA" #'+lsp-auto-enable)
  (defcustom +lsp-auto-enable-modes
    '(c++-mode c++-ts-mode c-mode c-ts-mode
      python-mode python-ts-mode
      rust-mode rust-ts-mode cmake-mode
      js-mode js-ts-mode typescript-mode typescript-ts-mode
      json-mode json-ts-mode js-json-mode)
    "Modes for which LSP-mode can be automatically enabled by `+lsp-auto-enable'."
    :group 'minemacs-prog
    :type '(repeat symbol))
  :config
  (defun +lsp-auto-enable ()
    "Auto-enable LSP-mode in configured modes in `+lsp-auto-enable-modes'."
    (interactive)
    (dolist (mode +lsp-auto-enable-modes)
      (let ((hook (intern (format "%s-hook" mode))))
        (add-hook hook #'lsp-deferred)
        (remove-hook hook #'eglot-ensure))))

  (+map! :keymaps 'lsp-mode-map
    :infix "c"
    "fF" #'lsp-format-buffer
    "d"  '(lsp-find-declaration :wk "Find declaration")
    "D"  '(lsp-find-definition :wk "Find definition")
    "i"  '(lsp-find-implementation :wk "Find implementation")
    "t"  '(lsp-find-type-definition :wk "Find type definition")
    "a"  '(lsp-execute-code-action :wk "Code actions")
    "r"  '(nil :wk "refactor")
    "rr" '(lsp-rename :wk "Rename")
    "lq" '(lsp-workspace-shutdown :wk "Shutdown")
    "lr" '(lsp-workspace-restart :wk "Restart")))

(use-package ccls
  :straight t
  :custom
  ;; Customization of CCLS, see:
  ;; github.com/MaskRay/ccls/wiki/Customization#initialization-options
  ;; github.com/MaskRay/ccls/blob/master/src/config.hh
  (ccls-initialization-options
   '(:index (:comments 2
             :trackDependency 1
             :threads 4)
     :completion (:detailedLabel t
                  :caseSensitivity 1
                  :dropOldRequests t
                  :duplicateOptional t
                  :filterAndSort t
                  :maxNum 100
                  :placeholder t ; :json-false
                  :include (:maxPathSize 30
                            :blacklist []
                            :whitelist []
                            :suffixWhitelist [".h" ".hh" ".hxx" ".hpp" ".inc"]))
     :diagnostics (:onChange 1000 ; 1s
                   :onOpen 0
                   :onSave 0
                   :spellChecking t
                   :blacklist []
                   :whilist []
                   :caseSensitivity 1)
     :clang (:extraArgs ["--clang-tidy"]
             :excludeArgs []))))

(use-package lsp-pyright
  :straight t
  :after lsp-mode
  :demand t)

(use-package consult-lsp
  :straight t
  :after consult lsp-mode
  :init
  (+map! :keymaps 'lsp-mode-map
    "cs" '(consult-lsp-file-symbols :wk "Symbols")))

(use-package dap-mode
  :straight t
  :init
  (+map-local!
    :keymaps '(c-mode-map c++-mode-map python-mode-map
               rust-mode-map sh-mode-map bash-ts-mode-map
               js-mode-map js-ts-mode-map ruby-mode-map
               perl-mode-map)
    "d" '(nil :wk "dap")
    "dd" #'dap-debug
    "dt" #'dap-debug-edit-template
    "dh" #'dap-hydra/body)
  :hook (dap-stopped . (lambda (arg) (call-interactively #'dap-hydra)))
  :custom
  (dap-utils-extension-path (concat minemacs-local-dir "dap/extension/"))
  (dap-breakpoints-file (concat minemacs-local-dir "dap/breakpoints.el"))
  (dap-auto-configure-features '(locals breakpoints controls tooltip))
  (dap-auto-show-output nil))

(use-package dap-gdb-lldb
  :after dap-mode
  :demand t
  :custom
  (dap-gdb-lldb-extension-version
   (+github-latest-release "WebFreak001" "code-debug" "0.26.1")))

(use-package dap-cpptools
  :after dap-mode
  :demand t
  :custom
  (dap-cpptools-extension-version
   (+github-latest-release "microsoft" "vscode-cpptools" "1.14.4")))

(use-package dap-codelldb
  :after dap-mode
  :demand t
  :custom
  (dap-codelldb-extension-version
   (+github-latest-release "vadimcn" "codelldb" "1.9.0")))

(use-package dap-python
  :after dap-mode
  :demand t)

(use-package dap-mouse
  :after dap-mode
  :demand t)
#+end_src
*** me-lsp.el =TAIL=
#+begin_src emacs-lisp
(provide me-lsp)
;;; me-lsp.el ends here
#+end_src
** me-math.el
:properties:
:header-args: :tangle modules/me-math.el
:end:
*** me-math.el =HEAD=
#+begin_src emacs-lisp
;;; me-math.el --- Mathematics stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-math.el maxima
+ Maxima是一个计算机代数系统,可以用于符号计算 数值计算 绘图和数据可视化等各种数学应用,它是一个免费的开源软件
+ iMaxima是Maxima的一个前端界面，它基于Emacs并提供了图形界面，方便用户进行符号计算
#+begin_src emacs-lisp
(defconst +maxima-path-p "/usr/share/emacs/site-lisp/maxima/")
(defconst +maxima-available-p (and (executable-find "maxima")
                                   (file-directory-p +maxima-path-p)))
(use-package maxima
  :load-path +maxima-path-p
  :when +maxima-available-p
  :mode ("\\.ma[cx]\\'" . maxima-mode)
  :interpreter ("maxima" . maxima-mode)
  :commands inferior-maxima-mode
  :custom
  (maxima-display-maxima-buffer nil))

(use-package imaxima
  :load-path +maxima-path-p
  :when +maxima-available-p
  :commands imaxima imath-mode
  :hook (imaxima-startup . maxima-inferior-mode) ; To get syntax highlighting
  :custom
  (imaxima-use-maxima-mode-flag nil))
#+end_src
*** WAIT me-math.el mark
#+begin_src emacs-lisp
(use-package math-preview ; Needed by ein to render equations
  :straight t)

(use-package ein
  :straight t
  :mode ("\\.ipynb\\'" . ein:ipynb-mode)
  :custom
  (ein:output-area-inlined-images t)
  :init
  (+map! :infix "o"
    "j" '(nil :wk "ein")
    "jr" #'ein:run
    "jl" #'ein:login
    "jf" #'ein:file-open
    "jn" #'ein:notebook-open)
  :config
  (+map-local! :keymaps 'ein:ipynb-mode-map
    "o" #'ein:process-find-file-callback
    "O" #'ein:process-open-notebook
    "r" #'ein:gat-run-remote
    "l" #'ein:gat-run-local)

  (setq-default ein:markdown-enable-math t)

  (with-eval-after-load 'org
    (org-babel-do-load-languages 'org-babel-load-languages (append org-babel-load-languages '((ein . t))))
    (setq org-src-lang-modes (append org-src-lang-modes '(("ein-python" . python) ("ein-r" . r) ("ein-julia" . julia))))))

(use-package julia-mode
  :straight t)

(use-package ess
  :straight t)

(use-package ess-view
  :straight t)

(use-package ess-R-data-view
  :straight t)

(use-package poly-R
  :straight t)

(use-package octave
  :straight (:type built-in)
  :mode ("\\.m\\'" . octave-mode)
  :config
  (defun +octave-eval-last-sexp ()
    "Evaluate Octave sexp before point and print value into current buffer."
    (interactive)
    (inferior-octave t)
    (let ((print-escape-newlines nil)
          (opoint (point)))
      (prin1
       (save-excursion
         (forward-sexp -1)
         (inferior-octave-send-list-and-digest
          (list (concat (buffer-substring-no-properties (point) opoint) "\n")))
         (mapconcat 'identity inferior-octave-output-list "\n")))))

  (with-eval-after-load 'eros
    (defun +eros-octave-eval-last-sexp ()
      "Wrapper for `+octave-eval-last-sexp' that overlays results."
      (interactive)
      (eros--eval-overlay
       (+octave-eval-last-sexp)
       (point)))

    (+map-local! :keymaps 'octave-mode-map
      "e"  '(nil :wk "eval")
      "ee" #'+eros-octave-eval-last-sexp)))
#+end_src
*** me-math.el =TAIL=
#+begin_src emacs-lisp
(provide me-math)
;;; me-math.el ends here
#+end_src
** me-media.el
:properties:
:header-args: :tangle modules/me-media.el
:end:
*** me-media.el =HEAD=
#+begin_src emacs-lisp
;;; me-media.el --- Multimedia stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-media.el empv
empv 是一款 Emacs 下的音乐播放器，可以播放本地音乐文件和网络音乐资源，支持多种音频格式。empv 的特点是使用简单，快捷键容易记忆，并支持集成到 Emacs 窗口中。empv 可以使用 Emacs Lisp 的方式进行配置，例如自定义快捷键、主题等。empv 依赖于其他工具，例如 MPlayer、mpv 等。
#+begin_src emacs-lisp
(use-package empv
  :straight (:host github :repo "isamert/empv.el")
  :preface
  (defconst +mpv-available-p (executable-find "mpv"))
  :when +mpv-available-p
  :init
  (+map! :infix "o"
    "v"  '(nil :wk "empv")
    "vp" '(empv-play :wk "Play")
    "vy" '(consult-empv-youtube :wk "Seach Youtube")
    "vr" '(empv-play-radio :wk "Play radio")
    "vs" '(empv-playtlist-save-to-file :wk "Save current playlist")
    "vD" '(+empv-download-playtlist-files :wk "Download current's playlist files"))
  :custom
  ;; See: docs.invidious.io/instances/
  (empv-invidious-instance "https://invidious.projectsegfau.lt/api/v1")
  (empv-audio-dir "~/Music")
  (empv-video-dir "~/Videos")
  (empv-max-directory-search-depth 6)
  (empv-radio-log-file (expand-file-name "logged-radio-songs.org" org-directory))
  (empv-audio-file-extensions '("webm" "mp3" "ogg" "wav" "m4a" "flac" "aac" "opus"))
  :config
  (defun +empv--dl-playlist (playlist &optional dist)
    (let ((default-directory
           (or dist
               (let ((d (expand-file-name "empv-downloads" empv-audio-dir)))
                 (unless (file-directory-p d) (mkdir d t)) d)))
          (vids (seq-filter
                 #'identity ;; Filter nils
                 (mapcar
                  (lambda (item)
                    (when-let
                        ((vid (when (string-match
                                     (rx (seq "watch?v=" (group-n 1 (one-or-more (or alnum "_" "-")))))
                                     item)
                                (match-string 1 item))))
                      vid))
                  playlist)))
          (proc-name "empv-yt-dlp"))
      (unless (zerop (length vids))
        (message "Downloading %d songs to %s" (length vids) default-directory)
        (when (get-process proc-name)
          (kill-process proc-name))
        (make-process :name proc-name
                      :buffer (format "*%s*" proc-name)
                      :command (append
                                (list
                                 (executable-find "yt-dlp")
                                 "--no-abort-on-error"
                                 "--no-colors"
                                 "--extract-audio"
                                 "--no-progress"
                                 "-f" "bestaudio")
                                vids)
                      :sentinel (lambda (prc event)
                                  (when (string= event "finished\n")
                                    (message "Finished downloading playlist files!")))))))

  (defun +empv-download-playtlist-files (&optional path)
    (interactive "DSave download playlist files to: ")
    (empv--playlist-apply #'+empv--dl-playlist path)))
#+end_src
*** me-media.el emms
emms 是 Emacs 多媒体系统（Emacs Multimedia System）的缩写，是 Emacs 中一个用于播放和管理音频和视频文件的工具。其支持多种媒体文件格式，包括 Ogg、MP3、FLAC、WAV、MIDI、OGM、MPEG、AVI、FLV 等。用户可以通过 Emacs 命令界面来浏览自己的音乐和视频文件集合，并且进行播放、暂停、停止等基本操作。EMMS 还提供了一个交互式搜索功能，用户可以通过搜索关键字来查找自己的音乐和视频文件，并且进行播放操作。除此之外，EMMS 还支持 ID3 标签编辑和一些可定制的选项。
#+begin_src emacs-lisp
(use-package emms
  :straight t)
#+end_src
*** me-media.el =TAIL=
#+begin_src emacs-lisp
(provide me-media)
;;; me-media.el ends here
#+end_src
** [✘] me-modeling.el
:properties:
:header-args: :tangle no
:end:
*** me-modeling.el =HEAD=
#+begin_src emacs-lisp
;;; me-modeling.el --- Mechanical modeling stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-modeling.el
#+begin_src emacs-lisp
(use-package scad-mode
  :straight t
  :config
  (+map-local! :keymaps 'scad-mode-map
    "p" #'scad-preview)

  (with-eval-after-load 'all-the-icons
    (add-to-list
     'all-the-icons-extension-icon-alist
     '("scad" all-the-icons-fileicon "openscad" :height 0.9 :face all-the-icons-yellow)))

  (with-eval-after-load 'apheleia-formatters
    (push '(scad-mode . clang-format) apheleia-mode-alist))

  (+eglot-register 'scad-mode '("openscad-lsp" "--stdio")))

(use-package modelica-mode
  :straight t
  :mode "\\.mo\\'")
#+end_src
*** me-modeling.el =TAIL=
#+begin_src emacs-lisp
(provide me-modeling)
;;; me-modeling.el ends here
#+end_src
** me-multi-cursors.el
:properties:
:header-args: :tangle modules/me-multi-cursors.el
:end:
多光标解决方案
*** me-multi-cursors.el =HEAD=
#+begin_src emacs-lisp
;;; me-multi-cursors.el --- Programming stuff -*- lexical-binding: t; -*-
;;; Author: donney.luck@gmail.com
;;; Commentary:
;;; Code:
#+end_src
*** me-multi-cursors.el iedit
可以在多个位置同时编辑的包。它可以用来一次性编辑一个文件中的多个位置，或者在多个文件中同时编辑某些文本
#+begin_src emacs-lisp
(use-package iedit
  :straight t
  :after minemacs-lazy
  :demand t
  :preface
  (+fn-inhibit-messages! iedit-update-key-bindings))

(use-package evil-iedit-state
  :straight t
  :after iedit evil
  :demand t
  :config
  ;; Use the `iedit' key to trigger `evil-iedit-state/iedit-mode'.
  (define-key global-map iedit-toggle-key-default #'evil-iedit-state/iedit-mode))
#+end_src
*** me-multi-cursors.el
+ evil-mc 的主要功能是在一个 Emacs 缓冲区中使用多个光标，用于在多个地方进行同时编辑。它的设计初衷是模仿 Sublime Text 中的多光标功能。evil-mc 可以使用类似于 Sublime Text 中的快捷键来添加或删除光标，以及在多个光标之间切换。它还支持在多个缓冲区之间进行多光标编辑，并提供了一些用于自定义光标样式的选项。
+ evil-multiedit 的主要功能是进行文本匹配和替换，以及删除或插入一些文本。它的设计初衷是提供类似于 Sublime Text 的多选编辑和替换的功能。evil-multiedit 提供了一些可以用于匹配和选定多个文本区域的快捷键。它还支持使用正则表达式和 Emacs Lisp 表达式进行文本匹配和替换。
#+begin_src emacs-lisp
(use-package evil-mc
  :straight t
  :hook (minemacs-after-startup . global-evil-mc-mode)
  :config
  ;; Use "gz" instead of "gr", this last is mapped to `xref-find-references' in
  ;; some programming modes.
  (evil-define-key* '(normal visual) evil-mc-key-map (kbd "gr") nil)
  (evil-define-key* '(normal visual) evil-mc-key-map (kbd "gz") evil-mc-cursors-map)

  ;; Add support to repeat these commands when prefixed with a number
  (dolist (cmd '(evil-mc-make-and-goto-first-cursor evil-mc-make-and-goto-last-cursor
                 evil-mc-make-and-goto-prev-cursor evil-mc-make-and-goto-next-cursor
                 evil-mc-skip-and-goto-prev-cursor evil-mc-skip-and-goto-next-cursor
                 evil-mc-make-and-goto-prev-match evil-mc-make-and-goto-next-match
                 evil-mc-skip-and-goto-prev-match evil-mc-skip-and-goto-next-match))
    (advice-add
     cmd :around
     (lambda (fn)
       (dotimes (i (if (integerp current-prefix-arg) current-prefix-arg 1))
         (funcall fn)))))

  ;; Custom commands to execute with `evil-mc'
  (setq
   evil-mc-custom-known-commands
   '((backward-kill-word (:default . evil-mc-execute-default-call-with-count))
     (evil-escape (:default . evil-mc-execute-default-evil-normal-state))
     (evil-delete-back-to-indentation (:default . evil-mc-execute-default-call))
     (undo-fu-only-redo (:default . evil-mc-execute-default-redo))
     (undo-fu-only-undo (:default . evil-mc-execute-default-undo))
     (corfu-complete (:default . evil-mc-execute-default-complete))
     (evil-numbers/dec-at-pt-incremental (:default . evil-mc-execute-default-call-with-count))
     (evil-numbers/inc-at-pt-incremental (:default . evil-mc-execute-default-call-with-count))
     (evil-org-delete (:default . evil-mc-execute-default-evil-delete))
     (ess-smart-comma (:default . evil-mc-execute-call))
     (evil-digit-argument-or-evil-beginning-of-visual-line
      (:default . evil-mc-execute-default-call)
      (visual . evil-mc-execute-visual-call)))))

(use-package me-evil-mc-evil-escape
  :after evil-mc evil-escape
  :demand t)

(use-package evil-multiedit
  :straight t
  :after iedit evil
  :demand t
  :init
  (+nvmap! :infix "g"
    "ze" '(nil :wk "evil-multiedit")
    "zem" #'evil-multiedit-match-all
    "zed" #'evil-multiedit-match-and-next
    "zeD" #'evil-multiedit-match-and-prev
    "zes" #'evil-multiedit-match-symbol-and-next
    "zeS" #'evil-multiedit-match-symbol-and-prev
    "zen" #'evil-multiedit-next
    "zeN" #'evil-multiedit-prev
    "zet" #'evil-multiedit-toggle-or-restrict-region
    "zeT" #'evil-multiedit-toggle-marker-here
    "zeq" #'evil-multiedit-abort)
  :config
  (evil-multiedit-default-keybinds))
#+end_src
*** me-multi-cursors.el =TAIL=
#+begin_src emacs-lisp
(provide me-multi-cursors)
;;; me-multi-cursors.el ends here
#+end_src
